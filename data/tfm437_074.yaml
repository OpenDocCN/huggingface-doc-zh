- en: Training on TPU with TensorFlow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä½¿ç”¨TensorFlowåœ¨TPUä¸Šè®­ç»ƒ
- en: 'Original text: [https://huggingface.co/docs/transformers/v4.37.2/en/perf_train_tpu_tf](https://huggingface.co/docs/transformers/v4.37.2/en/perf_train_tpu_tf)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸå§‹æ–‡æœ¬ï¼š[https://huggingface.co/docs/transformers/v4.37.2/en/perf_train_tpu_tf](https://huggingface.co/docs/transformers/v4.37.2/en/perf_train_tpu_tf)
- en: null
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: If you donâ€™t need long explanations and just want TPU code samples to get started
    with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨ä¸éœ€è¦é•¿ç¯‡è§£é‡Šï¼Œåªæƒ³è¦TPUä»£ç ç¤ºä¾‹æ¥å¼€å§‹ä½¿ç”¨ï¼Œè¯·æŸ¥çœ‹[æˆ‘ä»¬çš„TPUç¤ºä¾‹ç¬”è®°æœ¬ï¼](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)
- en: What is a TPU?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä»€ä¹ˆæ˜¯TPUï¼Ÿ
- en: A TPU is a **Tensor Processing Unit.** They are hardware designed by Google,
    which are used to greatly speed up the tensor computations within neural networks,
    much like GPUs. They can be used for both network training and inference. They
    are generally accessed through Googleâ€™s cloud services, but small TPUs can also
    be accessed directly for free through Google Colab and Kaggle Kernels.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TPUæ˜¯**å¼ é‡å¤„ç†å•å…ƒ**ã€‚å®ƒä»¬æ˜¯ç”±Googleè®¾è®¡çš„ç¡¬ä»¶ï¼Œç”¨äºå¤§å¤§åŠ é€Ÿç¥ç»ç½‘ç»œä¸­çš„å¼ é‡è®¡ç®—ï¼Œç±»ä¼¼äºGPUã€‚å®ƒä»¬å¯ç”¨äºç½‘ç»œè®­ç»ƒå’Œæ¨æ–­ã€‚é€šå¸¸é€šè¿‡Googleçš„äº‘æœåŠ¡è®¿é—®ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡Google
    Colabå’ŒKaggle Kernelsç›´æ¥å…è´¹è®¿é—®å°å‹TPUã€‚
- en: Because [all TensorFlow models in ğŸ¤— Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy),
    most of the methods in this document are generally applicable to TPU training
    for any Keras model! However, there are a few points that are specific to the
    HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and weâ€™ll
    make sure to flag them up when we get to them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º[ğŸ¤— Transformersä¸­çš„æ‰€æœ‰TensorFlowæ¨¡å‹éƒ½æ˜¯Kerasæ¨¡å‹](https://huggingface.co/blog/tensorflow-philosophy)ï¼Œå› æ­¤æœ¬æ–‡æ¡£ä¸­çš„å¤§å¤šæ•°æ–¹æ³•é€šå¸¸é€‚ç”¨äºä»»ä½•Kerasæ¨¡å‹çš„TPUè®­ç»ƒï¼ä½†æ˜¯ï¼Œæœ‰ä¸€äº›ç‚¹æ˜¯ç‰¹å®šäºHuggingFaceç”Ÿæ€ç³»ç»Ÿï¼ˆhug-o-systemï¼Ÿï¼‰çš„Transformerså’ŒDatasetsï¼Œå½“æˆ‘ä»¬åˆ°è¾¾è¿™äº›ç‚¹æ—¶ï¼Œæˆ‘ä»¬å°†ç¡®ä¿æ ‡è®°å®ƒä»¬ã€‚
- en: What kinds of TPU are available?
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æœ‰å“ªäº›ç±»å‹çš„TPUå¯ç”¨ï¼Ÿ
- en: New users are often very confused by the range of TPUs, and the different ways
    to access them. The first key distinction to understand is the difference between
    **TPU Nodes** and **TPU VMs.**
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æ–°ç”¨æˆ·ç»å¸¸å¯¹å„ç§TPUå’Œè®¿é—®æ–¹å¼æ„Ÿåˆ°å›°æƒ‘ã€‚è¦ç†è§£çš„ç¬¬ä¸€ä¸ªå…³é”®åŒºåˆ«æ˜¯**TPUèŠ‚ç‚¹**å’Œ**TPU VM**ä¹‹é—´çš„åŒºåˆ«ã€‚
- en: When you use a **TPU Node**, you are effectively indirectly accessing a remote
    TPU. You will need a separate VM, which will initialize your network and data
    pipeline and then forward them to the remote node. When you use a TPU on Google
    Colab, you are accessing it in the **TPU Node** style.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ‚¨ä½¿ç”¨**TPUèŠ‚ç‚¹**æ—¶ï¼Œå®é™…ä¸Šæ˜¯é—´æ¥è®¿é—®è¿œç¨‹TPUã€‚æ‚¨å°†éœ€è¦ä¸€ä¸ªå•ç‹¬çš„VMï¼Œè¯¥VMå°†åˆå§‹åŒ–æ‚¨çš„ç½‘ç»œå’Œæ•°æ®ç®¡é“ï¼Œç„¶åå°†å®ƒä»¬è½¬å‘åˆ°è¿œç¨‹èŠ‚ç‚¹ã€‚å½“æ‚¨åœ¨Google
    Colabä¸Šä½¿ç”¨TPUæ—¶ï¼Œæ‚¨æ˜¯ä»¥**TPUèŠ‚ç‚¹**æ ·å¼è®¿é—®å®ƒã€‚
- en: Using TPU Nodes can have some quite unexpected behaviour for people who arenâ€™t
    used to them! In particular, because the TPU is located on a physically different
    system to the machine youâ€™re running your Python code on, your data cannot be
    local to your machine - any data pipeline that loads from your machineâ€™s internal
    storage will totally fail! Instead, data must be stored in Google Cloud Storage
    where your data pipeline can still access it, even when the pipeline is running
    on the remote TPU node.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºä¸ä¹ æƒ¯ä½¿ç”¨TPUçš„äººæ¥è¯´ï¼Œä½¿ç”¨TPUèŠ‚ç‚¹å¯èƒ½ä¼šäº§ç”Ÿä¸€äº›æ„æƒ³ä¸åˆ°çš„è¡Œä¸ºï¼ç‰¹åˆ«æ˜¯ï¼Œå› ä¸ºTPUä½äºä¸è¿è¡ŒPythonä»£ç çš„æœºå™¨ç‰©ç†ä¸Šä¸åŒçš„ç³»ç»Ÿä¸Šï¼Œæ‚¨çš„æ•°æ®ä¸èƒ½æ˜¯æœ¬åœ°çš„
    - ä»æ‚¨æœºå™¨çš„å†…éƒ¨å­˜å‚¨åŠ è½½çš„ä»»ä½•æ•°æ®ç®¡é“å°†å®Œå…¨å¤±è´¥ï¼ç›¸åï¼Œæ•°æ®å¿…é¡»å­˜å‚¨åœ¨Google Cloud Storageä¸­ï¼Œæ‚¨çš„æ•°æ®ç®¡é“ä»ç„¶å¯ä»¥è®¿é—®å®ƒï¼Œå³ä½¿ç®¡é“åœ¨è¿œç¨‹TPUèŠ‚ç‚¹ä¸Šè¿è¡Œã€‚
- en: If you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then
    you can `fit()` on that data even when using Colab or a TPU Node, without needing
    to upload it to Google Cloud Storage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨å¯ä»¥å°†æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨å†…å­˜ä¸­ä½œä¸º`np.ndarray`æˆ–`tf.Tensor`ï¼Œé‚£ä¹ˆå³ä½¿åœ¨ä½¿ç”¨Colabæˆ–TPUèŠ‚ç‚¹æ—¶ï¼Œä¹Ÿå¯ä»¥åœ¨è¯¥æ•°æ®ä¸Šè¿›è¡Œ`fit()`ï¼Œè€Œæ— éœ€å°†å…¶ä¸Šä¼ åˆ°Google
    Cloud Storageã€‚
- en: '**ğŸ¤—Specific Hugging Face TipğŸ¤—:** The methods `Dataset.to_tf_dataset()` and
    its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout
    our TF code examples, will both fail on a TPU Node. The reason for this is that
    even though they create a `tf.data.Dataset` it is not a â€œpureâ€ `tf.data` pipeline
    and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from
    the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by
    data that is on a local disc and which the remote TPU Node will not be able to
    read.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**ğŸ¤—å…·ä½“çš„Hugging Faceæç¤ºğŸ¤—ï¼š**`Dataset.to_tf_dataset()`æ–¹æ³•åŠå…¶æ›´é«˜çº§åˆ«çš„åŒ…è£…å™¨`model.prepare_tf_dataset()`ï¼Œæ‚¨å°†åœ¨æˆ‘ä»¬çš„TFä»£ç ç¤ºä¾‹ä¸­çœ‹åˆ°ï¼Œéƒ½ä¼šåœ¨TPUèŠ‚ç‚¹ä¸Šå¤±è´¥ã€‚åŸå› æ˜¯å³ä½¿å®ƒä»¬åˆ›å»ºäº†ä¸€ä¸ª`tf.data.Dataset`ï¼Œå®ƒä¹Ÿä¸æ˜¯â€œçº¯ç²¹â€çš„`tf.data`ç®¡é“ï¼Œå¹¶ä¸”ä½¿ç”¨`tf.numpy_function`æˆ–`Dataset.from_generator()`ä»åº•å±‚HuggingFace`Dataset`ä¸­æµå¼ä¼ è¾“æ•°æ®ã€‚è¿™ä¸ªHuggingFace`Dataset`ç”±å­˜å‚¨åœ¨æœ¬åœ°ç£ç›˜ä¸Šçš„æ•°æ®æ”¯æŒï¼Œè¿œç¨‹TPUèŠ‚ç‚¹å°†æ— æ³•è¯»å–ã€‚'
- en: The second way to access a TPU is via a **TPU VM.** When using a TPU VM, you
    connect directly to the machine that the TPU is attached to, much like training
    on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes
    to your data pipeline. All of the above warnings do not apply to TPU VMs!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç§è®¿é—®TPUçš„æ–¹å¼æ˜¯é€šè¿‡**TPU VM**ã€‚åœ¨ä½¿ç”¨TPU VMæ—¶ï¼Œæ‚¨ç›´æ¥è¿æ¥åˆ°TPUè¿æ¥çš„æœºå™¨ï¼Œå°±åƒåœ¨GPU VMä¸Šè¿›è¡Œè®­ç»ƒä¸€æ ·ã€‚TPU VMé€šå¸¸æ›´å®¹æ˜“ä½¿ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†æ•°æ®ç®¡é“æ—¶ã€‚æ‰€æœ‰ä¸Šè¿°è­¦å‘Šä¸é€‚ç”¨äºTPU
    VMï¼
- en: 'This is an opinionated document, so hereâ€™s our opinion: **Avoid using TPU Node
    if possible.** It is more confusing and more difficult to debug than TPU VMs.
    It is also likely to be unsupported in future - Googleâ€™s latest TPU, TPUv4, can
    only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going
    to become a â€œlegacyâ€ access method. However, we understand that the only free
    TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so weâ€™ll try
    to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)
    for code samples that explain this in more detail.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä»½ä¸»è§‚çš„æ–‡ä»¶ï¼Œæ‰€ä»¥è¿™æ˜¯æˆ‘ä»¬çš„æ„è§ï¼š**å°½é‡é¿å…ä½¿ç”¨TPU Nodeã€‚**å®ƒæ¯”TPU VMæ›´ä»¤äººå›°æƒ‘ï¼Œæ›´éš¾ä»¥è°ƒè¯•ã€‚æœªæ¥ä¹Ÿå¯èƒ½ä¸å—æ”¯æŒ - è°·æ­Œæœ€æ–°çš„TPUï¼ŒTPUv4ï¼Œåªèƒ½ä½œä¸ºTPU
    VMè®¿é—®ï¼Œè¿™è¡¨æ˜TPU Nodeè¶Šæ¥è¶Šå¯èƒ½æˆä¸ºâ€œä¼ ç»Ÿâ€è®¿é—®æ–¹æ³•ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬äº†è§£åˆ°å”¯ä¸€å…è´¹çš„TPUè®¿é—®æ˜¯åœ¨Colabå’ŒKaggle Kernelsä¸Šï¼Œå®ƒä»¬ä½¿ç”¨TPU
    Node - å› æ­¤ï¼Œå¦‚æœå¿…é¡»ä½¿ç”¨ï¼Œæˆ‘ä»¬å°†å°è¯•è§£é‡Šå¦‚ä½•å¤„ç†ï¼æŸ¥çœ‹[TPUç¤ºä¾‹ç¬”è®°æœ¬](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)ä»¥è·å–æ›´è¯¦ç»†çš„ä»£ç ç¤ºä¾‹ã€‚
- en: What sizes of TPU are available?
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¯ç”¨çš„TPUå°ºå¯¸æ˜¯å¤šå°‘ï¼Ÿ
- en: A single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that
    can run hundreds or thousands of replicas simultaneously. When you use more than
    a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet
    is referred to as a **pod slice.**
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å•ä¸ªTPUï¼ˆv2-8/v3-8/v4-8ï¼‰è¿è¡Œ8ä¸ªå‰¯æœ¬ã€‚TPUå­˜åœ¨äºå¯ä»¥åŒæ—¶è¿è¡Œæ•°ç™¾æˆ–æ•°åƒä¸ªå‰¯æœ¬çš„**pod**ä¸­ã€‚å½“æ‚¨ä½¿ç”¨å¤šä¸ªTPUä½†å°‘äºæ•´ä¸ªpodæ—¶ï¼ˆä¾‹å¦‚v3-32ï¼‰ï¼Œæ‚¨çš„TPUç¾¤è¢«ç§°ä¸º**pod
    slice**ã€‚
- en: When you access a free TPU via Colab, you generally get a single v2-8 TPU.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ‚¨é€šè¿‡Colabè®¿é—®å…è´¹çš„TPUæ—¶ï¼Œé€šå¸¸ä¼šè·å¾—ä¸€ä¸ªv2-8 TPUã€‚
- en: I keep hearing about this XLA thing. Whatâ€™s XLA, and how does it relate to TPUs?
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æˆ‘ä¸€ç›´å¬è¯´è¿™ä¸ªXLAã€‚XLAæ˜¯ä»€ä¹ˆï¼Œå®ƒä¸TPUæœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿ
- en: XLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is
    the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!).
    The easiest way to enable it when training a Keras model is to pass the argument
    `jit_compile=True` to `model.compile()`. If you donâ€™t get any errors and performance
    is good, thatâ€™s a great sign that youâ€™re ready to move to TPU!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: XLAæ˜¯ä¸€ä¸ªä¼˜åŒ–ç¼–è¯‘å™¨ï¼Œè¢«TensorFlowå’ŒJAXåŒæ—¶ä½¿ç”¨ã€‚åœ¨JAXä¸­ï¼Œå®ƒæ˜¯å”¯ä¸€çš„ç¼–è¯‘å™¨ï¼Œè€Œåœ¨TensorFlowä¸­æ˜¯å¯é€‰çš„ï¼ˆä½†åœ¨TPUä¸Šæ˜¯å¼ºåˆ¶çš„ï¼ï¼‰ã€‚åœ¨è®­ç»ƒKerasæ¨¡å‹æ—¶å¯ç”¨å®ƒçš„æœ€ç®€å•æ–¹æ³•æ˜¯å°†å‚æ•°`jit_compile=True`ä¼ é€’ç»™`model.compile()`ã€‚å¦‚æœæ²¡æœ‰å‡ºç°ä»»ä½•é”™è¯¯ä¸”æ€§èƒ½è‰¯å¥½ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è¿¹è±¡ï¼Œè¡¨æ˜æ‚¨å·²å‡†å¤‡å¥½è½¬ç§»åˆ°TPUï¼
- en: Debugging on TPU is generally a bit harder than on CPU/GPU, so we recommend
    getting your code running on CPU/GPU with XLA first before trying it on TPU. You
    donâ€™t have to train for long, of course - just for a few steps to make sure that
    your model and data pipeline are working like you expect them to.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨TPUä¸Šè¿›è¡Œè°ƒè¯•é€šå¸¸æ¯”åœ¨CPU/GPUä¸Šæ›´å›°éš¾ï¼Œå› æ­¤æˆ‘ä»¬å»ºè®®åœ¨å°è¯•åœ¨TPUä¸Šè¿è¡Œä¹‹å‰ï¼Œå…ˆåœ¨CPU/GPUä¸Šä½¿ç”¨XLAä½¿æ‚¨çš„ä»£ç èƒ½å¤Ÿè¿è¡Œã€‚å½“ç„¶ï¼Œæ‚¨ä¸å¿…è®­ç»ƒå¾ˆé•¿æ—¶é—´
    - åªéœ€è¿›è¡Œå‡ ä¸ªæ­¥éª¤ï¼Œä»¥ç¡®ä¿æ‚¨çš„æ¨¡å‹å’Œæ•°æ®æµæ°´çº¿æŒ‰ç…§æ‚¨çš„é¢„æœŸå·¥ä½œã€‚
- en: XLA compiled code is usually faster - so even if youâ€™re not planning to run
    on TPU, adding `jit_compile=True` can improve your performance. Be sure to note
    the caveats below about XLA compatibility, though!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: XLAç¼–è¯‘çš„ä»£ç é€šå¸¸æ›´å¿« - å› æ­¤ï¼Œå³ä½¿æ‚¨ä¸æ‰“ç®—åœ¨TPUä¸Šè¿è¡Œï¼Œæ·»åŠ `jit_compile=True`ä¹Ÿå¯ä»¥æé«˜æ€§èƒ½ã€‚ä½†æ˜¯ï¼Œè¯·æ³¨æ„ä¸‹é¢å…³äºXLAå…¼å®¹æ€§çš„æ³¨æ„äº‹é¡¹ï¼
- en: '**Tip born of painful experience:** Although using `jit_compile=True` is a
    good way to get a speed boost and test if your CPU/GPU code is XLA-compatible,
    it can actually cause a lot of problems if you leave it in when actually training
    on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that
    line before actually running your code on a TPU!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**åŸºäºç—›è‹¦ç»éªŒçš„æç¤ºï¼š**è™½ç„¶ä½¿ç”¨`jit_compile=True`æ˜¯è·å¾—é€Ÿåº¦æå‡å¹¶æµ‹è¯•æ‚¨çš„CPU/GPUä»£ç æ˜¯å¦ä¸XLAå…¼å®¹çš„å¥½æ–¹æ³•ï¼Œä½†å¦‚æœåœ¨å®é™…åœ¨TPUä¸Šè®­ç»ƒæ—¶ä¿ç•™å®ƒï¼Œå¯èƒ½ä¼šå¯¼è‡´è®¸å¤šé—®é¢˜ã€‚XLAç¼–è¯‘å°†åœ¨TPUä¸Šéšå¼å‘ç”Ÿï¼Œå› æ­¤åœ¨å®é™…åœ¨TPUä¸Šè¿è¡Œä»£ç ä¹‹å‰ï¼Œè¯·è®°å¾—åˆ é™¤é‚£è¡Œï¼'
- en: How do I make my model XLA compatible?
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¦‚ä½•ä½¿æˆ‘çš„æ¨¡å‹ä¸XLAå…¼å®¹ï¼Ÿ
- en: 'In many cases, your code is probably XLA-compatible already! However, there
    are a few things that work in normal TensorFlow that donâ€™t work in XLA. Weâ€™ve
    distilled them into three core rules below:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œæ‚¨çš„ä»£ç å¯èƒ½å·²ç»ä¸XLAå…¼å®¹ï¼ä½†æ˜¯ï¼Œæœ‰ä¸€äº›åœ¨æ™®é€šTensorFlowä¸­æœ‰æ•ˆä½†åœ¨XLAä¸­æ— æ•ˆçš„äº‹æƒ…ã€‚æˆ‘ä»¬å°†å®ƒä»¬æ¦‚æ‹¬ä¸ºä»¥ä¸‹ä¸‰æ¡æ ¸å¿ƒè§„åˆ™ï¼š
- en: '**ğŸ¤—Specific HuggingFace TipğŸ¤—:** Weâ€™ve put a lot of effort into rewriting our
    TensorFlow models and loss functions to be XLA-compatible. Our models and loss
    functions generally obey rule #1 and #2 by default, so you can skip over them
    if youâ€™re using `transformers` models. Donâ€™t forget about these rules when writing
    your own models and loss functions, though!'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**ğŸ¤—å…·ä½“çš„HuggingFaceæç¤ºğŸ¤—ï¼š**æˆ‘ä»¬å·²ç»ä»˜å‡ºäº†å¾ˆå¤šåŠªåŠ›ï¼Œå°†æˆ‘ä»¬çš„TensorFlowæ¨¡å‹å’ŒæŸå¤±å‡½æ•°é‡å†™ä¸ºXLAå…¼å®¹ã€‚æˆ‘ä»¬çš„æ¨¡å‹å’ŒæŸå¤±å‡½æ•°é€šå¸¸é»˜è®¤éµå®ˆè§„åˆ™ï¼ƒ1å’Œï¼ƒ2ï¼Œå› æ­¤å¦‚æœæ‚¨ä½¿ç”¨`transformers`æ¨¡å‹ï¼Œåˆ™å¯ä»¥è·³è¿‡å®ƒä»¬ã€‚ä½†æ˜¯ï¼Œåœ¨ç¼–å†™è‡ªå·±çš„æ¨¡å‹å’ŒæŸå¤±å‡½æ•°æ—¶ï¼Œè¯·ä¸è¦å¿˜è®°è¿™äº›è§„åˆ™ï¼'
- en: 'XLA Rule #1: Your code cannot have â€œdata-dependent conditionalsâ€'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: XLAè§„åˆ™ï¼ƒ1ï¼šæ‚¨çš„ä»£ç ä¸èƒ½å…·æœ‰â€œæ•°æ®ç›¸å…³æ¡ä»¶â€
- en: What that means is that any `if` statement cannot depend on values inside a
    `tf.Tensor`. For example, this code block cannot be compiled with XLA!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€ä»»ä½•`if`è¯­å¥éƒ½ä¸èƒ½ä¾èµ–äº`tf.Tensor`å†…éƒ¨çš„å€¼ã€‚ä¾‹å¦‚ï¼Œæ­¤ä»£ç å—æ— æ³•ä½¿ç”¨XLAç¼–è¯‘ï¼
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This might seem very restrictive at first, but most neural net code doesnâ€™t
    need to do this. You can often get around this restriction by using `tf.cond`
    (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond))
    or by removing the conditional and finding a clever math trick with indicator
    variables instead, like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸€å¼€å§‹å¯èƒ½çœ‹èµ·æ¥éå¸¸å—é™åˆ¶ï¼Œä½†å¤§å¤šæ•°ç¥ç»ç½‘ç»œä»£ç ä¸éœ€è¦è¿™æ ·åšã€‚æ‚¨é€šå¸¸å¯ä»¥é€šè¿‡ä½¿ç”¨`tf.cond`ï¼ˆè¯·å‚é˜…[æ­¤å¤„](https://www.tensorflow.org/api_docs/python/tf/cond)çš„æ–‡æ¡£ï¼‰æˆ–é€šè¿‡åˆ é™¤æ¡ä»¶å¹¶æ‰¾åˆ°ä¸€ä¸ªå·§å¦™çš„æ•°å­¦æŠ€å·§æ¥ç»•è¿‡æ­¤é™åˆ¶ï¼Œä¾‹å¦‚ï¼š
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code has exactly the same effect as the code above, but by avoiding a conditional,
    we ensure it will compile with XLA without problems!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç ä¸ä¸Šé¢çš„ä»£ç å…·æœ‰å®Œå…¨ç›¸åŒçš„æ•ˆæœï¼Œä½†é€šè¿‡é¿å…æ¡ä»¶è¯­å¥ï¼Œæˆ‘ä»¬ç¡®ä¿å®ƒå°†åœ¨XLAä¸­ç¼–è¯‘è€Œæ— é—®é¢˜ï¼
- en: 'XLA Rule #2: Your code cannot have â€œdata-dependent shapesâ€'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: XLAè§„åˆ™ï¼ƒ2ï¼šæ‚¨çš„ä»£ç ä¸èƒ½å…·æœ‰â€œæ•°æ®ç›¸å…³å½¢çŠ¶â€
- en: What this means is that the shape of all of the `tf.Tensor` objects in your
    code cannot depend on their values. For example, the function `tf.unique` cannot
    be compiled with XLA, because it returns a `tensor` containing one instance of
    each unique value in the input. The shape of this output will obviously be different
    depending on how repetitive the input `Tensor` was, and so XLA refuses to handle
    it!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€ä»£ç ä¸­æ‰€æœ‰çš„`tf.Tensor`å¯¹è±¡çš„å½¢çŠ¶ä¸èƒ½ä¾èµ–äºå®ƒä»¬çš„å€¼ã€‚ä¾‹å¦‚ï¼Œå‡½æ•°`tf.unique`ä¸èƒ½ä¸XLAä¸€èµ·ç¼–è¯‘ï¼Œå› ä¸ºå®ƒè¿”å›ä¸€ä¸ªåŒ…å«è¾“å…¥ä¸­æ¯ä¸ªå”¯ä¸€å€¼çš„`tensor`ã€‚è¿™ä¸ªè¾“å‡ºçš„å½¢çŠ¶æ˜¾ç„¶ä¼šæ ¹æ®è¾“å…¥`Tensor`çš„é‡å¤ç¨‹åº¦è€Œä¸åŒï¼Œå› æ­¤XLAæ‹’ç»å¤„ç†å®ƒï¼
- en: 'In general, most neural network code obeys rule #2 by default. However, there
    are a few common cases where it becomes a problem. One very common one is when
    you use **label masking**, setting your labels to a negative value to indicate
    that those positions should be ignored when computing the loss. If you look at
    NumPy or PyTorch loss functions that support label masking, you will often see
    code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€èˆ¬æ¥è¯´ï¼Œå¤§å¤šæ•°ç¥ç»ç½‘ç»œä»£ç é»˜è®¤éµå®ˆè§„åˆ™ï¼ƒ2ã€‚ä½†æ˜¯ï¼Œåœ¨ä¸€äº›å¸¸è§æƒ…å†µä¸‹ï¼Œè¿™å¯èƒ½ä¼šæˆä¸ºä¸€ä¸ªé—®é¢˜ã€‚ä¸€ä¸ªéå¸¸å¸¸è§çš„æƒ…å†µæ˜¯å½“æ‚¨ä½¿ç”¨**æ ‡ç­¾å±è”½**æ—¶ï¼Œå°†æ ‡ç­¾è®¾ç½®ä¸ºè´Ÿå€¼ä»¥æŒ‡ç¤ºåœ¨è®¡ç®—æŸå¤±æ—¶åº”å¿½ç•¥è¿™äº›ä½ç½®ã€‚å¦‚æœæ‚¨æŸ¥çœ‹æ”¯æŒæ ‡ç­¾å±è”½çš„NumPyæˆ–PyTorchæŸå¤±å‡½æ•°ï¼Œæ‚¨ç»å¸¸ä¼šçœ‹åˆ°ç±»ä¼¼äºä½¿ç”¨[å¸ƒå°”ç´¢å¼•](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing)çš„ä»£ç ï¼š
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because
    the shape of `masked_outputs` and `masked_labels` depends on how many positions
    are masked - that makes it a **data-dependent shape.** However, just like for
    rule #1, we can often rewrite this code to yield exactly the same output without
    any data-dependent shapes.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç åœ¨NumPyæˆ–PyTorchä¸­å®Œå…¨æ­£å¸¸ï¼Œä½†åœ¨XLAä¸­ä¼šå‡ºé”™ï¼ä¸ºä»€ä¹ˆï¼Ÿå› ä¸º`masked_outputs`å’Œ`masked_labels`çš„å½¢çŠ¶å–å†³äºæœ‰å¤šå°‘ä½ç½®è¢«å±è”½
    - è¿™ä½¿å…¶æˆä¸º**æ•°æ®ç›¸å…³å½¢çŠ¶ã€‚**ç„¶è€Œï¼Œå°±åƒè§„åˆ™ï¼ƒ1ä¸€æ ·ï¼Œæˆ‘ä»¬é€šå¸¸å¯ä»¥é‡å†™è¿™æ®µä»£ç ï¼Œä»¥äº§ç”Ÿå®Œå…¨ç›¸åŒçš„è¾“å‡ºï¼Œè€Œä¸æ¶‰åŠä»»ä½•æ•°æ®ç›¸å…³å½¢çŠ¶ã€‚
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we avoid data-dependent shapes by computing the loss for every position,
    but zeroing out the masked positions in both the numerator and denominator when
    we calculate the mean, which yields exactly the same result as the first block
    while maintaining XLA compatibility. Note that we use the same trick as in rule
    #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable.
    This is a really useful trick, so remember it if you need to convert your own
    code to XLA!'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬é€šè¿‡ä¸ºæ¯ä¸ªä½ç½®è®¡ç®—æŸå¤±ï¼Œä½†åœ¨è®¡ç®—å‡å€¼æ—¶å°†è¢«å±è”½çš„ä½ç½®åœ¨åˆ†å­å’Œåˆ†æ¯ä¸­å½’é›¶ï¼Œä»è€Œè·å¾—ä¸ç¬¬ä¸€ä¸ªå—å®Œå…¨ç›¸åŒçš„ç»“æœï¼ŒåŒæ—¶ä¿æŒXLAå…¼å®¹æ€§ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸è§„åˆ™ï¼ƒ1ç›¸åŒçš„æŠ€å·§
    - å°†`tf.bool`è½¬æ¢ä¸º`tf.float32`å¹¶å°†å…¶ç”¨ä½œæŒ‡ç¤ºå˜é‡ã€‚è¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„æŠ€å·§ï¼Œæ‰€ä»¥å¦‚æœæ‚¨éœ€è¦å°†è‡ªå·±çš„ä»£ç è½¬æ¢ä¸ºXLAï¼Œè¯·è®°ä½å®ƒï¼
- en: 'XLA Rule #3: XLA will need to recompile your model for every different input
    shape it sees'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: XLAè§„åˆ™ï¼ƒ3ï¼šXLAå°†éœ€è¦ä¸ºæ¯ä¸ªä¸åŒçš„è¾“å…¥å½¢çŠ¶é‡æ–°ç¼–è¯‘æ‚¨çš„æ¨¡å‹
- en: This is the big one. What this means is that if your input shapes are very variable,
    XLA will have to recompile your model over and over, which will create huge performance
    problems. This commonly arises in NLP models, where input texts have variable
    lengths after tokenization. In other modalities, static shapes are more common
    and this rule is much less of a problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªé‡è¦çš„è§„åˆ™ã€‚è¿™æ„å‘³ç€å¦‚æœæ‚¨çš„è¾“å…¥å½¢çŠ¶éå¸¸ä¸åŒï¼ŒXLAå°†ä¸å¾—ä¸ä¸€éåˆä¸€éåœ°é‡æ–°ç¼–è¯‘æ‚¨çš„æ¨¡å‹ï¼Œè¿™å°†å¯¼è‡´å·¨å¤§çš„æ€§èƒ½é—®é¢˜ã€‚è¿™åœ¨NLPæ¨¡å‹ä¸­ç»å¸¸å‡ºç°ï¼Œå› ä¸ºè¾“å…¥æ–‡æœ¬åœ¨æ ‡è®°åŒ–åé•¿åº¦ä¸åŒã€‚åœ¨å…¶ä»–æ¨¡æ€ä¸­ï¼Œé™æ€å½¢çŠ¶æ›´å¸¸è§ï¼Œè¿™ä¸ªè§„åˆ™å°±ä¸æ˜¯é‚£ä¹ˆå¤§çš„é—®é¢˜äº†ã€‚
- en: 'How can you get around rule #3? The key is **padding** - if you pad all your
    inputs to the same length, and then use an `attention_mask`, you can get the same
    results as youâ€™d get from variable shapes, but without any XLA issues. However,
    excessive padding can cause severe slowdown too - if you pad all your samples
    to the maximum length in the whole dataset, you might end up with batches consisting
    endless padding tokens, which will waste a lot of compute and memory!'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½•é¿å¼€è§„åˆ™ï¼ƒ3ï¼Ÿå…³é”®æ˜¯**å¡«å……** - å¦‚æœæ‚¨å°†æ‰€æœ‰è¾“å…¥å¡«å……åˆ°ç›¸åŒçš„é•¿åº¦ï¼Œç„¶åä½¿ç”¨`attention_mask`ï¼Œæ‚¨å¯ä»¥è·å¾—ä¸å¯å˜å½¢çŠ¶ç›¸åŒçš„ç»“æœï¼Œä½†æ²¡æœ‰ä»»ä½•XLAé—®é¢˜ã€‚ç„¶è€Œï¼Œè¿‡åº¦å¡«å……ä¹Ÿä¼šå¯¼è‡´ä¸¥é‡çš„å‡é€Ÿ
    - å¦‚æœæ‚¨å°†æ‰€æœ‰æ ·æœ¬å¡«å……åˆ°æ•´ä¸ªæ•°æ®é›†ä¸­çš„æœ€å¤§é•¿åº¦ï¼Œæ‚¨å¯èƒ½ä¼šå¾—åˆ°ç”±æ— å°½å¡«å……æ ‡è®°ç»„æˆçš„æ‰¹æ¬¡ï¼Œè¿™å°†æµªè´¹å¤§é‡è®¡ç®—å’Œå†…å­˜ï¼
- en: There isnâ€™t a perfect solution to this problem. However, you can try some tricks.
    One very useful trick is to **pad batches of samples up to a multiple of a number
    like 32 or 64 tokens.** This often only increases the number of tokens by a small
    amount, but it hugely reduces the number of unique input shapes, because every
    input shape now has to be a multiple of 32 or 64\. Fewer unique input shapes means
    fewer XLA compilations!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è§£å†³è¿™ä¸ªé—®é¢˜å¹¶æ²¡æœ‰å®Œç¾çš„æ–¹æ³•ã€‚ä½†æ˜¯ï¼Œä½ å¯ä»¥å°è¯•ä¸€äº›æŠ€å·§ã€‚ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„æŠ€å·§æ˜¯**å°†æ ·æœ¬æ‰¹æ¬¡å¡«å……åˆ°32æˆ–64ä¸ªæ ‡è®°çš„å€æ•°ã€‚**è¿™é€šå¸¸åªä¼šå¢åŠ å°‘é‡æ ‡è®°çš„æ•°é‡ï¼Œä½†ä¼šå¤§å¤§å‡å°‘å”¯ä¸€è¾“å…¥å½¢çŠ¶çš„æ•°é‡ï¼Œå› ä¸ºç°åœ¨æ¯ä¸ªè¾“å…¥å½¢çŠ¶éƒ½å¿…é¡»æ˜¯32æˆ–64çš„å€æ•°ã€‚æ›´å°‘çš„å”¯ä¸€è¾“å…¥å½¢çŠ¶æ„å‘³ç€æ›´å°‘çš„XLAç¼–è¯‘ï¼
- en: '**ğŸ¤—Specific HuggingFace TipğŸ¤—:** Our tokenizers and data collators have methods
    that can help you here. You can use `padding="max_length"` or `padding="longest"`
    when calling tokenizers to get them to output padded data. Our tokenizers and
    data collators also have a `pad_to_multiple_of` argument that you can use to reduce
    the number of unique input shapes you see!'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**ğŸ¤—HuggingFaceä¸“å±æç¤ºğŸ¤—ï¼š**æˆ‘ä»¬çš„åˆ†è¯å™¨å’Œæ•°æ®æ•´ç†å™¨æœ‰åŠ©äºè§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•ã€‚åœ¨è°ƒç”¨åˆ†è¯å™¨æ—¶ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨`padding="max_length"`æˆ–`padding="longest"`æ¥è·å–å¡«å……æ•°æ®ã€‚æˆ‘ä»¬çš„åˆ†è¯å™¨å’Œæ•°æ®æ•´ç†å™¨è¿˜æœ‰ä¸€ä¸ª`pad_to_multiple_of`å‚æ•°ï¼Œå¯ä»¥å‡å°‘æ‚¨çœ‹åˆ°çš„å”¯ä¸€è¾“å…¥å½¢çŠ¶çš„æ•°é‡ï¼'
- en: How do I actually train my model on TPU?
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æˆ‘å¦‚ä½•åœ¨TPUä¸Šå®é™…è®­ç»ƒæˆ‘çš„æ¨¡å‹ï¼Ÿ
- en: Once your training is XLA-compatible and (if youâ€™re using TPU Node / Colab)
    your dataset has been prepared appropriately, running on TPU is surprisingly easy!
    All you really need to change in your code is to add a few lines to initialize
    your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy`
    scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)
    to see this in action!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æ‚¨çš„è®­ç»ƒæ˜¯XLAå…¼å®¹çš„ï¼Œå¹¶ä¸”ï¼ˆå¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨TPUèŠ‚ç‚¹/Colabï¼‰æ‚¨çš„æ•°æ®é›†å·²ç»å‡†å¤‡å°±ç»ªï¼Œé‚£ä¹ˆåœ¨TPUä¸Šè¿è¡Œå®é™…ä¸Šéå¸¸å®¹æ˜“ï¼æ‚¨çœŸæ­£éœ€è¦åœ¨ä»£ç ä¸­åšçš„æ”¹å˜åªæ˜¯æ·»åŠ å‡ è¡Œä»£ç æ¥åˆå§‹åŒ–æ‚¨çš„TPUï¼Œå¹¶ç¡®ä¿æ‚¨çš„æ¨¡å‹å’Œæ•°æ®é›†éƒ½åœ¨`TPUStrategy`èŒƒå›´å†…åˆ›å»ºã€‚æŸ¥çœ‹[æˆ‘ä»¬çš„TPUç¤ºä¾‹ç¬”è®°æœ¬](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)ä»¥æŸ¥çœ‹å®é™…æ“ä½œï¼
- en: Summary
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: 'There was a lot in here, so letâ€™s summarize with a quick checklist you can
    follow when you want to get your model ready for TPU training:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰å¾ˆå¤šå†…å®¹ï¼Œè®©æˆ‘ä»¬ç”¨ä¸€ä¸ªå¿«é€Ÿçš„æ¸…å•æ¥æ€»ç»“ï¼Œå½“æ‚¨æƒ³è¦å‡†å¤‡å¥½æ‚¨çš„æ¨¡å‹è¿›è¡ŒTPUè®­ç»ƒæ—¶å¯ä»¥éµå¾ªï¼š
- en: Make sure your code follows the three rules of XLA
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¡®ä¿æ‚¨çš„ä»£ç éµå¾ªXLAçš„ä¸‰æ¡è§„åˆ™
- en: Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can
    train it with XLA
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨CPU/GPUä¸Šä½¿ç”¨`jit_compile=True`ç¼–è¯‘æ‚¨çš„æ¨¡å‹ï¼Œå¹¶ç¡®è®¤æ‚¨å¯ä»¥ä½¿ç”¨XLAè¿›è¡Œè®­ç»ƒ
- en: Either load your dataset into memory or use a TPU-compatible dataset loading
    approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¦ä¹ˆå°†æ•°æ®é›†åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œè¦ä¹ˆä½¿ç”¨å…¼å®¹TPUçš„æ•°æ®é›†åŠ è½½æ–¹æ³•ï¼ˆè¯·å‚é˜…[notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)ï¼‰
- en: Migrate your code either to Colab (with accelerator set to â€œTPUâ€) or a TPU VM
    on Google Cloud
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†æ‚¨çš„ä»£ç è¿ç§»åˆ°Colabï¼ˆåŠ é€Ÿå™¨è®¾ç½®ä¸ºâ€œTPUâ€ï¼‰æˆ–Google Cloudä¸Šçš„TPU VM
- en: Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ·»åŠ TPUåˆå§‹åŒ–ä»£ç ï¼ˆè¯·å‚é˜…[notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)ï¼‰
- en: Create your `TPUStrategy` and make sure dataset loading and model creation are
    inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ›å»ºæ‚¨çš„`TPUStrategy`ï¼Œå¹¶ç¡®ä¿æ•°æ®é›†åŠ è½½å’Œæ¨¡å‹åˆ›å»ºåœ¨`strategy.scope()`å†…ï¼ˆè¯·å‚é˜…[notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)ï¼‰
- en: Donâ€™t forget to take `jit_compile=True` out again when you move to TPU!
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æ‚¨è½¬ç§»åˆ°TPUæ—¶ï¼Œä¸è¦å¿˜è®°å†æ¬¡å°†`jit_compile=True`å»æ‰ï¼
- en: ğŸ™ğŸ™ğŸ™ğŸ¥ºğŸ¥ºğŸ¥º
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ğŸ™ğŸ™ğŸ™ğŸ¥ºğŸ¥ºğŸ¥º
- en: Call model.fit()
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è°ƒç”¨model.fit()
- en: You did it!
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ åšåˆ°äº†ï¼
