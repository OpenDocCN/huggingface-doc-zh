- en: Dataset features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ•°æ®é›†ç‰¹å¾
- en: 'Original text: [https://huggingface.co/docs/datasets/about_dataset_features](https://huggingface.co/docs/datasets/about_dataset_features)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡é“¾æ¥ï¼š[https://huggingface.co/docs/datasets/about_dataset_features](https://huggingface.co/docs/datasets/about_dataset_features)
- en: null
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[Features](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Features)
    defines the internal structure of a dataset. It is used to specify the underlying
    serialization format. Whatâ€™s more interesting to you though is that [Features](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Features)
    contains high-level information about everything from the column names and types,
    to the [ClassLabel](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.ClassLabel).
    You can think of [Features](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Features)
    as the backbone of a dataset.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[Features](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Features)å®šä¹‰äº†æ•°æ®é›†çš„å†…éƒ¨ç»“æ„ã€‚å®ƒç”¨äºæŒ‡å®šåº•å±‚åºåˆ—åŒ–æ ¼å¼ã€‚ä¸è¿‡ï¼Œå¯¹æ‚¨æ¥è¯´æ›´æœ‰è¶£çš„æ˜¯ï¼Œ[Features](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Features)åŒ…å«æœ‰å…³ä¸€åˆ‡çš„é«˜çº§ä¿¡æ¯ï¼Œä»åˆ—åå’Œç±»å‹åˆ°[ClassLabel](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.ClassLabel)ã€‚æ‚¨å¯ä»¥å°†[Features](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Features)è§†ä¸ºæ•°æ®é›†çš„æ”¯æŸ±ã€‚'
- en: 'The [Features](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Features)
    format is simple: `dict[column_name, column_type]`. It is a dictionary of column
    name and column type pairs. The column type provides a wide range of options for
    describing the type of data you have.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[Features](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Features)æ ¼å¼å¾ˆç®€å•ï¼š`dict[column_name,
    column_type]`ã€‚å®ƒæ˜¯åˆ—åå’Œåˆ—ç±»å‹å¯¹çš„å­—å…¸ã€‚åˆ—ç±»å‹æä¾›äº†æè¿°æ‚¨æ‹¥æœ‰çš„æ•°æ®ç±»å‹çš„å¹¿æ³›é€‰é¡¹ã€‚'
- en: 'Letâ€™s have a look at the features of the MRPC dataset from the GLUE benchmark:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹çœ‹GLUEåŸºå‡†æµ‹è¯•ä¸­MRPCæ•°æ®é›†çš„ç‰¹å¾ï¼š
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The [Value](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Value)
    feature tells ğŸ¤— Datasets:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[Value](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Value)ç‰¹å¾å‘Šè¯‰ğŸ¤—æ•°æ®é›†ï¼š'
- en: The `idx` data type is `int32`.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idx`æ•°æ®ç±»å‹ä¸º`int32`ã€‚'
- en: The `sentence1` and `sentence2` data types are `string`.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sentence1`å’Œ`sentence2`æ•°æ®ç±»å‹ä¸º`string`ã€‚'
- en: ğŸ¤— Datasets supports many other data types such as `bool`, `float32` and `binary`
    to name just a few.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ¤—æ•°æ®é›†æ”¯æŒè®¸å¤šå…¶ä»–æ•°æ®ç±»å‹ï¼Œä¾‹å¦‚`bool`ã€`float32`å’Œ`binary`ç­‰ã€‚
- en: Refer to [Value](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Value)
    for a full list of supported data types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å…³æ”¯æŒçš„æ•°æ®ç±»å‹çš„å®Œæ•´åˆ—è¡¨ï¼Œè¯·å‚è€ƒ[Value](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Value)ã€‚
- en: The [ClassLabel](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.ClassLabel)
    feature informs ğŸ¤— Datasets the `label` column contains two classes. The classes
    are labeled `not_equivalent` and `equivalent`. Labels are stored as integers in
    the dataset. When you retrieve the labels, [ClassLabel.int2str()](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.ClassLabel.int2str)
    and [ClassLabel.str2int()](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.ClassLabel.str2int)
    carries out the conversion from integer value to label name, and vice versa.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[ClassLabel](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.ClassLabel)ç‰¹å¾å‘Šè¯‰ğŸ¤—æ•°æ®é›†`label`åˆ—åŒ…å«ä¸¤ä¸ªç±»ã€‚è¿™äº›ç±»åˆ«æ ‡è®°ä¸º`not_equivalent`å’Œ`equivalent`ã€‚æ ‡ç­¾ä»¥æ•´æ•°å½¢å¼å­˜å‚¨åœ¨æ•°æ®é›†ä¸­ã€‚å½“æ‚¨æ£€ç´¢æ ‡ç­¾æ—¶ï¼Œ[ClassLabel.int2str()](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.ClassLabel.int2str)å’Œ[ClassLabel.str2int()](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.ClassLabel.str2int)æ‰§è¡Œä»æ•´æ•°å€¼åˆ°æ ‡ç­¾åç§°çš„è½¬æ¢ï¼Œåä¹‹äº¦ç„¶ã€‚'
- en: If your data type contains a list of objects, then you want to use the [Sequence](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Sequence)
    feature. Remember the SQuAD dataset?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨çš„æ•°æ®ç±»å‹åŒ…å«å¯¹è±¡åˆ—è¡¨ï¼Œåˆ™åº”ä½¿ç”¨[Sequence](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Sequence)ç‰¹å¾ã€‚è¿˜è®°å¾—SQuADæ•°æ®é›†å—ï¼Ÿ
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `answers` field is constructed using the [Sequence](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Sequence)
    feature because it contains two subfields, `text` and `answer_start`, which are
    lists of `string` and `int32`, respectively.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`answers`å­—æ®µä½¿ç”¨[Sequence](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Sequence)ç‰¹å¾æ„å»ºï¼Œå› ä¸ºå®ƒåŒ…å«ä¸¤ä¸ªå­å­—æ®µï¼Œ`text`å’Œ`answer_start`ï¼Œåˆ†åˆ«æ˜¯`string`å’Œ`int32`çš„åˆ—è¡¨ã€‚'
- en: See the [flatten](./process#flatten) section to learn how you can extract the
    nested subfields as their own independent columns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹[flatten](./process#flatten)éƒ¨åˆ†ï¼Œäº†è§£å¦‚ä½•æå–åµŒå¥—å­å­—æ®µä½œä¸ºç‹¬ç«‹åˆ—ã€‚
- en: The array feature type is useful for creating arrays of various sizes. You can
    create arrays with two dimensions using [Array2D](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Array2D),
    and even arrays with five dimensions using [Array5D](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Array5D).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°ç»„ç‰¹å¾ç±»å‹éå¸¸é€‚ç”¨äºåˆ›å»ºå„ç§å¤§å°çš„æ•°ç»„ã€‚æ‚¨å¯ä»¥ä½¿ç”¨[Array2D](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Array2D)åˆ›å»ºå…·æœ‰ä¸¤ä¸ªç»´åº¦çš„æ•°ç»„ï¼Œç”šè‡³å¯ä»¥ä½¿ç”¨[Array5D](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Array5D)åˆ›å»ºå…·æœ‰äº”ä¸ªç»´åº¦çš„æ•°ç»„ã€‚
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The array type also allows the first dimension of the array to be dynamic. This
    is useful for handling sequences with variable lengths such as sentences, without
    having to pad or truncate the input to a uniform shape.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°ç»„ç±»å‹è¿˜å…è®¸æ•°ç»„çš„ç¬¬ä¸€ä¸ªç»´åº¦æ˜¯åŠ¨æ€çš„ã€‚è¿™å¯¹äºå¤„ç†é•¿åº¦å¯å˜çš„åºåˆ—ï¼ˆä¾‹å¦‚å¥å­ï¼‰éå¸¸æœ‰ç”¨ï¼Œè€Œæ— éœ€å¡«å……æˆ–æˆªæ–­è¾“å…¥ä»¥è·å¾—ç»Ÿä¸€çš„å½¢çŠ¶ã€‚
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Audio feature
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: éŸ³é¢‘ç‰¹å¾
- en: 'Audio datasets have a column with type [Audio](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Audio),
    which contains three important fields:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: éŸ³é¢‘æ•°æ®é›†å…·æœ‰ä¸€ä¸ªç±»å‹ä¸º[Audio](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Audio)çš„åˆ—ï¼Œå…¶ä¸­åŒ…å«ä¸‰ä¸ªé‡è¦å­—æ®µï¼š
- en: '`array`: the decoded audio data represented as a 1-dimensional array.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`ï¼šè¡¨ç¤ºä¸ºä¸€ç»´æ•°ç»„çš„è§£ç éŸ³é¢‘æ•°æ®ã€‚'
- en: '`path`: the path to the downloaded audio file.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`ï¼šä¸‹è½½çš„éŸ³é¢‘æ–‡ä»¶çš„è·¯å¾„ã€‚'
- en: '`sampling_rate`: the sampling rate of the audio data.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sampling_rate`ï¼šéŸ³é¢‘æ•°æ®çš„é‡‡æ ·ç‡ã€‚'
- en: 'When you load an audio dataset and call the audio column, the [Audio](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Audio)
    feature automatically decodes and resamples the audio file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ‚¨åŠ è½½éŸ³é¢‘æ•°æ®é›†å¹¶è°ƒç”¨éŸ³é¢‘åˆ—æ—¶ï¼Œ[Audio](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Audio)ç‰¹å¾ä¼šè‡ªåŠ¨è§£ç å’Œé‡æ–°é‡‡æ ·éŸ³é¢‘æ–‡ä»¶ï¼š
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Index into an audio dataset using the row index first and then the `audio` column
    - `dataset[0]["audio"]` - to avoid decoding and resampling all the audio files
    in the dataset. Otherwise, this can be a slow and time-consuming process if you
    have a large dataset.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆä½¿ç”¨è¡Œç´¢å¼•ï¼Œç„¶åä½¿ç”¨`audio`åˆ—æ¥ç´¢å¼•éŸ³é¢‘æ•°æ®é›† - `dataset[0]["audio"]` - ä»¥é¿å…è§£ç å’Œé‡æ–°é‡‡æ ·æ•°æ®é›†ä¸­çš„æ‰€æœ‰éŸ³é¢‘æ–‡ä»¶ã€‚å¦åˆ™ï¼Œå¦‚æœæ•°æ®é›†å¾ˆå¤§ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªç¼“æ…¢ä¸”è€—æ—¶çš„è¿‡ç¨‹ã€‚
- en: With `decode=False`, the [Audio](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Audio)
    type simply gives you the path or the bytes of the audio file, without decoding
    it into an `array`,
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`decode=False`ï¼Œ[Audio](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Audio)ç±»å‹åªæ˜¯æä¾›éŸ³é¢‘æ–‡ä»¶çš„è·¯å¾„æˆ–å­—èŠ‚ï¼Œè€Œä¸å°†å…¶è§£ç ä¸ºä¸€ä¸ª`array`ï¼Œ
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Image feature
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å›¾åƒç‰¹å¾
- en: 'Image datasets have a column with type [Image](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Image),
    which loads `PIL.Image` objects from images stored as bytes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ•°æ®é›†æœ‰ä¸€ä¸ªç±»å‹ä¸º[Image](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Image)çš„åˆ—ï¼Œå®ƒä»ä»¥å­—èŠ‚å­˜å‚¨çš„å›¾åƒä¸­åŠ è½½`PIL.Image`å¯¹è±¡ï¼š
- en: 'When you load an image dataset and call the image column, the [Image](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Image)
    feature automatically decodes the image file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: å½“åŠ è½½å›¾åƒæ•°æ®é›†å¹¶è°ƒç”¨å›¾åƒåˆ—æ—¶ï¼Œ[Image](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Image)ç‰¹å¾ä¼šè‡ªåŠ¨è§£ç å›¾åƒæ–‡ä»¶ï¼š
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Index into an image dataset using the row index first and then the `image` column
    - `dataset[0]["image"]` - to avoid decoding all the image files in the dataset.
    Otherwise, this can be a slow and time-consuming process if you have a large dataset.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆä½¿ç”¨è¡Œç´¢å¼•ï¼Œç„¶åä½¿ç”¨`image`åˆ—æ¥ç´¢å¼•å›¾åƒæ•°æ®é›† - `dataset[0]["image"]` - ä»¥é¿å…è§£ç æ•°æ®é›†ä¸­çš„æ‰€æœ‰å›¾åƒæ–‡ä»¶ã€‚å¦åˆ™ï¼Œå¦‚æœæ•°æ®é›†å¾ˆå¤§ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªç¼“æ…¢ä¸”è€—æ—¶çš„è¿‡ç¨‹ã€‚
- en: With `decode=False`, the [Image](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Image)
    type simply gives you the path or the bytes of the image file, without decoding
    it into an `PIL.Image`,
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`decode=False`ï¼Œ[Image](/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Image)ç±»å‹åªæ˜¯æä¾›å›¾åƒæ–‡ä»¶çš„è·¯å¾„æˆ–å­—èŠ‚ï¼Œè€Œä¸å°†å…¶è§£ç ä¸º`PIL.Image`ã€‚
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Depending on the dataset, you may get the path to the local downloaded image,
    or the content of the image as bytes if the dataset is not made of individual
    files.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®æ•°æ®é›†ï¼Œæ‚¨å¯èƒ½ä¼šå¾—åˆ°æœ¬åœ°ä¸‹è½½å›¾åƒçš„è·¯å¾„ï¼Œæˆ–è€…å¦‚æœæ•°æ®é›†ä¸æ˜¯ç”±å•ç‹¬çš„æ–‡ä»¶ç»„æˆï¼Œåˆ™ä¼šå¾—åˆ°å›¾åƒå†…å®¹çš„å­—èŠ‚ã€‚
- en: 'You can also define a dataset of images from numpy arrays:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨è¿˜å¯ä»¥ä»numpyæ•°ç»„å®šä¹‰å›¾åƒæ•°æ®é›†ï¼š
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And in this case the numpy arrays are encoded into PNG (or TIFF if the pixels
    values precision is important).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œnumpyæ•°ç»„ä¼šè¢«ç¼–ç ä¸ºPNGï¼ˆå¦‚æœåƒç´ å€¼ç²¾åº¦å¾ˆé‡è¦ï¼Œåˆ™ä¸ºTIFFï¼‰ã€‚
- en: 'For multi-channels arrays like RGB or RGBA, only uint8 is supported. If you
    use a larger precision, you get a warning and the array is downcasted to uint8.
    For gray-scale images you can use the integer or float precision you want as long
    as it is compatible with `Pillow`. A warning is shown if your image integer or
    float precision is too high, and in this case the array is downcated: an int64
    array is downcasted to int32, and a float64 array is downcasted to float32.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå¤šé€šé“æ•°ç»„å¦‚RGBæˆ–RGBAï¼Œä»…æ”¯æŒuint8ã€‚å¦‚æœä½¿ç”¨æ›´å¤§çš„ç²¾åº¦ï¼Œå°†ä¼šæ”¶åˆ°è­¦å‘Šå¹¶å°†æ•°ç»„é™çº§ä¸ºuint8ã€‚å¯¹äºç°åº¦å›¾åƒï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä¸`Pillow`å…¼å®¹çš„æ•´æ•°æˆ–æµ®ç‚¹ç²¾åº¦ï¼Œè­¦å‘Šä¼šæ˜¾ç¤ºå¦‚æœæ‚¨çš„å›¾åƒæ•´æ•°æˆ–æµ®ç‚¹ç²¾åº¦è¿‡é«˜ï¼Œæ­¤æ—¶æ•°ç»„å°†è¢«é™çº§ï¼šint64æ•°ç»„é™çº§ä¸ºint32ï¼Œfloat64æ•°ç»„é™çº§ä¸ºfloat32ã€‚
