# ViLT

> 原始文本：[`huggingface.co/docs/transformers/v4.37.2/en/model_doc/vilt`](https://huggingface.co/docs/transformers/v4.37.2/en/model_doc/vilt)

## 概述

ViLT 模型是由 Wonjae Kim、Bokyung Son、Ildoo Kim 在[ViLT: Vision-and-Language Transformer Without Convolution or Region Supervision](https://arxiv.org/abs/2102.03334)中提出的。ViLT 将文本嵌入集成到 Vision Transformer（ViT）中，使其在视觉和语言预训练（VLP）中具有最小设计。

论文摘要如下：

*视觉和语言预训练（VLP）在各种联合视觉和语言下游任务上提高了性能。当前的 VLP 方法主要依赖于图像特征提取过程，其中大部分涉及区域监督（例如目标检测）和卷积架构（例如 ResNet）。尽管文献中忽略了这一点，但我们发现这在效率/速度方面存在问题，仅仅提取输入特征就需要比多模态交互步骤更多的计算量；以及表达能力方面，因为它受到视觉嵌入器及其预定义视觉词汇表表达能力的上限。在本文中，我们提出了一个最小的 VLP 模型，Vision-and-Language Transformer（ViLT），在处理视觉输入方面与处理文本输入的无卷积方式相同，从而使其成为一个整体。我们展示 ViLT 比以前的 VLP 模型快数十倍，但在下游任务性能上具有竞争力或更好。*

ViLT 架构。取自[原始论文](https://arxiv.org/abs/2102.03334)。

此模型由[nielsr](https://huggingface.co/nielsr)贡献。原始代码可在[此处](https://github.com/dandelin/ViLT)找到。

## 使用提示

+   开始使用 ViLT 的最快方法是查看[示例笔记本](https://github.com/NielsRogge/Transformers-Tutorials/tree/master/ViLT)（展示了对自定义数据的推理和微调）。

+   ViLT 是一个同时接受`pixel_values`和`input_ids`作为输入的模型。可以使用 ViltProcessor 为模型准备数据。该处理器将图像处理器（用于图像模态）和标记器（用于语言模态）封装在一起。

+   ViLT 使用各种尺寸的图像进行训练：作者将输入图像的较短边调整为 384，并将较长边限制在 640 以下，同时保持纵横比。为了使图像的批处理成为可能，作者使用一个`pixel_mask`指示哪些像素值是真实的，哪些是填充的。ViltProcessor 会自动为您创建这个。

+   ViLT 的设计与标准 Vision Transformer（ViT）非常相似。唯一的区别是该模型包括用于语言模态的额外嵌入层。

+   此模型的 PyTorch 版本仅在 torch 1.10 及更高版本中可用。

## ViltConfig

### `class transformers.ViltConfig`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/configuration_vilt.py#L28)

```py
( vocab_size = 30522 type_vocab_size = 2 modality_type_vocab_size = 2 max_position_embeddings = 40 hidden_size = 768 num_hidden_layers = 12 num_attention_heads = 12 intermediate_size = 3072 hidden_act = 'gelu' hidden_dropout_prob = 0.0 attention_probs_dropout_prob = 0.0 initializer_range = 0.02 layer_norm_eps = 1e-12 image_size = 384 patch_size = 32 num_channels = 3 qkv_bias = True max_image_length = -1 tie_word_embeddings = False num_images = -1 **kwargs )
```

参数

+   `vocab_size`（`int`，*可选*，默认为 30522）—模型文本部分的词汇量。定义了在调用 ViltModel 时可以表示的不同标记数量。

+   `type_vocab_size`（`int`，*可选*，默认为 2）—在调用 ViltModel 时传递的`token_type_ids`的词汇量。在编码文本时使用。

+   `modality_type_vocab_size` (`int`, *optional*, defaults to 2) — 在调用 ViltModel 时传递的模态词汇表大小。在连接文本和图像模态的嵌入后使用。

+   `max_position_embeddings` (`int`, *optional*, defaults to 40) — 该模型可能使用的最大序列长度。

+   `hidden_size` (`int`, *optional*, defaults to 768) — 编码器层和池化层的维度。

+   `num_hidden_layers` (`int`, *optional*, defaults to 12) — Transformer 编码器中的隐藏层数量。

+   `num_attention_heads` (`int`, *optional*, defaults to 12) — Transformer 编码器中每个注意力层的注意力头数量。

+   `intermediate_size` (`int`, *optional*, defaults to 3072) — Transformer 编码器中“中间”（即前馈）层的维度。

+   `hidden_act` (`str` or `function`, *optional*, defaults to `"gelu"`) — 编码器和池化层中的非线性激活函数（函数或字符串）。如果是字符串，支持`"gelu"`、`"relu"`、`"selu"`和`"gelu_new"`。

+   `hidden_dropout_prob` (`float`, *optional*, defaults to 0.0) — 嵌入层、编码器和池化层中所有全连接层的 dropout 概率。

+   `attention_probs_dropout_prob` (`float`, *optional*, defaults to 0.0) — 注意力概率的 dropout 比率。

+   `initializer_range` (`float`, *optional*, defaults to 0.02) — 用于初始化所有权重矩阵的 truncated_normal_initializer 的标准差。

+   `layer_norm_eps` (`float`, *optional*, defaults to 1e-12) — 层归一化层使用的 epsilon。

+   `image_size` (`int`, *optional*, defaults to 384) — 每张图片的大小（分辨率）。

+   `patch_size` (`int`, *optional*, defaults to 32) — 每个补丁的大小（分辨率）。

+   `num_channels` (`int`, *optional*, defaults to 3) — 输入通道数。

+   `qkv_bias` (`bool`, *optional*, defaults to `True`) — 是否为查询、键和值添加偏置。

+   `max_image_length` (`int`, *optional*, defaults to -1) — 用于 Transformer 编码器的输入最大补丁数。如果设置为正整数，编码器将最多采样`max_image_length`个补丁。如果设置为-1，则不会考虑。

+   `num_images` (`int`, *optional*, defaults to -1) — 用于自然语言视觉推理的图像数量。如果设置为正整数，将被 ViltForImagesAndTextClassification 用于定义分类器头。

这是用于存储`ViLTModel`配置的配置类。根据指定的参数实例化 ViLT 模型，定义模型架构。使用默认值实例化配置将产生类似于 ViLT[dandelin/vilt-b32-mlm](https://huggingface.co/dandelin/vilt-b32-mlm)架构的配置。

配置对象继承自 PretrainedConfig，可用于控制模型输出。阅读 PretrainedConfig 的文档以获取更多信息。

示例：

```py
>>> from transformers import ViLTModel, ViLTConfig

>>> # Initializing a ViLT dandelin/vilt-b32-mlm style configuration
>>> configuration = ViLTConfig()

>>> # Initializing a model from the dandelin/vilt-b32-mlm style configuration
>>> model = ViLTModel(configuration)

>>> # Accessing the model configuration
>>> configuration = model.config
```

## ViltFeatureExtractor

### `class transformers.ViltFeatureExtractor`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/feature_extraction_vilt.py#L26)

```py
( *args **kwargs )
```

#### `__call__`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/image_processing_utils.py#L550)

```py
( images **kwargs )
```

预处理一张图片或一批图片。

## ViltImageProcessor

### `class transformers.ViltImageProcessor`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/image_processing_vilt.py#L120)

```py
( do_resize: bool = True size: Dict = None size_divisor: int = 32 resample: Resampling = <Resampling.BICUBIC: 3> do_rescale: bool = True rescale_factor: Union = 0.00392156862745098 do_normalize: bool = True image_mean: Union = None image_std: Union = None do_pad: bool = True **kwargs )
```

参数

+   `do_resize` (`bool`, *optional*, defaults to `True`) — 是否将图像的（高度，宽度）尺寸调整为指定的 `size`。可以被 `preprocess` 方法中的 `do_resize` 参数覆盖。

+   `size` (`Dict[str, int]` *optional*, defaults to `{"shortest_edge" -- 384}`): 调整输入的较短边到 `size["shortest_edge"]`。较长边将被限制在 `int((1333 / 800) * size["shortest_edge"])` 以下，同时保持纵横比。仅在 `do_resize` 设置为 `True` 时有效。可以被 `preprocess` 方法中的 `size` 参数覆盖。

+   `size_divisor` (`int`, *optional*, defaults to 32) — 用于确保高度和宽度都可以被整除的大小。仅在 `do_resize` 设置为 `True` 时有效。可以被 `preprocess` 方法中的 `size_divisor` 参数覆盖。

+   `resample` (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`) — 如果调整图像大小，则使用的重采样滤波器。仅在 `do_resize` 设置为 `True` 时有效。可以被 `preprocess` 方法中的 `resample` 参数覆盖。

+   `do_rescale` (`bool`, *optional*, defaults to `True`) — 是否按指定比例 `rescale_factor` 重新缩放图像。可以被 `preprocess` 方法中的 `do_rescale` 参数覆盖。

+   `rescale_factor` (`int` or `float`, *optional*, defaults to `1/255`) — 如果重新缩放图像，则使用的缩放因子。仅在 `do_rescale` 设置为 `True` 时有效。可以被 `preprocess` 方法中的 `rescale_factor` 参数覆盖。

+   `do_normalize` (`bool`, *optional*, defaults to `True`) — 是否对图像进行归一化。可以被 `preprocess` 方法中的 `do_normalize` 参数覆盖。

+   `image_mean` (`float` or `List[float]`, *optional*, defaults to `IMAGENET_STANDARD_MEAN`) — 如果对图像进行归一化，则使用的均值。这是一个浮点数或与图像通道数相同长度的浮点数列表。可以被 `preprocess` 方法中的 `image_mean` 参数覆盖。

+   `image_std` (`float` or `List[float]`, *optional*, defaults to `IMAGENET_STANDARD_STD`) — 如果对图像进行归一化，则使用的标准差。这是一个浮点数或与图像通道数相同长度的浮点数列表。可以被 `preprocess` 方法中的 `image_std` 参数覆盖。

+   `do_pad` (`bool`, *optional*, defaults to `True`) — 是否将图像填充到批次中图像的（最大高度，最大宽度）。可以被 `preprocess` 方法中的 `do_pad` 参数覆盖。

构建一个 ViLT 图像处理器。

#### `preprocess`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/image_processing_vilt.py#L338)

```py
( images: Union do_resize: Optional = None size: Optional = None size_divisor: Optional = None resample: Resampling = None do_rescale: Optional = None rescale_factor: Optional = None do_normalize: Optional = None image_mean: Union = None image_std: Union = None do_pad: Optional = None return_tensors: Union = None data_format: ChannelDimension = <ChannelDimension.FIRST: 'channels_first'> input_data_format: Union = None **kwargs )
```

参数

+   `images` (`ImageInput`) — 要预处理的图像。期望单个图像或批量图像，像素值范围从 0 到 255。如果传入像素值在 0 到 1 之间的图像，请设置 `do_rescale=False`。

+   `do_resize` (`bool`, *optional*, defaults to `self.do_resize`) — 是否调整图像大小。

+   `size` (`Dict[str, int]`, *optional*, defaults to `self.size`) — 控制 `resize` 后图像的大小。图像的最短边被调整为 `size["shortest_edge"]`，同时保持纵横比。如果调整后图像的最长边 > `int(size["shortest_edge"] * (1333 / 800))`，则再次调整图像，使最长边等于 `int(size["shortest_edge"] * (1333 / 800))`。

+   `size_divisor` (`int`, *optional*, defaults to `self.size_divisor`) — 图像被调整为该值的倍数。

+   `resample` (`PILImageResampling`, *optional*, defaults to `self.resample`) — 如果调整图像大小，则使用的重采样滤波器。仅在 `do_resize` 设置为 `True` 时有效。

+   `do_rescale`（`bool`，*可选*，默认为`self.do_rescale`）— 是否将图像值重新缩放在[0 - 1]之间。

+   `rescale_factor`（`float`，*可选*，默认为`self.rescale_factor`）— 如果`do_rescale`设置为`True`，用于重新缩放图像的重新缩放因子。

+   `do_normalize`（`bool`，*可选*，默认为`self.do_normalize`）— 是否对图像进行归一化。

+   `image_mean`（`float`或`List[float]`，*可选*，默认为`self.image_mean`）— 如果`do_normalize`设置为`True`，用于归一化图像的图像均值。

+   `image_std`（`float`或`List[float]`，*可选*，默认为`self.image_std`）— 如果`do_normalize`设置为`True`，用于归一化图像的图像标准差。

+   `do_pad`（`bool`，*可选*，默认为`self.do_pad`）— 是否将图像填充到批处理中的（max_height，max_width）。如果为`True`，还会创建并返回像素掩码。

+   `return_tensors`（`str`或`TensorType`，*可选*）— 要返回的张量类型。可以是以下之一：

    +   未设置：返回一个`np.ndarray`列表。

    +   `TensorType.TENSORFLOW`或`'tf'`：返回类型为`tf.Tensor`的批处理。

    +   `TensorType.PYTORCH`或`'pt'`：返回类型为`torch.Tensor`的批处理。

    +   `TensorType.NUMPY`或`'np'`：返回类型为`np.ndarray`的批处理。

    +   `TensorType.JAX`或`'jax'`：返回类型为`jax.numpy.ndarray`的批处理。

+   `data_format`（`ChannelDimension`或`str`，*可选*，默认为`ChannelDimension.FIRST`）— 输出图像的通道维度格式。可以是以下之一：

    +   `ChannelDimension.FIRST`：图像以（通道数，高度，宽度）格式。

    +   `ChannelDimension.LAST`：图像以（高度，宽度，通道数）格式。

+   `input_data_format`（`ChannelDimension`或`str`，*可选*）— 输入图像的通道维度格式。如果未设置，则从输入图像中推断出通道维度格式。可以是以下之一：

    +   `"channels_first"`或`ChannelDimension.FIRST`：图像以（通道数，高度，宽度）格式。

    +   `"channels_last"`或`ChannelDimension.LAST`：图像以（高度，宽度，通道数）格式。

    +   `"none"`或`ChannelDimension.NONE`：图像以（高度，宽度）格式。

预处理图像或图像批处理。

## ViltProcessor

### `class transformers.ViltProcessor`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/processing_vilt.py#L27)

```py
( image_processor = None tokenizer = None **kwargs )
```

参数

+   `image_processor`（`ViltImageProcessor`，*可选*）— 一个 ViltImageProcessor 的实例。图像处理器是必需的输入。

+   `tokenizer`（`BertTokenizerFast`，*可选*）— 一个[‘BertTokenizerFast`]的实例。分词器是必需的输入。

构建一个 ViLT 处理器，将 BERT 分词器和 ViLT 图像处理器封装成一个处理器。

ViltProcessor 提供了 ViltImageProcessor 和 BertTokenizerFast 的所有功能。有关更多信息，请参阅**call**()和`decode()`的文档字符串。

#### `__call__`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/processing_vilt.py#L64)

```py
( images text: Union = None add_special_tokens: bool = True padding: Union = False truncation: Union = None max_length: Optional = None stride: int = 0 pad_to_multiple_of: Optional = None return_token_type_ids: Optional = None return_attention_mask: Optional = None return_overflowing_tokens: bool = False return_special_tokens_mask: bool = False return_offsets_mapping: bool = False return_length: bool = False verbose: bool = True return_tensors: Union = None **kwargs )
```

此方法使用 ViltImageProcessor.**call**()方法准备模型的图像，并使用 BertTokenizerFast.**call**()准备模型的文本。

有关更多信息，请参阅上述两种方法的文档字符串。

## ViltModel

### `class transformers.ViltModel`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L711)

```py
( config add_pooling_layer = True )
```

参数

+   `config` (ViltConfig) — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只加载配置。查看 from_pretrained() 方法以加载模型权重。

裸 ViLT 模型变压器输出原始隐藏状态，没有特定的头部。此模型是 PyTorch `torch.nn.Module <https://pytorch.org/docs/stable/nn.html#torch.nn.Module>`_ 子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L743)

```py
( input_ids: Optional = None attention_mask: Optional = None token_type_ids: Optional = None pixel_values: Optional = None pixel_mask: Optional = None head_mask: Optional = None inputs_embeds: Optional = None image_embeds: Optional = None image_token_type_idx: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.BaseModelOutputWithPooling or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`torch.LongTensor` of shape `({0})`) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。

+   `attention_mask` (`torch.FloatTensor` of shape `({0})`, *optional*) — 用于避免在填充标记索引上执行注意力的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示未被“遮蔽”的标记，

    +   0 表示被“遮蔽”的标记。什么是注意力掩码？

+   `token_type_ids` (`torch.LongTensor` of shape `({0})`, *optional*) — 段落标记索引，用于指示输入的第一部分和第二部分。索引在 `[0, 1]` 中选择：

    +   0 对应于 *句子 A* 标记，

    +   1 对应于 *句子 B* 标记。什么是标记类型 ID？

+   `pixel_values` (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`) — 像素值。可以使用 AutoImageProcessor 获取像素值。有关详细信息，请参阅 ViltImageProcessor.`call`()。

+   `pixel_mask` (`torch.LongTensor` of shape `(batch_size, height, width)`, *optional*) — 用于避免在填充像素值上执行注意力的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示真实的像素（即未被遮蔽），

    +   0 表示填充的像素（即“遮蔽”）。`什么是注意力掩码？<../glossary.html#attention-mask>`__

+   `head_mask` (`torch.FloatTensor` of shape `(num_heads,)` or `(num_layers, num_heads)`, *optional*) — 用于使自注意力模块中选择的头部失效的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被“遮蔽”。

+   `inputs_embeds` (`torch.FloatTensor` of shape `({0}, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递 `input_ids`。如果您想要更多控制如何将 `input_ids` 索引转换为相关向量，而不是模型内部的嵌入查找矩阵，这将非常有用。

+   `image_embeds` (`torch.FloatTensor` of shape `(batch_size, num_patches, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递 `pixel_values`。如果您想要更多控制如何将 `pixel_values` 转换为补丁嵌入，这将非常有用。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请查看返回的张量下的 `attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回一个 ModelOutput 而不是一个普通的元组。

返回

transformers.modeling_outputs.BaseModelOutputWithPooling 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.BaseModelOutputWithPooling 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或当`config.return_dict=False`时），包括根据配置(ViltConfig)和输入的各种元素。

+   `last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`) — 模型最后一层的隐藏状态序列。

+   `pooler_output` (`torch.FloatTensor`，形状为`(batch_size, hidden_size)`) — 经过用于辅助预训练任务的层进一步处理后的序列的第一个标记（分类标记）的最后一层隐藏状态。例如，对于 BERT 系列模型，这将返回通过线性层和 tanh 激活函数处理后的分类标记。线性层的权重是在预训练期间从下一个句子预测（分类）目标中训练的。

+   `hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_hidden_states=True`或当`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出的输出+每层的输出）。

    模型在每一层输出的隐藏状态以及可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或当`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    在注意力 softmax 之后的注意力权重，用于计算自注意力头中的加权平均值。

ViltModel 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的方法需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import ViltProcessor, ViltModel
>>> from PIL import Image
>>> import requests

>>> # prepare image and text
>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> text = "hello world"

>>> processor = ViltProcessor.from_pretrained("dandelin/vilt-b32-mlm")
>>> model = ViltModel.from_pretrained("dandelin/vilt-b32-mlm")

>>> inputs = processor(image, text, return_tensors="pt")
>>> outputs = model(**inputs)
>>> last_hidden_states = outputs.last_hidden_state
```

## ViltForMaskedLM

### `class transformers.ViltForMaskedLM`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L875)

```py
( config )
```

参数

+   `config` (ViltConfig) — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

在预训练期间，ViLT 模型在顶部带有一个语言建模头。

这个模型是 PyTorch 的`torch.nn.Module <https://pytorch.org/docs/stable/nn.html#torch.nn.Module>`_ 子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L899)

```py
( input_ids: Optional = None attention_mask: Optional = None token_type_ids: Optional = None pixel_values: Optional = None pixel_mask: Optional = None head_mask: Optional = None inputs_embeds: Optional = None image_embeds: Optional = None labels: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.MaskedLMOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`torch.LongTensor`，形状为 `(batch_size, sequence_length)`) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `attention_mask` (`torch.FloatTensor`，形状为 `(batch_size, sequence_length)`，*可选*) — 避免在填充标记索引上执行注意力的掩码。掩码值选在 `[0, 1]`：

    +   1 表示标记是 `未掩码`，

    +   0 表示 `被掩码` 的标记。什么是注意力掩码？

+   `token_type_ids` (`torch.LongTensor`，形状为 `(batch_size, sequence_length)`，*可选*) — 段标记索引，指示输入的第一部分和第二部分。索引选在 `[0, 1]`：

    +   0 对应一个 *句子 A* 标记，

    +   1 对应一个 *句子 B* 标记。什么是标记类型 ID？

+   `pixel_values` (`torch.FloatTensor`，形状为 `(batch_size, num_channels, height, width)`) — 像素值。可以使用 AutoImageProcessor 获取像素值。有关详细信息，请参阅 ViltImageProcessor.`call`()。

+   `pixel_mask` (`torch.LongTensor`，形状为 `(batch_size, height, width)`，*可选*) — 用于避免在填充像素值上执行注意力的掩码。掩码值选在 `[0, 1]`：

    +   1 表示像素是真实的（即 `未掩码`），

    +   0 表示填充的像素（即 `被掩码`）。`什么是注意力掩码？ <../glossary.html#attention-mask>`__

+   `head_mask` (`torch.FloatTensor`，形状为 `(num_heads,)` 或 `(num_layers, num_heads)`，*可选*) — 用于使自注意力模块的选定头部失效的掩码。掩码值选在 `[0, 1]`：

    +   1 表示头部是 `未掩码`，

    +   0 表示头部是 `被掩码`。

+   `inputs_embeds` (`torch.FloatTensor`，形状为 `(batch_size, sequence_length, hidden_size)`，*可选*) — 可选地，您可以选择直接传递嵌入表示，而不是传递 `input_ids`。如果您想要更多控制权来将 `input_ids` 索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，这将非常有用。

+   `image_embeds` (`torch.FloatTensor`，形状为 `(batch_size, num_patches, hidden_size)`，*可选*) — 可选地，您可以选择直接传递嵌入表示，而不是传递 `pixel_values`。如果您想要更多控制权来将 `pixel_values` 转换为补丁嵌入，这将非常有用。

+   `output_attentions` (`bool`，*可选*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回的张量下的 `attentions`。

+   `output_hidden_states` (`bool`，*可选*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回的张量下的 `hidden_states`。

+   `return_dict` (`bool`，*可选*) — 是否返回一个 ModelOutput 而不是一个普通元组。

+   `labels`（*torch.LongTensor*，形状为 *(batch_size, sequence_length)*，*可选*) — 用于计算掩码语言建模损失的标签。索引应在 *[-100, 0, …, config.vocab_size]* 范围内（参见 *input_ids* 文档字符串）。索引设置为 *-100* 的标记将被忽略（被掩码），损失仅计算具有标签在 *[0, …, config.vocab_size]* 范围内的标记。

返回

transformers.modeling_outputs.MaskedLMOutput 或 `tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.MaskedLMOutput 或一个 `torch.FloatTensor` 元组（如果传递 `return_dict=False` 或 `config.return_dict=False` 时）包含根据配置（ViltConfig）和输入的不同元素。

+   `loss` (`torch.FloatTensor`，形状为 `(1,)`，*可选*，当提供 `labels` 时返回) — 掩码语言建模（MLM）损失。

+   `logits` (`torch.FloatTensor`，形状为 `(batch_size, sequence_length, config.vocab_size)`) — 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递 `output_hidden_states=True` 或 `config.output_hidden_states=True` 时返回） — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor` 元组（如果模型有嵌入层，则为嵌入输出 + 每一层的输出）。

    模型在每一层输出的隐藏状态以及可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递 `output_attentions=True` 或 `config.output_attentions=True` 时返回） — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组（每层一个）。

    在自注意力头中用于计算加权平均值的注意力 softmax 之后的注意力权重。

ViltForMaskedLM 的前向方法，覆盖了 `__call__` 特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用 `Module` 实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import ViltProcessor, ViltForMaskedLM
>>> import requests
>>> from PIL import Image
>>> import re
>>> import torch

>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> text = "a bunch of [MASK] laying on a [MASK]."

>>> processor = ViltProcessor.from_pretrained("dandelin/vilt-b32-mlm")
>>> model = ViltForMaskedLM.from_pretrained("dandelin/vilt-b32-mlm")

>>> # prepare inputs
>>> encoding = processor(image, text, return_tensors="pt")

>>> # forward pass
>>> outputs = model(**encoding)

>>> tl = len(re.findall("\[MASK\]", text))
>>> inferred_token = [text]

>>> # gradually fill in the MASK tokens, one by one
>>> with torch.no_grad():
...     for i in range(tl):
...         encoded = processor.tokenizer(inferred_token)
...         input_ids = torch.tensor(encoded.input_ids)
...         encoded = encoded["input_ids"][0][1:-1]
...         outputs = model(input_ids=input_ids, pixel_values=encoding.pixel_values)
...         mlm_logits = outputs.logits[0]  # shape (seq_len, vocab_size)
...         # only take into account text features (minus CLS and SEP token)
...         mlm_logits = mlm_logits[1 : input_ids.shape[1] - 1, :]
...         mlm_values, mlm_ids = mlm_logits.softmax(dim=-1).max(dim=-1)
...         # only take into account text
...         mlm_values[torch.tensor(encoded) != 103] = 0
...         select = mlm_values.argmax().item()
...         encoded[select] = mlm_ids[select].item()
...         inferred_token = [processor.decode(encoded)]

>>> selected_token = ""
>>> encoded = processor.tokenizer(inferred_token)
>>> output = processor.decode(encoded.input_ids[0], skip_special_tokens=True)
>>> print(output)
a bunch of cats laying on a couch.
```

## ViltForQuestionAnswering

### `class transformers.ViltForQuestionAnswering`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L1050)

```py
( config )
```

参数

+   `config` (ViltConfig) — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只加载配置。查看 from_pretrained() 方法加载模型权重。

Vilt 模型变压器，顶部带有分类器头（在 [CLS] 标记的最终隐藏状态之上的线性层），用于视觉问答，例如用于 VQAv2。

这个模型是 PyTorch 的 `torch.nn.Module <https://pytorch.org/docs/stable/nn.html#torch.nn.Module>`_ 子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取与一般用法和行为相关的所有事项。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L1075)

```py
( input_ids: Optional = None attention_mask: Optional = None token_type_ids: Optional = None pixel_values: Optional = None pixel_mask: Optional = None head_mask: Optional = None inputs_embeds: Optional = None image_embeds: Optional = None labels: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.SequenceClassifierOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`torch.LongTensor`，形状为 `({0})`) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。查看 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`() 获取详细信息。什么是输入 ID？

+   `attention_mask` (`torch.FloatTensor`，形状为 `({0})`，*可选*) — 避免在填充标记索引上执行注意力的掩码。掩码值选择在 `[0, 1]`：

    +   对于未被掩码的标记为 1，

    +   对于`被掩码`的标记为 0。什么是注意力掩码？

+   `token_type_ids`（形状为`({0})`的`torch.LongTensor`，*可选*）— 段标记索引，指示输入的第一部分和第二部分。索引选定在`[0, 1]`之间：

    +   0 对应于*句子 A*的标记，

    +   1 对应于*句子 B*的标记。什么是标记类型 ID？

+   `pixel_values`（形状为`(batch_size, num_channels, height, width)`的`torch.FloatTensor`）— 像素值。可以使用 AutoImageProcessor 获取像素值。有关详细信息，请参阅 ViltImageProcessor.`call`()。

+   `pixel_mask`（形状为`(batch_size, height, width)`的`torch.LongTensor`，*可选*）— 用于避免对填充像素值执行注意力的掩码。掩码值选定在`[0, 1]`之间：

    +   像素为 1 表示是真实像素（即`未被掩码`），

    +   对于填充像素（即`masked`）的像素为 0。`什么是注意力掩码？<../glossary.html#attention-mask>`__

+   `head_mask`（形状为`(num_heads,)`或`(num_layers, num_heads)`的`torch.FloatTensor`，*可选*）— 用于使自注意力模块中的选定头部失效的掩码。掩码值选定在`[0, 1]`之间：

    +   1 表示头部`未被掩码`，

    +   0 表示头部`被掩码`。

+   `inputs_embeds`（形状为`({0}, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选地，您可以选择直接传递嵌入表示，而不是传递`input_ids`。如果您想要更多控制如何将`input_ids`索引转换为相关向量，而不是模型的内部嵌入查找矩阵。

+   `image_embeds`（形状为`(batch_size, num_patches, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选地，您可以选择直接传递嵌入表示，而不是传递`pixel_values`。如果您想要更多控制如何将`pixel_values`转换为补丁嵌入，这将非常有用。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。查看返回的张量中的`attentions`以获取更多细节。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。查看返回的张量中的`hidden_states`以获取更多细节。

+   `return_dict`（`bool`，*可选*）— 是否返回一个 ModelOutput 而不是一个普通的元组。

+   `labels`（形状为`(batch_size, num_labels)`的`torch.FloatTensor`，*可选*）— 用于计算视觉问答损失的标签。此张量必须是给定示例批次中适用的所有答案的独热编码，或者指示哪些答案适用的软编码，其中 1.0 是最高分。

返回

transformers.modeling_outputs.SequenceClassifierOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.SequenceClassifierOutput 或者一个`torch.FloatTensor`的元组（如果传递了`return_dict=False`或者当`config.return_dict=False`时），包括根据配置（ViltConfig）和输入的不同元素。

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，当提供`labels`时返回）— 分类（如果`config.num_labels==1`则为回归）损失。

+   `logits`（形状为`(batch_size, config.num_labels)`的`torch.FloatTensor`）— 分类（如果`config.num_labels==1`则为回归）分数（SoftMax 之前）。

+   `hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递 `output_hidden_states=True` 或当 `config.output_hidden_states=True` 时返回) — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor` 元组（一个用于嵌入的输出，如果模型有一个嵌入层，+ 一个用于每一层的输出）。

    每层模型的隐藏状态加上可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递 `output_attentions=True` 或当 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组（每层一个）。

    在注意力 softmax 之后的注意力权重，用于计算自注意力头中的加权平均值。

ViltForQuestionAnswering 的前向方法，覆盖了 `__call__` 特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用 `Module` 实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import ViltProcessor, ViltForQuestionAnswering
>>> import requests
>>> from PIL import Image

>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> text = "How many cats are there?"

>>> processor = ViltProcessor.from_pretrained("dandelin/vilt-b32-finetuned-vqa")
>>> model = ViltForQuestionAnswering.from_pretrained("dandelin/vilt-b32-finetuned-vqa")

>>> # prepare inputs
>>> encoding = processor(image, text, return_tensors="pt")

>>> # forward pass
>>> outputs = model(**encoding)
>>> logits = outputs.logits
>>> idx = logits.argmax(-1).item()
>>> print("Predicted answer:", model.config.id2label[idx])
Predicted answer: 2
```

## ViltForImagesAndTextClassification

`transformers.ViltForImagesAndTextClassification` 类

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L1265)

```py
( config )
```

参数

+   `input_ids` (`torch.LongTensor`，形状为 `({0})`) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `attention_mask` (`torch.FloatTensor`，形状为 `({0})`，*可选*) — 用于避免在填充标记索引上执行注意力的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示未被掩码的标记，

    +   0 表示被掩码的标记。什么是注意力掩码？

+   `token_type_ids` (`torch.LongTensor`，形状为 `({0})`，*可选*) — 段标记索引，用于指示输入的第一部分和第二部分。索引在 `[0, 1]` 中选择：

    +   0 对应于 *句子 A* 的标记，

    +   1 对应于 *句子 B* 的标记。什么是标记类型 ID？

+   `pixel_values` (`torch.FloatTensor`，形状为 `(batch_size, num_images, num_channels, height, width)`) — 像素值。像素值可以使用 AutoImageProcessor 获取。有关详细信息，请参阅 ViltImageProcessor.`call`()。

+   `pixel_mask` (`torch.LongTensor`，形状为 `(batch_size, num_images, height, width)`，*可选*) — 用于避免在填充像素值上执行注意力的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示真实的像素（即 `未被掩码`），

    +   0 表示填充的像素（即 `被掩码`）。`什么是注意力掩码？ <../glossary.html#attention-mask>`__

+   `head_mask` (`torch.FloatTensor`，形状为 `(num_heads,)` 或 `(num_layers, num_heads)`，*可选*) — 用于使自注意力模块中选择的头部失效的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示头部是 `未被掩码`，

    +   0 表示头部是 `被掩码`。

+   `inputs_embeds` (`torch.FloatTensor` of shape `({0}, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递`input_ids`。如果您想要更多控制如何将`input_ids`索引转换为相关向量，这将非常有用，而不是使用模型的内部嵌入查找矩阵。

+   `image_embeds` (`torch.FloatTensor` of shape `(batch_size, num_images, num_patches, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递`pixel_values`。如果您想要更多控制如何将`pixel_values`转换为补丁嵌入，这将非常有用。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回的张量下的`attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回的张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

Vilt 模型变压器，顶部带有自然语言视觉推理的分类器头部，例如 NLVR2。

#### `forward`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L1290)

```py
( input_ids: Optional = None attention_mask: Optional = None token_type_ids: Optional = None pixel_values: Optional = None pixel_mask: Optional = None head_mask: Optional = None inputs_embeds: Optional = None image_embeds: Optional = None labels: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.models.vilt.modeling_vilt.ViltForImagesAndTextClassificationOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`torch.LongTensor` of shape `({0})`) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `attention_mask` (`torch.FloatTensor` of shape `({0})`, *optional*) — 用于避免在填充标记索引上执行注意力的掩码。掩码值在`[0, 1]`中选择：

    +   1 表示未被`masked`的标记，

    +   0 表示被`masked`的标记。什么是注意力掩码？

+   `token_type_ids` (`torch.LongTensor` of shape `({0})`, *optional*) — 段标记索引，指示输入的第一部分和第二部分。索引在`[0, 1]`中选择：

    +   0 对应于*句子 A*标记，

    +   1 对应于*句子 B*标记。什么是标记类型 ID？

+   `pixel_values` (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`) — 像素值。可以使用 AutoImageProcessor 获取像素值。有关详细信息，请参阅 ViltImageProcessor.`call`()。

+   `pixel_mask` (`torch.LongTensor` of shape `(batch_size, height, width)`, *optional*) — 用于避免在填充像素值上执行注意力的掩码。掩码值在`[0, 1]`中选择：

    +   1 表示真实的像素（即`not masked`），

    +   0 表示填充像素（即`masked`）。`什么是注意力掩码？<../glossary.html#attention-mask>`__

+   `head_mask` (`torch.FloatTensor` of shape `(num_heads,)` or `(num_layers, num_heads)`, *optional*) — 用于使自注意力模块中选择的头部失效的掩码。掩码值在`[0, 1]`中选择：

    +   1 表示头部未被`masked`，

    +   0 表示头部被`masked`。

+   `inputs_embeds` (`torch.FloatTensor` of shape `({0}, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递`input_ids`。如果您想要更多控制如何将`input_ids`索引转换为相关向量，这将非常有用，而不是使用模型的内部嵌入查找矩阵。

+   `image_embeds` (`torch.FloatTensor` of shape `(batch_size, num_patches, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递`pixel_values`。如果您想要更多控制如何将`pixel_values`转换为补丁嵌入，这将非常有用。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

+   `labels` (`torch.LongTensor` of shape `(batch_size,)`, *optional*) — 二元分类标签。

返回

`transformers.models.vilt.modeling_vilt.ViltForImagesAndTextClassificationOutput` 或 `tuple(torch.FloatTensor)`

一个`transformers.models.vilt.modeling_vilt.ViltForImagesAndTextClassificationOutput`或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（ViltConfig）和输入的不同元素。

+   `loss` (`torch.FloatTensor` of shape `(1,)`, *optional*, 当提供`labels`时返回) — 分类（如果`config.num_labels==1`则为回归）损失。

+   `logits` (`torch.FloatTensor` of shape `(batch_size, config.num_labels)`) — 分类（如果`config.num_labels==1`则为回归）分数（SoftMax 之前）。

+   `hidden_states` (`List[tuple(torch.FloatTensor)]`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 一个元组列表，每个元组包含每个图像-文本对的`torch.FloatTensor`输出（每个元组包含嵌入的输出和每个层的输出），形状为`(batch_size, sequence_length, hidden_size)`。模型在每个层的输出处的隐藏状态加上初始嵌入输出。

+   `attentions` (`List[tuple(torch.FloatTensor)]`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 一个元组列表，每个元组包含形状为`(batch_size, num_heads, sequence_length, sequence_length)`的注意力权重的`torch.FloatTensor`（每个图像-文本对一个元组）。注意力 softmax 后的注意力权重，用于计算自注意力头中的加权平均值。

ViltForImagesAndTextClassification 前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者则默默地忽略它们。

示例：

```py
>>> from transformers import ViltProcessor, ViltForImagesAndTextClassification
>>> import requests
>>> from PIL import Image

>>> image1 = Image.open(requests.get("https://lil.nlp.cornell.edu/nlvr/exs/ex0_0.jpg", stream=True).raw)
>>> image2 = Image.open(requests.get("https://lil.nlp.cornell.edu/nlvr/exs/ex0_1.jpg", stream=True).raw)
>>> text = "The left image contains twice the number of dogs as the right image."

>>> processor = ViltProcessor.from_pretrained("dandelin/vilt-b32-finetuned-nlvr2")
>>> model = ViltForImagesAndTextClassification.from_pretrained("dandelin/vilt-b32-finetuned-nlvr2")

>>> # prepare inputs
>>> encoding = processor([image1, image2], text, return_tensors="pt")

>>> # forward pass
>>> outputs = model(input_ids=encoding.input_ids, pixel_values=encoding.pixel_values.unsqueeze(0))
>>> logits = outputs.logits
>>> idx = logits.argmax(-1).item()
>>> print("Predicted answer:", model.config.id2label[idx])
Predicted answer: True
```

## ViltForImageAndTextRetrieval

### `class transformers.ViltForImageAndTextRetrieval`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L1163)

```py
( config )
```

参数

+   `config`（ViltConfig） — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

Vilt 模型变压器，顶部带有分类器头（在[CLS]标记的最终隐藏状态之上的线性层），用于图像到文本或文本到图像检索，例如 MSCOCO 和 F30K。

这个模型是一个 PyTorch `torch.nn.Module <https://pytorch.org/docs/stable/nn.html#torch.nn.Module>`_ 的子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取与一般用法和行为相关的所有内容。

#### `forward`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L1182)

```py
( input_ids: Optional = None attention_mask: Optional = None token_type_ids: Optional = None pixel_values: Optional = None pixel_mask: Optional = None head_mask: Optional = None inputs_embeds: Optional = None image_embeds: Optional = None labels: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.SequenceClassifierOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`torch.LongTensor` of shape `({0})`) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `attention_mask` (`torch.FloatTensor` of shape `({0})`, *optional*) — 用于避免在填充标记索引上执行注意力的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示 `未掩码` 的标记，

    +   0 表示被 `掩码` 的标记。什么是注意力掩码？

+   `token_type_ids` (`torch.LongTensor` of shape `({0})`, *optional*) — 段标记索引，用于指示输入的第一部分和第二部分。索引在 `[0, 1]` 中选择：

    +   0 对应于 *句子 A* 标记，

    +   1 对应于 *句子 B* 标记。什么是标记类型 ID？

+   `pixel_values` (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`) — 像素值。可以使用 AutoImageProcessor 获取像素值。有关详细信息，请参阅 ViltImageProcessor.`call`()。

+   `pixel_mask` (`torch.LongTensor` of shape `(batch_size, height, width)`, *optional*) — 用于避免在填充像素值上执行注意力的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示真实的像素（即 `未掩码`），

    +   0 表示填充的像素（即 `掩码`）。`什么是注意力掩码？ <../glossary.html#attention-mask>`__

+   `head_mask` (`torch.FloatTensor` of shape `(num_heads,)` or `(num_layers, num_heads)`, *optional*) — 用于使自注意力模块中选择的头部失效的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示头部 `未掩码`，

    +   0 表示头部 `掩码`。

+   `inputs_embeds` (`torch.FloatTensor` of shape `({0}, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递 `input_ids`。如果您想要更多控制如何将 `input_ids` 索引转换为与模型的内部嵌入查找矩阵相关的向量，则这是有用的。

+   `image_embeds` (`torch.FloatTensor` of shape `(batch_size, num_patches, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递 `pixel_values`。如果您想要更多控制如何将 `pixel_values` 转换为补丁嵌入，则这是有用的。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量中的 `attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量中的 `hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回一个 ModelOutput 而不是一个普通的元组。

+   `labels` (`torch.LongTensor` of shape `(batch_size,)`, *optional*) — 目前不支持标签。

返回

transformers.modeling_outputs.SequenceClassifierOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.SequenceClassifierOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含各种元素，取决于配置（ViltConfig）和输入。

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，当提供`labels`时返回）- 分类（如果`config.num_labels==1`则为回归）损失。

+   `logits`（形状为`(batch_size, config.num_labels)`的`torch.FloatTensor`）- 分类（如果`config.num_labels==1`则为回归）得分（在 SoftMax 之前）。

+   `hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入的输出+每层的输出）。

    模型在每一层输出的隐藏状态加上可选的初始嵌入输出。

+   `attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    在自注意力头中用于计算加权平均值的注意力权重在注意力 softmax 之后。

ViltForImageAndTextRetrieval 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import ViltProcessor, ViltForImageAndTextRetrieval
>>> import requests
>>> from PIL import Image

>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> texts = ["An image of two cats chilling on a couch", "A football player scoring a goal"]

>>> processor = ViltProcessor.from_pretrained("dandelin/vilt-b32-finetuned-coco")
>>> model = ViltForImageAndTextRetrieval.from_pretrained("dandelin/vilt-b32-finetuned-coco")

>>> # forward pass
>>> scores = dict()
>>> for text in texts:
...     # prepare inputs
...     encoding = processor(image, text, return_tensors="pt")
...     outputs = model(**encoding)
...     scores[text] = outputs.logits[0, :].item()
```

## ViltForTokenClassification

### `class transformers.ViltForTokenClassification`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L1406)

```py
( config )
```

参数

+   `config`（ViltConfig）- 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

ViLT 模型在顶部有一个标记分类头（文本标记的最终隐藏状态上的线性层），例如用于命名实体识别（NER）任务。

这个模型是 PyTorch 的`torch.nn.Module <https://pytorch.org/docs/stable/nn.html#torch.nn.Module>`_ 子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有信息。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/vilt/modeling_vilt.py#L1426)

```py
( input_ids: Optional = None attention_mask: Optional = None token_type_ids: Optional = None pixel_values: Optional = None pixel_mask: Optional = None head_mask: Optional = None inputs_embeds: Optional = None image_embeds: Optional = None labels: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.TokenClassifierOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`({0})`的`torch.LongTensor`）- 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `attention_mask`（形状为`({0})`的`torch.FloatTensor`，*可选*）—用于避免在填充标记索引上执行注意力的遮罩。选择的遮罩值在`[0, 1]`中：

    +   1 表示`未被遮罩`的标记，

    +   0 表示`被遮罩`的标记。什么是注意力遮罩？

+   `token_type_ids`（形状为`({0})`的`torch.LongTensor`，*可选*）—段标记索引，指示输入的第一部分和第二部分。索引在`[0, 1]`中选择：

    +   0 对应于*句子 A*标记，

    +   1 对应于*句子 B*标记。什么是标记类型 ID？

+   `pixel_values`（形状为`(batch_size, num_channels, height, width)`的`torch.FloatTensor`）—像素值。可以使用 AutoImageProcessor 获取像素值。有关详细信息，请参阅 ViltImageProcessor.`call`()。

+   `pixel_mask`（形状为`(batch_size, height, width)`的`torch.LongTensor`，*可选*）—用于避免在填充像素值上执行注意力的遮罩。选择的遮罩值在`[0, 1]`中：

    +   1 表示真实的像素（即`未被遮罩`），

    +   0 表示填充的像素（即`被遮罩`）。`什么是注意力遮罩？<../glossary.html#attention-mask>`__

+   `head_mask`（形状为`(num_heads,)`或`(num_layers, num_heads)`的`torch.FloatTensor`，*可选*）—用于使自注意力模块的选定头部失效的遮罩。选择的遮罩值在`[0, 1]`中：

    +   1 表示头部`未被遮罩`，

    +   0 表示头部`被遮罩`。

+   `inputs_embeds`（形状为`({0}, hidden_size)`的`torch.FloatTensor`，*可选*）—可选地，可以直接传递嵌入表示，而不是传递`input_ids`。如果您想要更多控制如何将`input_ids`索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，这将非常有用。

+   `image_embeds`（形状为`(batch_size, num_patches, hidden_size)`的`torch.FloatTensor`，*可选*）—可选地，可以直接传递嵌入表示，而不是传递`pixel_values`。如果您想要更多控制如何将`pixel_values`转换为补丁嵌入，这将非常有用。

+   `output_attentions`（`bool`，*可选*）—是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）—是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）—是否返回 ModelOutput 而不是普通元组。

+   `labels`（形状为`(batch_size, text_sequence_length)`的`torch.LongTensor`，*可选*）—用于计算标记分类损失的标签。索引应在`[0, ..., config.num_labels - 1]`中。

返回

一个 transformers.modeling_outputs.TokenClassifierOutput 或者`tuple(torch.FloatTensor)`，

一个 transformers.modeling_outputs.TokenClassifierOutput 或者一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或者`config.return_dict=False`时）包括各种元素，取决于配置（ViltConfig）和输入。

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，在提供`labels`时返回）—分类损失。

+   `logits`（形状为`(batch_size, sequence_length, config.num_labels)`的`torch.FloatTensor`）—分类分数（SoftMax 之前）。

+   `hidden_states` (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`) — Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, + one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`。

    模型在每一层输出的隐藏状态以及可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`) — Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length, sequence_length)`。

    在自注意力头中用于计算加权平均值的注意力 softmax 后的注意力权重。

ViltForTokenClassification 的前向方法，覆盖了 `__call__` 特殊方法。

虽然前向传递的步骤需要在这个函数中定义，但应该在此之后调用 `Module` 实例，而不是在此处调用，因为前者会处理运行前后的处理步骤，而后者会默默地忽略它们。
