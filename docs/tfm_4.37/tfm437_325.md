# Wav2Vec2-Conformer

> 原文链接：[`huggingface.co/docs/transformers/v4.37.2/en/model_doc/wav2vec2-conformer`](https://huggingface.co/docs/transformers/v4.37.2/en/model_doc/wav2vec2-conformer)

## 概述

Wav2Vec2-Conformer 是由 Changhan Wang、Yun Tang、Xutai Ma、Anne Wu、Sravya Popuri、Dmytro Okhonko、Juan Pino 在更新版本的[fairseq S2T: Fast Speech-to-Text Modeling with fairseq](https://arxiv.org/abs/2010.05171)中添加的。

模型的官方结果可以在论文的表 3 和表 4 中找到。

Wav2Vec2-Conformer 权重由 Meta AI 团队在[Fairseq 库](https://github.com/pytorch/fairseq/blob/main/examples/wav2vec/README.md#pre-trained-models)中发布。

该模型由[patrickvonplaten](https://huggingface.co/patrickvonplaten)贡献。原始代码可以在[这里](https://github.com/pytorch/fairseq/tree/main/examples/wav2vec)找到。

## 使用提示

+   Wav2Vec2-Conformer 遵循与 Wav2Vec2 相同的架构，但将*Attention*-block 替换为*Conformer*-block，如[Conformer: Convolution-augmented Transformer for Speech Recognition](https://arxiv.org/abs/2005.08100)中介绍的那样。

+   对于相同数量的层，Wav2Vec2-Conformer 比 Wav2Vec2 需要更多的参数，但也能提高词错误率。

+   Wav2Vec2-Conformer 使用与 Wav2Vec2 相同的分词器和特征提取器。

+   Wav2Vec2-Conformer 可以通过设置正确的`config.position_embeddings_type`来使用无相对位置嵌入、类似 Transformer-XL 的位置嵌入或旋转位置嵌入。

## 资源

+   音频分类任务指南

+   自动语音识别任务指南

## Wav2Vec2ConformerConfig

### `class transformers.Wav2Vec2ConformerConfig`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/configuration_wav2vec2_conformer.py#L33)

```py
( vocab_size = None hidden_size = 768 num_hidden_layers = 12 num_attention_heads = 12 intermediate_size = 3072 hidden_act = 'gelu' hidden_dropout = 0.1 activation_dropout = 0.1 attention_dropout = 0.1 feat_proj_dropout = 0.0 feat_quantizer_dropout = 0.0 final_dropout = 0.1 layerdrop = 0.1 initializer_range = 0.02 layer_norm_eps = 1e-05 feat_extract_norm = 'group' feat_extract_activation = 'gelu' conv_dim = (512, 512, 512, 512, 512, 512, 512) conv_stride = (5, 2, 2, 2, 2, 2, 2) conv_kernel = (10, 3, 3, 3, 3, 2, 2) conv_bias = False num_conv_pos_embeddings = 128 num_conv_pos_embedding_groups = 16 apply_spec_augment = True mask_time_prob = 0.05 mask_time_length = 10 mask_time_min_masks = 2 mask_feature_prob = 0.0 mask_feature_length = 10 mask_feature_min_masks = 0 num_codevectors_per_group = 320 num_codevector_groups = 2 contrastive_logits_temperature = 0.1 num_negatives = 100 codevector_dim = 256 proj_codevector_dim = 256 diversity_loss_weight = 0.1 ctc_loss_reduction = 'sum' ctc_zero_infinity = False use_weighted_layer_sum = False classifier_proj_size = 256 tdnn_dim = (512, 512, 512, 512, 1500) tdnn_kernel = (5, 3, 3, 1, 1) tdnn_dilation = (1, 2, 3, 1, 1) xvector_output_dim = 512 pad_token_id = 0 bos_token_id = 1 eos_token_id = 2 add_adapter = False adapter_kernel_size = 3 adapter_stride = 2 num_adapter_layers = 3 output_hidden_size = None position_embeddings_type = 'relative' rotary_embedding_base = 10000 max_source_positions = 5000 conv_depthwise_kernel_size = 31 conformer_conv_dropout = 0.1 **kwargs )
```

参数

+   `vocab_size`（`int`，*可选*）— Wav2Vec2Conformer 模型的词汇表大小。定义了在调用 Wav2Vec2ConformerModel 时可以表示的不同令牌数量。模型的词汇表大小。定义了可以由传递给 Wav2Vec2ConformerModel 的*inputs_ids*表示的不同令牌。

+   `hidden_size`（`int`，*可选*，默认为 768）— 编码器层和池化层的维度。

+   `num_hidden_layers`（`int`，*可选*，默认为 12）— Transformer 编码器中的隐藏层数。

+   `num_attention_heads`（`int`，*可选*，默认为 12）— Transformer 编码器中每个注意力层的注意力头数。

+   `intermediate_size`（`int`，*可选*，默认为 3072）— Transformer 编码器中“中间”（即前馈）层的维度。

+   `hidden_act`（`str`或`function`，*可选*，默认为`"gelu"`）— 编码器和池化器中的非线性激活函数（函数或字符串）。如果是字符串，支持`"gelu"`、`"relu"`、`"selu"`和`"gelu_new"`。

+   `hidden_dropout`（`float`，*可选*，默认为 0.1）— 嵌入层、编码器和池化器中所有全连接层的 dropout 概率。

+   `activation_dropout`（`float`，*可选*，默认为 0.1）— 全连接层内部激活的 dropout 比率。

+   `attention_dropout`（`float`，*可选*，默认为 0.1）— 注意力概率的 dropout 比率。

+   `final_dropout`（`float`，*可选*，默认为 0.1）— Wav2Vec2ConformerForCTC 的最终投影层的 dropout 概率。

+   `layerdrop` (`float`, *optional*, defaults to 0.1) — LayerDrop 概率。有关更多详细信息，请参阅 LayerDrop paper)。

+   `initializer_range` (`float`, *optional*, defaults to 0.02) — 用于初始化所有权重矩阵的截断正态初始化器的标准差。

+   `layer_norm_eps` (`float`, *optional*, defaults to 1e-12) — 层归一化层使用的 epsilon。

+   `feat_extract_norm` (`str`, *optional*, defaults to `"group"`) — 应用于特征编码器中 1D 卷积层的规范化。`"group"`表示仅对第一个 1D 卷积层进行组归一化，`"layer"`表示对所有 1D 卷积层进行层归一化。

+   `feat_proj_dropout` (`float`, *optional*, defaults to 0.0) — 特征编码器输出的丢弃概率。

+   `feat_extract_activation` (`str,` optional`, defaults to` “gelu”`) -- 特征提取器中 1D 卷积层的非线性激活函数（函数或字符串）。如果是字符串，支持`“gelu”`、`“relu”`、`“selu”`和`“gelu_new”`。

+   `feat_quantizer_dropout` (`float`, *optional*, defaults to 0.0) — 量化特征编码器状态的丢弃概率。

+   `conv_dim` (`Tuple[int]` or `List[int]`, *optional*, defaults to `(512, 512, 512, 512, 512, 512, 512)`) — 定义特征编码器中每个 1D 卷积层的输入和输出通道数的整数元组。*conv_dim*的长度定义了 1D 卷积层的数量。

+   `conv_stride` (`Tuple[int]` or `List[int]`, *optional*, defaults to `(5, 2, 2, 2, 2, 2, 2)`) — 定义特征编码器中每个 1D 卷积层的步幅的整数元组。*conv_stride*的长度定义了卷积层的数量，并且必须与*conv_dim*的长度匹配。

+   `conv_kernel` (`Tuple[int]` or `List[int]`, *optional*, defaults to `(10, 3, 3, 3, 3, 3, 3)`) — 定义特征编码器中每个 1D 卷积层的内核大小的整数元组。*conv_kernel*的长度定义了卷积层的数量，并且必须与*conv_dim*的长度匹配。

+   `conv_bias` (`bool`, *optional*, defaults to `False`) — 1D 卷积层是否具有偏置。

+   `num_conv_pos_embeddings` (`int`, *optional*, defaults to 128) — 卷积位置嵌入的数量。定义了 1D 卷积位置嵌入层的内核大小。

+   `num_conv_pos_embedding_groups` (`int`, *optional*, defaults to 16) — 1D 卷积位置嵌入层的组数。

+   `apply_spec_augment` (`bool`, *optional*, defaults to `True`) — 是否对特征编码器的输出应用*SpecAugment*数据增强。有关详细信息，请参阅[SpecAugment: A Simple Data Augmentation Method for Automatic Speech Recognition](https://arxiv.org/abs/1904.08779)。

+   `mask_time_prob` (`float`, *optional*, defaults to 0.05) — 沿时间轴遮罩的所有特征向量的百分比（介于 0 和 1 之间）。遮罩过程在轴上生成”mask_time_prob*len(time_axis)/mask_time_length”个独立的掩码。如果从每个特征向量被选择为遮罩的向量跨度起始的概率推理，*mask_time_prob*应为`prob_vector_start*mask_time_length`。请注意，重叠可能会降低实际遮罩向量的百分比。仅在`apply_spec_augment`为 True 时相关。

+   `mask_time_length` (`int`, *optional*, defaults to 10) — 沿时间轴的向量跨度长度。

+   `mask_time_min_masks` (`int`, *optional*, defaults to 2), — 沿时间轴生成的长度为`mask_feature_length`的最小掩码数量，每个时间步，与`mask_feature_prob`无关。仅在”mask_time_prob*len(time_axis)/mask_time_length < mask_time_min_masks”时相关

+   `mask_feature_prob` (`float`, *optional*, 默认为 0.0) — 沿特征轴的所有特征向量中将被掩盖的百分比（介于 0 和 1 之间）。掩盖过程在轴上生成”mask_feature_prob*len(feature_axis)/mask_time_length”个独立掩码。如果从每个特征向量被选择为被掩盖的向量跨度的起始点的概率推理，*mask_feature_prob*应该是`prob_vector_start*mask_feature_length`。请注意，重叠可能会降低实际掩盖向量的百分比。仅在`apply_spec_augment`为 True 时相关。

+   `mask_feature_length` (`int`, *optional*, 默认为 10) — 沿特征轴的向量跨度长度。

+   `mask_feature_min_masks` (`int`, *optional*, 默认为 0) — 沿特征轴生成的长度为`mask_feature_length`的掩码的最小数量，每个时间步，与`mask_feature_prob`无关。仅在”mask_feature_prob*len(feature_axis)/mask_feature_length < mask_feature_min_masks”时相关。

+   `num_codevectors_per_group` (`int`, *optional*, 默认为 320) — 每个量化码书（组）中的条目数。

+   `num_codevector_groups` (`int`, *optional*, 默认为 2) — 产品码矢量量化的码矢量组数。

+   `contrastive_logits_temperature` (`float`, *optional*, 默认为 0.1) — 对比损失中的温度*kappa*。

+   `feat_quantizer_dropout` (`float`, *optional*, 默认为 0.0) — 用于量化器的特征编码器输出的丢失概率。

+   `num_negatives` (`int`, *optional*, 默认为 100) — 对比损失的负样本数量。

+   `codevector_dim` (`int`, *optional*, 默认为 256) — 量化特征向量的维度。

+   `proj_codevector_dim` (`int`, *optional*, 默认为 256) — 量化和变换特征的最终投影的维度。

+   `diversity_loss_weight` (`int`, *optional*, 默认为 0.1) — 代码本多样性损失组件的权重。

+   `ctc_loss_reduction` (`str`, *optional*, 默认为`"sum"`) — 指定应用于`torch.nn.CTCLoss`输出的减少方式。仅在训练 Wav2Vec2ConformerForCTC 实例时相关。

+   `ctc_zero_infinity` (`bool`, *optional*, 默认为`False`) — 是否将无穷损失和`torch.nn.CTCLoss`的相关梯度置零。当输入太短无法与目标对齐时，主要会出现无穷损失。仅在训练 Wav2Vec2ConformerForCTC 实例时相关。

+   `use_weighted_layer_sum` (`bool`, *optional*, 默认为`False`) — 是否使用具有学习权重的层输出的加权平均值。仅在使用 Wav2Vec2ConformerForSequenceClassification 实例时相关。

+   `classifier_proj_size` (`int`, *optional*, 默认为 256) — 用于分类的标记均值池化之前的投影的维度。

+   `tdnn_dim` (`Tuple[int]` 或 `List[int]`, *optional*, 默认为`(512, 512, 512, 512, 1500)`) — 定义*XVector*模型中*TDNN*模块中每个 1D 卷积层的输出通道数的整数元组。*tdnn_dim*的长度定义了*TDNN*层的数量。

+   `tdnn_kernel` (`Tuple[int]` 或 `List[int]`, *optional*, 默认为`(5, 3, 3, 1, 1)`) — 定义*XVector*模型中*TDNN*模块中每个 1D 卷积层的内核大小的整数元组。*tdnn_kernel*的长度必须与*tdnn_dim*的长度相匹配。

+   `tdnn_dilation` (`Tuple[int]` 或 `List[int]`, *可选*, 默认为`(1, 2, 3, 1, 1)`) — 一个整数元组，定义*XVector*模型中*TDNN*模块中每个 1D 卷积层的扩张因子。*tdnn_dilation*的长度必须与*tdnn_dim*的长度相匹配。

+   `xvector_output_dim` (`int`, *可选*, 默认为 512) — *XVector*嵌入向量的维度。

+   `add_adapter` (`bool`, *可选*, 默认为`False`) — 是否应在 Wav2Vec2Conformer 编码器顶部堆叠卷积网络。对于 Warm-starting Wav2Vec2Conformer 用于 SpeechEncoderDecoder 模型非常有用。

+   `adapter_kernel_size` (`int`, *可选*, 默认为 3) — 适配器网络中卷积层的核大小。仅在`add_adapter`为 True 时相关。

+   `adapter_stride` (`int`, *可选*, 默认为 2) — 适配器网络中卷积层的步幅。仅在`add_adapter`为 True 时相关。

+   `num_adapter_layers` (`int`, *可选*, 默认为 3) — 适配器网络中应使用的卷积层的数量。仅在`add_adapter`为 True 时相关。

+   `output_hidden_size` (`int`, *可选*) — 编码器输出层的维度。如果未定义，则默认为*hidden-size*。仅在`add_adapter`为 True 时相关。

+   `position_embeddings_type` (`str`, *可选*, 默认为`"relative"`) — 可以指定为`relative`或`rotary`，分别用于相对位置嵌入或旋转位置嵌入。如果为`None`，则不应用相对位置嵌入。

+   `rotary_embedding_base` (`int`, *可选*, 默认为 10000) — 如果使用`"rotary"`位置嵌入，定义嵌入基数的大小。

+   `max_source_positions` (`int`, *可选*, 默认为 5000) — 如果使用`"relative"`位置嵌入，定义最大源输入位置。

+   `conv_depthwise_kernel_size` (`int`, 默认为 31) — Conformer 块中深度卷积 1D 层的核大小。

+   `conformer_conv_dropout` (`float`, 默认为 0.1) — Conformer 块中所有卷积层的 dropout 概率。

这是用于存储 Wav2Vec2ConformerModel 配置的配置类。根据指定的参数实例化一个 Wav2Vec2Conformer 模型，定义模型架构。使用默认值实例化配置将产生类似于 Wav2Vec2Conformer [facebook/wav2vec2-conformer-rel-pos-large](https://huggingface.co/facebook/wav2vec2-conformer-rel-pos-large)架构的配置。

配置对象继承自 PretrainedConfig，可用于控制模型输出。阅读 PretrainedConfig 的文档以获取更多信息。

示例：

```py
>>> from transformers import Wav2Vec2ConformerConfig, Wav2Vec2ConformerModel

>>> # Initializing a Wav2Vec2Conformer facebook/wav2vec2-conformer-rel-pos-large style configuration
>>> configuration = Wav2Vec2ConformerConfig()

>>> # Initializing a model (with random weights) from the facebook/wav2vec2-conformer-rel-pos-large style configuration
>>> model = Wav2Vec2ConformerModel(configuration)

>>> # Accessing the model configuration
>>> configuration = model.config
```

## Wav2Vec2Conformer 特定输出

### `class transformers.models.wav2vec2_conformer.modeling_wav2vec2_conformer.Wav2Vec2ConformerForPreTrainingOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L72)

```py
( loss: Optional = None projected_states: FloatTensor = None projected_quantized_states: FloatTensor = None codevector_perplexity: FloatTensor = None hidden_states: Optional = None attentions: Optional = None contrastive_loss: Optional = None diversity_loss: Optional = None )
```

参数

+   `loss` (*可选*, 当传递`sample_negative_indices`时返回，`torch.FloatTensor`，形状为`(1,)`) — 总损失，作为对比损失(L_m)和多样性损失(L_d)的总和，如[官方论文](https://arxiv.org/pdf/2006.11477.pdf)中所述。 (分类)损失。

+   `projected_states` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, config.proj_codevector_dim)`) — 模型的隐藏状态投影到*config.proj_codevector_dim*，可用于预测掩码投影量化状态。

+   `projected_quantized_states`（形状为`(batch_size, sequence_length, config.proj_codevector_dim)`的`torch.FloatTensor`）— 量化提取的特征向量投影到*config.proj_codevector_dim*，表示对比损失的正目标向量。

+   `hidden_states`（`tuple(torch.FloatTensor)`，*可选*，在传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）— 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（一个用于嵌入的输出 + 一个用于每个层的输出）。

    模型在每一层输出的隐藏状态以及初始嵌入输出。

+   `attentions`（`tuple(torch.FloatTensor)`，*可选*，在传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    在注意力 softmax 之后的注意力权重，用于计算自注意力头中的加权平均值。

+   `contrastive_loss`（*可选*，在传递`sample_negative_indices`时返回，形状为`(1,)`的`torch.FloatTensor`）— 对比损失（L_m），如[官方论文](https://arxiv.org/pdf/2006.11477.pdf)中所述。

+   `diversity_loss`（*可选*，在传递`sample_negative_indices`时返回，形状为`(1,)`的`torch.FloatTensor`）— 多样性损失（L_d），如[官方论文](https://arxiv.org/pdf/2006.11477.pdf)中所述。

Wav2Vec2ConformerForPreTraining 的输出类型，具有潜在的隐藏状态和注意力。

## Wav2Vec2ConformerModel

### `class transformers.Wav2Vec2ConformerModel`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1226)

```py
( config: Wav2Vec2ConformerConfig )
```

参数

+   `config`（Wav2Vec2ConformerConfig）— 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

裸的 Wav2Vec2Conformer 模型变压器，输出原始隐藏状态，没有特定的头部。Wav2Vec2Conformer 是由 Alexei Baevski、Henry Zhou、Abdelrahman Mohamed、Michael Auli 在[wav2vec 2.0: A Framework for Self-Supervised Learning of Speech Representations](https://arxiv.org/abs/2006.11477)中提出的。

这个模型继承自 PreTrainedModel。查看超类文档，了解库为所有模型实现的通用方法（如下载或保存等）。

这个模型是 PyTorch [nn.Module](https://pytorch.org/docs/stable/nn.html#nn.Module)的子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取与一般用法和行为相关的所有内容。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1303)

```py
( input_values: Optional attention_mask: Optional = None mask_time_indices: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Wav2Vec2BaseModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_values`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`）— 输入原始语音波形的浮点值。可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得值，例如通过 soundfile 库（`pip install soundfile`）。要将数组准备成`input_values`，应使用 AutoProcessor 进行填充和转换为`torch.FloatTensor`类型的张量。有关详细信息，请参阅 Wav2Vec2Processor.`call`()。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`，*可选*）— 用于避免在填充标记索引上执行卷积和注意力的掩码。选择在`[0, 1]`范围内的掩码值：

    +   对于未被`masked`的标记为 1，

    +   对于被`masked`的标记为 0。

    什么是注意力掩码？

    只有当相应的处理器具有`config.return_attention_mask == True`时，才应传递`attention_mask`。对于所有处理器具有`config.return_attention_mask == False`的模型，例如[wav2vec2-conformer-rel-pos-large](https://huggingface.co/facebook/wav2vec2-conformer-rel-pos-large)，在进行批量推断时，应`不`传递`attention_mask`以避免性能下降。对于这样的模型，`input_values`应该简单地用 0 填充并在不传递`attention_mask`的情况下传递。请注意，这些模型根据`input_values`是否填充会产生略有不同的结果。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回 ModelOutput 而不是普通元组。

返回

transformers.modeling_outputs.Wav2Vec2BaseModelOutput 或`tuple(torch.FloatTensor)`

transformers.modeling_outputs.Wav2Vec2BaseModelOutput 或`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`，或输入取决于配置（Wav2Vec2ConformerConfig）和输入。

+   `last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`）— 模型最后一层的隐藏状态序列。

+   `extract_features`（形状为`(batch_size, sequence_length, conv_dim[-1])`的`torch.FloatTensor`）— 模型最后一个卷积层的提取特征向量序列。

+   `hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）— 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（嵌入输出的一个+每层输出的一个）。

    每层模型的隐藏状态加上初始嵌入输出。

+   `attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    注意力权重在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

Wav2Vec2ConformerModel 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的方法需要在这个函数中定义，但应该在之后调用`Module`实例，而不是在这里调用，因为前者会处理运行前后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoProcessor, Wav2Vec2ConformerModel
>>> import torch
>>> from datasets import load_dataset

>>> dataset = load_dataset("hf-internal-testing/librispeech_asr_demo", "clean", split="validation")
>>> dataset = dataset.sort("id")
>>> sampling_rate = dataset.features["audio"].sampling_rate

>>> processor = AutoProcessor.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")
>>> model = Wav2Vec2ConformerModel.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")

>>> # audio file is decoded on the fly
>>> inputs = processor(dataset[0]["audio"]["array"], sampling_rate=sampling_rate, return_tensors="pt")
>>> with torch.no_grad():
...     outputs = model(**inputs)

>>> last_hidden_states = outputs.last_hidden_state
>>> list(last_hidden_states.shape)
[1, 292, 1024]
```

## Wav2Vec2ConformerForCTC

### `class transformers.Wav2Vec2ConformerForCTC`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1582)

```py
( config target_lang: Optional = None )
```

参数

+   `config` (Wav2Vec2ConformerConfig) — 模型的所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只会加载配置。查看 from_pretrained()方法来加载模型权重。

带有顶部`语言建模`头部的 Wav2Vec2Conformer 模型，用于连接主义时间分类（CTC）。Wav2Vec2Conformer 是由 Alexei Baevski、Henry Zhou、Abdelrahman Mohamed、Michael Auli 在[wav2vec 2.0: A Framework for Self-Supervised Learning of Speech Representations](https://arxiv.org/abs/2006.11477)中提出的。

这个模型继承自 PreTrainedModel。检查超类文档以获取库为所有模型实现的通用方法（如下载或保存等）。

这个模型是 PyTorch 的[nn.Module](https://pytorch.org/docs/stable/nn.html#nn.Module)子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1619)

```py
( input_values: Optional attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None labels: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.CausalLMOutput or tuple(torch.FloatTensor)
```

参数

+   `input_values`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`）— 输入原始语音波形的浮点值。值可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，例如通过声音文件库（`pip install soundfile`）。要准备好数组为`input_values`，应使用 AutoProcessor 进行填充和转换为`torch.FloatTensor`类型的张量。有关详细信息，请参阅 Wav2Vec2Processor.`call`()。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`，*可选*）— 用于避免在填充标记索引上执行卷积和注意力的掩码。选择的掩码值在`[0, 1]`中：

    +   1 表示`未被掩码`的标记，

    +   0 表示`被掩码`的标记。

    什么是注意力掩码？

    只有在相应的处理器具有`config.return_attention_mask == True`时才应传递`attention_mask`。对于所有处理器具有`config.return_attention_mask == False`的模型，比如[wav2vec2-conformer-rel-pos-large](https://huggingface.co/facebook/wav2vec2-conformer-rel-pos-large)，在进行批量推理时，应`不`传递`attention_mask`以避免性能下降。对于这样的模型，`input_values`应该简单地用 0 填充并在不传递`attention_mask`的情况下传递。请注意，这些模型根据`input_values`是否填充会产生略微不同的结果。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）- 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）- 是否返回 ModelOutput 而不是普通元组。

+   `labels`（形状为`(batch_size, target_length)`的`torch.LongTensor`，*可选*）- 用于连接主义时间分类的标签。请注意，`target_length`必须小于或等于输出 logits 的序列长度。索引在`[-100, 0, ..., config.vocab_size - 1]`中选择。所有设置为`-100`的标签都被忽略（掩码），损失仅计算`[0, ..., config.vocab_size - 1]`中的标签。

返回

transformers.modeling_outputs.CausalLMOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.CausalLMOutput 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`时）包含根据配置（Wav2Vec2ConformerConfig）和输入的各种元素。

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，当提供`labels`时返回）- 语言建模损失（用于下一个标记预测）。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`torch.FloatTensor`）- 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层的输出一个，+每层输出的一个）。

    模型在每一层输出的隐藏状态加上可选的初始嵌入输出。

+   `attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    在注意力 softmax 之后的注意力权重，用于计算自注意力头中的加权平均值。

Wav2Vec2ConformerForCTC 的前向方法，覆盖`__call__`特殊方法。

尽管前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者则默默地忽略它们。

示例：

```py
>>> from transformers import AutoProcessor, Wav2Vec2ConformerForCTC
>>> from datasets import load_dataset
>>> import torch

>>> dataset = load_dataset("hf-internal-testing/librispeech_asr_demo", "clean", split="validation")
>>> dataset = dataset.sort("id")
>>> sampling_rate = dataset.features["audio"].sampling_rate

>>> processor = AutoProcessor.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")
>>> model = Wav2Vec2ConformerForCTC.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")

>>> # audio file is decoded on the fly
>>> inputs = processor(dataset[0]["audio"]["array"], sampling_rate=sampling_rate, return_tensors="pt")
>>> with torch.no_grad():
...     logits = model(**inputs).logits
>>> predicted_ids = torch.argmax(logits, dim=-1)

>>> # transcribe speech
>>> transcription = processor.batch_decode(predicted_ids)
>>> transcription[0]
'MISTER QUILTER IS THE APOSTLE OF THE MIDDLE CLASSES AND WE ARE GLAD TO WELCOME HIS GOSPEL'

>>> inputs["labels"] = processor(text=dataset[0]["text"], return_tensors="pt").input_ids

>>> # compute loss
>>> loss = model(**inputs).loss
>>> round(loss.item(), 2)
64.21
```

## Wav2Vec2ConformerForSequenceClassification

### `class transformers.Wav2Vec2ConformerForSequenceClassification`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1700)

```py
( config )
```

参数

+   `config`（Wav2Vec2ConformerConfig）- 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

带有顶部序列分类头（池化输出上的线性层）的 Wav2Vec2Conformer 模型，用于类似 SUPERB 关键词检测的任务。

Wav2Vec2Conformer 是由 Alexei Baevski、Henry Zhou、Abdelrahman Mohamed、Michael Auli 在[wav2vec 2.0:自监督学习语音表示的框架](https://arxiv.org/abs/2006.11477)中提出的。

此模型继承自 PreTrainedModel。检查超类文档以获取库实现的所有模型的通用方法（例如下载或保存等）。

此模型是 PyTorch [nn.Module](https://pytorch.org/docs/stable/nn.html#nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取与一般用法和行为相关的所有事项。

#### `前向`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1742)

```py
( input_values: Optional attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None labels: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.SequenceClassifierOutput or tuple(torch.FloatTensor)
```

参数

+   `input_values`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`）— 输入原始语音波形的浮点值。值可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，*例如*通过 soundfile 库（`pip install soundfile`）。要准备数组为`input_values`，应使用 AutoProcessor 进行填充和转换为`torch.FloatTensor`类型的张量。有关详细信息，请参阅 Wav2Vec2Processor.`call`()。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`，*可选*）— 用于避免在填充标记索引上执行卷积和注意力的蒙版。选择的蒙版值在`[0, 1]`范围内：

    +   对于`未屏蔽`的标记，

    +   对于`屏蔽`的标记为 0。

    注意力蒙版是什么？

    只有当相应处理器具有`config.return_attention_mask == True`时，才应传递`attention_mask`。对于所有处理器具有`config.return_attention_mask == False`的模型，例如[wav2vec2-conformer-rel-pos-large](https://huggingface.co/facebook/wav2vec2-conformer-rel-pos-large)，在进行批量推断时，应`不`传递`attention_mask`以避免性能下降。对于这些模型，`input_values`应简单地填充为 0 并在不传递`attention_mask`的情况下传递。请注意，这些模型的结果也会因`input_values`是否填充而略有不同。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回 ModelOutput 而不是普通元组。

+   `labels`（形状为`(batch_size,)`的`torch.LongTensor`，*可选*）— 用于计算序列分类/回归损失的标签。索引应在`[0, ..., config.num_labels - 1]`范围内。如果`config.num_labels == 1`，则计算回归损失（均方损失），如果`config.num_labels > 1`，则计算分类损失（交叉熵）。

返回

transformers.modeling_outputs.SequenceClassifierOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.SequenceClassifierOutput 或一个 `torch.FloatTensor` 元组（如果传递了 `return_dict=False` 或当 `config.return_dict=False` 时）包含各种元素，这取决于配置（Wav2Vec2ConformerConfig）和输入。

+   `损失` (`torch.FloatTensor`，形状为`(1,)`，*可选*，当提供`labels`时返回) — 分类（如果`config.num_labels==1`则为回归）损失。

+   `logits` (`torch.FloatTensor`，形状为`(batch_size, config.num_labels)`) — 分类（如果`config.num_labels==1`则为回归）得分（SoftMax 之前）。

+   `hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递 `output_hidden_states=True` 或当 `config.output_hidden_states=True` 时返回） — 形状为`(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor` 元组（如果模型有嵌入层，则为嵌入的输出 + 每层的输出）。

    模型在每一层输出处的隐藏状态以及可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递 `output_attentions=True` 或当 `config.output_attentions=True` 时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组（每层一个）。

    注意力 softmax 后的注意力权重，用于计算自注意力头中的加权平均值。

Wav2Vec2ConformerForSequenceClassification 的前向方法重写了 `__call__` 特殊方法。

虽然前向传递的方法需要在此函数内定义，但应该在此之后调用 `Module` 实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoFeatureExtractor, Wav2Vec2ConformerForSequenceClassification
>>> from datasets import load_dataset
>>> import torch

>>> dataset = load_dataset("hf-internal-testing/librispeech_asr_demo", "clean", split="validation")
>>> dataset = dataset.sort("id")
>>> sampling_rate = dataset.features["audio"].sampling_rate

>>> feature_extractor = AutoFeatureExtractor.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")
>>> model = Wav2Vec2ConformerForSequenceClassification.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")

>>> # audio file is decoded on the fly
>>> inputs = feature_extractor(dataset[0]["audio"]["array"], sampling_rate=sampling_rate, return_tensors="pt")

>>> with torch.no_grad():
...     logits = model(**inputs).logits

>>> predicted_class_ids = torch.argmax(logits, dim=-1).item()
>>> predicted_label = model.config.id2label[predicted_class_ids]

>>> # compute loss - target_label is e.g. "down"
>>> target_label = model.config.id2label[0]
>>> inputs["labels"] = torch.tensor([model.config.label2id[target_label]])
>>> loss = model(**inputs).loss
```

## Wav2Vec2ConformerForAudioFrameClassification

### `class transformers.Wav2Vec2ConformerForAudioFrameClassification`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1812)

```py
( config )
```

参数

+   `config` (Wav2Vec2ConformerConfig) — 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只会加载配置。查看 from_pretrained() 方法以加载模型权重。

Wav2Vec2Conformer 模型在顶部带有一个帧分类头，用于说话人分离等任务。

Wav2Vec2Conformer 是由 Alexei Baevski、Henry Zhou、Abdelrahman Mohamed、Michael Auli 在 [wav2vec 2.0: A Framework for Self-Supervised Learning of Speech Representations](https://arxiv.org/abs/2006.11477) 中提出的。

这个模型继承自 PreTrainedModel。检查超类文档以获取库为所有模型实现的通用方法（如下载或保存等）。

这个模型是一个 PyTorch [nn.Module](https://pytorch.org/docs/stable/nn.html#nn.Module) 的子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取与一般用法和行为相关的所有内容。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1853)

```py
( input_values: Optional attention_mask: Optional = None labels: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.TokenClassifierOutput or tuple(torch.FloatTensor)
```

参数

+   `input_values` (`torch.FloatTensor`，形状为`(batch_size, sequence_length)`) — 输入原始语音波形的浮点值。可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得值，例如通过 soundfile 库（`pip install soundfile`）。要准备好数组为`input_values`，应使用 AutoProcessor 进行填充和转换为`torch.FloatTensor`类型的张量。有关详细信息，请参见 Wav2Vec2Processor.`call`()。

+   `attention_mask` (`torch.LongTensor`，形状为`(batch_size, sequence_length)`, *可选*) — 用于避免在填充标记索引上执行卷积和注意力的掩码。选择的掩码值在`[0, 1]`范围内：

    +   对于未被掩码的标记为`1`，

    +   对于被掩码的标记为`0`。

    注意力掩码是什么？

    只有当相应的处理器具有`config.return_attention_mask == True`时才应传递`attention_mask`。对于所有处理器具有`config.return_attention_mask == False`的模型，例如[wav2vec2-conformer-rel-pos-large](https://huggingface.co/facebook/wav2vec2-conformer-rel-pos-large)，在进行批量推断时应避免传递`attention_mask`以避免性能下降。对于这些模型，`input_values`应简单地填充为 0 并在没有`attention_mask`的情况下传递。请注意，这些模型的结果也会因`input_values`是否填充而略有不同。

+   `output_attentions` (`bool`, *可选*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *可选*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *可选*) — 是否返回一个 ModelOutput 而不是一个普通元组。

+   `labels` (`torch.LongTensor`，形状为`(batch_size,)`, *可选*) — 用于计算序列分类/回归损失的标签。索引应在`[0, ..., config.num_labels - 1]`范围内。如果`config.num_labels == 1`，则计算回归损失（均方损失），如果`config.num_labels > 1`，则计算分类损失（交叉熵）。

返回

transformers.modeling_outputs.TokenClassifierOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.TokenClassifierOutput 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`时）包括根据配置（Wav2Vec2ConformerConfig）和输入的不同元素。

+   `loss` (`torch.FloatTensor`，形状为`(1,)`, *可选*, 当提供`labels`时返回) — 分类损失。

+   `logits` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, config.num_labels)`) — 分类分数（SoftMax 之前）。

+   `hidden_states` (`tuple(torch.FloatTensor)`, *可选*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出的一个+每个层的输出的一个）。

    模型在每个层的输出以及可选的初始嵌入输出的隐藏状态。

+   `attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    注意力 softmax 后的注意力权重，用于计算自注意力头中的加权平均值。

Wav2Vec2ConformerForAudioFrameClassification 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此之后调用，因为前者负责运行前处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoFeatureExtractor, Wav2Vec2ConformerForAudioFrameClassification
>>> from datasets import load_dataset
>>> import torch

>>> dataset = load_dataset("hf-internal-testing/librispeech_asr_demo", "clean", split="validation")
>>> dataset = dataset.sort("id")
>>> sampling_rate = dataset.features["audio"].sampling_rate

>>> feature_extractor = AutoFeatureExtractor.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")
>>> model = Wav2Vec2ConformerForAudioFrameClassification.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")

>>> # audio file is decoded on the fly
>>> inputs = feature_extractor(dataset[0]["audio"]["array"], return_tensors="pt", sampling_rate=sampling_rate)
>>> with torch.no_grad():
...     logits = model(**inputs).logits

>>> probabilities = torch.sigmoid(logits[0])
>>> # labels is a one-hot array of shape (num_frames, num_speakers)
>>> labels = (probabilities > 0.5).long()
```

## Wav2Vec2ConformerForXVector

### `class transformers.Wav2Vec2ConformerForXVector`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1966)

```py
( config )
```

参数

+   `config`（Wav2Vec2ConformerConfig）- 模型的所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

Wav2Vec2Conformer 模型，顶部带有 XVector 特征提取头，用于说话者验证等任务。

Wav2Vec2Conformer 是由 Alexei Baevski、Henry Zhou、Abdelrahman Mohamed、Michael Auli 在[wav2vec 2.0: A Framework for Self-Supervised Learning of Speech Representations](https://arxiv.org/abs/2006.11477)中提出的。

此模型继承自 PreTrainedModel。查看超类文档以了解库为所有模型实现的通用方法（如下载或保存等）。

此模型是 PyTorch [nn.Module](https://pytorch.org/docs/stable/nn.html#nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L2025)

```py
( input_values: Optional attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None labels: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.XVectorOutput or tuple(torch.FloatTensor)
```

参数

+   `input_values`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`）- 输入原始语音波形的浮点值。值可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，*例如*通过 soundfile 库（`pip install soundfile`）。要准备好数组为`input_values`，应使用 AutoProcessor 进行填充和转换为`torch.FloatTensor`类型的张量。有关详细信息，请参阅 Wav2Vec2Processor.`call`()。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`，*可选*）- 用于避免在填充令牌索引上执行卷积和注意力的掩码。掩码值选在`[0, 1]`之间：

    +   对于未被`masked`的令牌为 1。

    +   对于被`masked`的令牌为 0。

    什么是注意力掩码？

    只有当相应的处理器具有 `config.return_attention_mask == True` 时才应传递 `attention_mask`。对于所有处理器具有 `config.return_attention_mask == False` 的模型，比如 [wav2vec2-conformer-rel-pos-large](https://huggingface.co/facebook/wav2vec2-conformer-rel-pos-large)，在进行批量推理时，应该 `不` 传递 `attention_mask` 以避免性能下降。对于这些模型，`input_values` 应该简单地用 0 填充并在不传递 `attention_mask` 的情况下传递。请注意，这些模型根据 `input_values` 是否填充会产生略有不同的结果。

+   `output_attentions`（`bool`，*可选*） — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的 `attentions`。

+   `output_hidden_states`（`bool`，*可选*） — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的 `hidden_states`。

+   `return_dict`（`bool`，*可选*） — 是否返回 ModelOutput 而不是普通元组。

+   `labels`（形状为 `(batch_size,)` 的 `torch.LongTensor`，*可选*） — 用于计算序列分类/回归损失的标签。索引应在 `[0, ..., config.num_labels - 1]` 范围内。如果 `config.num_labels == 1`，则计算回归损失（均方损失），如果 `config.num_labels > 1`，则计算分类损失（交叉熵）。

返回

transformers.modeling_outputs.XVectorOutput 或 `tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.XVectorOutput 或一个 `torch.FloatTensor` 元组（如果传递了 `return_dict=False` 或当 `config.return_dict=False` 时）包含根据配置（Wav2Vec2ConformerConfig）和输入不同的元素。

+   `loss`（形状为 `(1,)` 的 `torch.FloatTensor`，*可选*，当提供 `labels` 时返回） — 分类损失。

+   `logits`（形状为 `(batch_size, config.xvector_output_dim)` 的 `torch.FloatTensor`） — AMSoftmax 之前的分类隐藏状态。

+   `embeddings`（形状为 `(batch_size, config.xvector_output_dim)` 的 `torch.FloatTensor`） — 用于基于向量相似性检索的话语嵌入。

+   `hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递 `output_hidden_states=True` 或当 `config.output_hidden_states=True` 时返回） — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor` 元组（一个用于嵌入的输出 + 一个用于每一层的输出）。

    模型在每一层输出的隐藏状态加上初始嵌入输出。

+   `attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递 `output_attentions=True` 或当 `config.output_attentions=True` 时返回） — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组（每层一个）。

    在注意力 softmax 之后的注意力权重，用于计算自注意力头中的加权平均值。

Wav2Vec2ConformerForXVector 的前向方法，覆盖了 `__call__` 特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用 `Module` 实例而不是这个，因为前者会负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoFeatureExtractor, Wav2Vec2ConformerForXVector
>>> from datasets import load_dataset
>>> import torch

>>> dataset = load_dataset("hf-internal-testing/librispeech_asr_demo", "clean", split="validation")
>>> dataset = dataset.sort("id")
>>> sampling_rate = dataset.features["audio"].sampling_rate

>>> feature_extractor = AutoFeatureExtractor.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")
>>> model = Wav2Vec2ConformerForXVector.from_pretrained("facebook/wav2vec2-conformer-rope-large-960h-ft")

>>> # audio file is decoded on the fly
>>> inputs = feature_extractor(
...     [d["array"] for d in dataset[:2]["audio"]], sampling_rate=sampling_rate, return_tensors="pt", padding=True
... )
>>> with torch.no_grad():
...     embeddings = model(**inputs).embeddings

>>> embeddings = torch.nn.functional.normalize(embeddings, dim=-1).cpu()

>>> # the resulting embeddings can be used for cosine similarity-based retrieval
>>> cosine_sim = torch.nn.CosineSimilarity(dim=-1)
>>> similarity = cosine_sim(embeddings[0], embeddings[1])
>>> threshold = 0.7  # the optimal threshold is dataset-dependent
>>> if similarity < threshold:
...     print("Speakers are not the same!")
```

## Wav2Vec2ConformerForPreTraining

### `class transformers.Wav2Vec2ConformerForPreTraining`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1365)

```py
( config: Wav2Vec2ConformerConfig )
```

参数

+   `config` (Wav2Vec2ConformerConfig) — 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

带有量化器和`VQ`头部的 Wav2Vec2Conformer 模型。Wav2Vec2Conformer 是由 Alexei Baevski、Henry Zhou、Abdelrahman Mohamed、Michael Auli 在[wav2vec 2.0: A Framework for Self-Supervised Learning of Speech Representations](https://arxiv.org/abs/2006.11477)中提出的。

这个模型继承自 PreTrainedModel。查看超类文档以获取库为所有模型实现的通用方法（如下载或保存等）。

这个模型是 PyTorch 的[nn.Module](https://pytorch.org/docs/stable/nn.html#nn.Module)子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/wav2vec2_conformer/modeling_wav2vec2_conformer.py#L1420)

```py
( input_values: Optional attention_mask: Optional = None mask_time_indices: Optional = None sampled_negative_indices: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.models.wav2vec2_conformer.modeling_wav2vec2_conformer.Wav2Vec2ConformerForPreTrainingOutput or tuple(torch.FloatTensor)
```

参数

+   `input_values` (`torch.FloatTensor`，形状为`(batch_size, sequence_length)`) — 输入原始语音波形的浮点值。可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得值，*例如*通过 soundfile 库（`pip install soundfile`）。为了准备数组为`input_values`，应使用 AutoProcessor 进行填充和转换为`torch.FloatTensor`类型的张量。查看 Wav2Vec2Processor.`call`()获取详细信息。

+   `attention_mask` (`torch.LongTensor`，形状为`(batch_size, sequence_length)`，*可选*) — 用于避免在填充标记索引上执行卷积和注意力的掩码。掩码值选在`[0, 1]`之间：

    +   1 表示`未被掩码`的标记，

    +   0 表示`被掩码`的标记。

    注意力掩码是什么？

    只有当相应的处理器具有`config.return_attention_mask == True`时，才应传递`attention_mask`。对于所有处理器具有`config.return_attention_mask == False`的模型，比如[wav2vec2-conformer-rel-pos-large](https://huggingface.co/facebook/wav2vec2-conformer-rel-pos-large)，在进行批量推理时，应`不`传递`attention_mask`以避免性能下降。对于这样的模型，`input_values`应该简单地用 0 填充并在不传递`attention_mask`的情况下传递。请注意，这些模型根据`input_values`是否填充会产生略有不同的结果。

+   `output_attentions` (`bool`, *可选*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请查看返回的张量下的`attentions`。

+   `output_hidden_states` (`bool`, *可选*) — 是否返回所有层的隐藏状态。有关更多详细信息，请查看返回的张量下的`hidden_states`。

+   `return_dict` (`bool`, *可选*) — 是否返回一个 ModelOutput 而不是一个普通的元组。

+   `mask_time_indices` (`torch.BoolTensor`，形状为`(batch_size, sequence_length)`，*可选*) — 用于对对比损失的提取特征进行掩码的索引。在训练模式下，模型学习在*config.proj_codevector_dim*空间中预测掩码提取特征。

+   `sampled_negative_indices` (`torch.BoolTensor` of shape `(batch_size, sequence_length, num_negatives)`, *可选*) — 指示哪些量化目标向量用作对比损失中的负采样向量的索引。预训练所需的必要输入。

返回

transformers.models.wav2vec2_conformer.modeling_wav2vec2_conformer.Wav2Vec2ConformerForPreTrainingOutput 或 `tuple(torch.FloatTensor)`

一个 transformers.models.wav2vec2_conformer.modeling_wav2vec2_conformer.Wav2Vec2ConformerForPreTrainingOutput 或一个 `torch.FloatTensor` 元组（如果传入 `return_dict=False` 或 `config.return_dict=False`）包含各种元素，取决于配置（Wav2Vec2ConformerConfig）和输入。

+   `loss` (*可选*, 当传入 `sample_negative_indices` 时返回, `torch.FloatTensor` of shape `(1,)`) — 总损失，作为对比损失 (L_m) 和多样性损失 (L_d) 的和，如[官方论文](https://arxiv.org/pdf/2006.11477.pdf)中所述。 (分类) 损失。

+   `projected_states` (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.proj_codevector_dim)`) — 模型隐藏状态投影到 *config.proj_codevector_dim*，可用于预测掩码投影量化状态。

+   `projected_quantized_states` (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.proj_codevector_dim)`) — 量化提取的特征向量投影到 *config.proj_codevector_dim*，代表对比损失的正目标向量。

+   `hidden_states` (`tuple(torch.FloatTensor)`, *可选*, 当传入 `output_hidden_states=True` 或 `config.output_hidden_states=True` 时返回) — 由形状为 `(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor` 元组组成（一个用于嵌入输出，一个用于每一层的输出）。

    模型在每一层输出的隐藏状态加上初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`, *可选*, 当传入 `output_attentions=True` 或 `config.output_attentions=True` 时返回) — 由形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组组成（每一层一个）。

    注意力权重经过注意力 softmax 后的结果，用于计算自注意力头中的加权平均值。

+   `contrastive_loss` (*可选*, 当传入 `sample_negative_indices` 时返回, `torch.FloatTensor` of shape `(1,)`) — 如[官方论文](https://arxiv.org/pdf/2006.11477.pdf)中所述的对比损失 (L_m)。

+   `diversity_loss` (*可选*, 当传入 `sample_negative_indices` 时返回, `torch.FloatTensor` of shape `(1,)`) — 如[官方论文](https://arxiv.org/pdf/2006.11477.pdf)中所述的多样性损失 (L_d)。

Wav2Vec2ConformerForPreTraining 的前向方法，覆盖了 `__call__` 特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用 `Module` 实例，而不是在此处调用，因为前者会处理运行前后处理步骤，而后者会默默地忽略它们。

例如：

```py
>>> import torch
>>> from transformers import AutoFeatureExtractor, Wav2Vec2ConformerForPreTraining
>>> from transformers.models.wav2vec2_conformer.modeling_wav2vec2_conformer import _compute_mask_indices, _sample_negative_indices
>>> from datasets import load_dataset

>>> feature_extractor = AutoFeatureExtractor.from_pretrained("facebook/wav2vec2-conformer-rel-pos-large")
>>> model = Wav2Vec2ConformerForPreTraining.from_pretrained("facebook/wav2vec2-conformer-rel-pos-large")

>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")
>>> input_values = feature_extractor(ds[0]["audio"]["array"], return_tensors="pt").input_values  # Batch size 1

>>> # compute masked indices
>>> batch_size, raw_sequence_length = input_values.shape
>>> sequence_length = model._get_feat_extract_output_lengths(raw_sequence_length).item()
>>> mask_time_indices = _compute_mask_indices(
...     shape=(batch_size, sequence_length), mask_prob=0.2, mask_length=2
... )
>>> sampled_negative_indices = _sample_negative_indices(
...     features_shape=(batch_size, sequence_length),
...     num_negatives=model.config.num_negatives,
...     mask_time_indices=mask_time_indices,
... )
>>> mask_time_indices = torch.tensor(data=mask_time_indices, device=input_values.device, dtype=torch.long)
>>> sampled_negative_indices = torch.tensor(
...     data=sampled_negative_indices, device=input_values.device, dtype=torch.long
... )

>>> with torch.no_grad():
...     outputs = model(input_values, mask_time_indices=mask_time_indices)

>>> # compute cosine similarity between predicted (=projected_states) and target (=projected_quantized_states)
>>> cosine_sim = torch.cosine_similarity(outputs.projected_states, outputs.projected_quantized_states, dim=-1)

>>> # show that cosine similarity is much higher than random
>>> cosine_sim[mask_time_indices.to(torch.bool)].mean() > 0.5
tensor(True)

>>> # for contrastive loss training model should be put into train mode
>>> model = model.train()
>>> loss = model(
...     input_values, mask_time_indices=mask_time_indices, sampled_negative_indices=sampled_negative_indices
... ).loss
```
