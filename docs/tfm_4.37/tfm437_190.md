# LongT5

> 原始文本：[`huggingface.co/docs/transformers/v4.37.2/en/model_doc/longt5`](https://huggingface.co/docs/transformers/v4.37.2/en/model_doc/longt5)

## 概述

LongT5 模型是由 Mandy Guo、Joshua Ainslie、David Uthus、Santiago Ontanon、Jianmo Ni、Yun-Hsuan Sung 和 Yinfei Yang 在[LongT5: Efficient Text-To-Text Transformer for Long Sequences](https://arxiv.org/abs/2112.07916)中提出的。它是在文本到文本去噪生成设置中预训练的编码器-解码器变压器。LongT5 模型是 T5 模型的扩展，它可以使用两种不同的高效注意力机制之一——（1）局部注意力，或（2）瞬时全局注意力。

论文摘要如下：

最近的工作表明，要么增加输入长度，要么增加模型大小可以提高基于 Transformer 的神经模型的性能。在本文中，我们提出了一个名为 LongT5 的新模型，通过该模型我们同时探索了扩展输入长度和模型大小的效果。具体来说，我们将长输入变压器（ETC）的注意力思想与摘要预训练（PEGASUS）的预训练策略整合到可扩展的 T5 架构中。结果是一个我们称之为“瞬时全局”（TGlobal）的新注意力机制，模仿了 ETC 的局部/全局注意力机制，但不需要额外的辅助输入。我们能够在几个摘要任务上取得最先进的结果，并在问答任务上胜过原始的 T5 模型。

这个模型是由[stancld](https://huggingface.co/stancld)贡献的。原始代码可以在[这里](https://github.com/google-research/longt5)找到。

## 使用提示

+   LongT5ForConditionalGeneration 是 T5ForConditionalGeneration 的扩展，用高效的“局部”注意力或“瞬时全局”（tglobal）注意力交换传统的编码器“自注意力”层。

+   与 T5 模型不同，LongT5 不使用任务前缀。此外，它使用了受 PegasusForConditionalGeneration 预训练启发的不同预训练目标。

+   LongT5 模型旨在在输入序列超过常用的 512 个标记的长距离序列任务上高效地运行并表现良好。它能够处理长度长达 16,384 个标记的输入序列。

+   对于“局部注意力”，稀疏滑动窗口局部注意力操作允许给定标记仅关注其左右`r`个标记（默认为`r=127`）。“局部注意力”不向模型引入任何新参数。该机制的复杂度与输入序列长度`l`呈线性关系：`O(l*r)`。

+   “瞬时全局注意力”是“局部注意力”的扩展。此外，它允许每个输入标记与该层中的所有其他标记进行交互。这是通过将输入序列分割为固定长度`k`的块（默认为`k=16`）来实现的。然后，通过对该块中每个标记的嵌入进行求和和归一化，获得该块的全局标记。由于这一点，注意力机制允许每个标记既关注像局部注意力中的附近标记，也关注像标准全局注意力中的每个全局标记（“瞬时”表示全局标记在每个注意力操作中动态构建）。因此，“TGlobal”注意力引入了一些新参数——全局相对位置偏差和全局标记嵌入的层归一化。该机制的复杂度为`O(l(r + l/k))`。

+   下面是一个示例，展示了如何在[pubmed 数据集](https://huggingface.co/datasets/scientific_papers)上评估一个经过精调的 LongT5 模型。

```py
>>> import evaluate
>>> from datasets import load_dataset
>>> from transformers import AutoTokenizer, LongT5ForConditionalGeneration

>>> dataset = load_dataset("scientific_papers", "pubmed", split="validation")
>>> model = (
...     LongT5ForConditionalGeneration.from_pretrained("Stancld/longt5-tglobal-large-16384-pubmed-3k_steps")
...     .to("cuda")
...     .half()
... )
>>> tokenizer = AutoTokenizer.from_pretrained("Stancld/longt5-tglobal-large-16384-pubmed-3k_steps")

>>> def generate_answers(batch):
...     inputs_dict = tokenizer(
...         batch["article"], max_length=16384, padding="max_length", truncation=True, return_tensors="pt"
...     )
...     input_ids = inputs_dict.input_ids.to("cuda")
...     attention_mask = inputs_dict.attention_mask.to("cuda")
...     output_ids = model.generate(input_ids, attention_mask=attention_mask, max_length=512, num_beams=2)
...     batch["predicted_abstract"] = tokenizer.batch_decode(output_ids, skip_special_tokens=True)
...     return batch

>>> result = dataset.map(generate_answer, batched=True, batch_size=2)
>>> rouge = evaluate.load("rouge")
>>> rouge.compute(predictions=result["predicted_abstract"], references=result["abstract"])
```

## 资源

+   翻译任务指南

+   摘要任务指南

## LongT5Config

### `class transformers.LongT5Config`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/configuration_longt5.py#L33)

```py
( vocab_size = 32128 d_model = 512 d_kv = 64 d_ff = 2048 num_layers = 6 num_decoder_layers = None num_heads = 8 local_radius = 127 global_block_size = 16 relative_attention_num_buckets = 32 relative_attention_max_distance = 128 dropout_rate = 0.1 layer_norm_epsilon = 1e-06 initializer_factor = 1.0 feed_forward_proj = 'relu' is_encoder_decoder = True encoder_attention_type = 'local' use_cache = True pad_token_id = 0 eos_token_id = 1 **kwargs )
```

参数

+   `vocab_size` (`int`, *optional*, defaults to 32128) — LongT5 模型的词汇量。定义了在调用 LongT5Model 时可以表示的不同标记数量。

+   `d_model` (`int`, *optional*, defaults to 512) — 编码器层和池化层的大小。

+   `d_kv` (`int`, *optional*, defaults to 64) — 每个注意力头的键、查询、值投影的大小。`d_kv`必须等于`d_model // num_heads`。

+   `d_ff` (`int`, *optional*, defaults to 2048) — 每个`LongT5Block`中间级前向层的大小。

+   `num_layers` (`int`, *optional*, defaults to 6) — Transformer 编码器中的隐藏层数量。

+   `num_decoder_layers` (`int`, *optional*) — Transformer 解码器中的隐藏层数量。如果未设置，将使用与`num_layers`相同的值。

+   `num_heads` (`int`, *optional*, defaults to 8) — Transformer 编码器中每个注意力层的注意力头数。

+   `local_radius` (`int`, *optional*, defaults to 127) — 每个标记左/右的标记数，用于在本地注意机制中进行本地自我关注。

+   `global_block_size` (`int`, *optional*, defaults to 16) — 输入序列分成用于全局标记表示的块的长度。仅用于`encoder_attention_type = "transient-global"`。

+   `relative_attention_num_buckets` (`int`, *optional*, defaults to 32) — 每个注意力层使用的桶数量。

+   `relative_attention_max_distance` (`int`, *optional*, defaults to 128) — 用于桶分离的更长序列的最大距离。

+   `dropout_rate` (`float`, *optional*, defaults to 0.1) — 所有 dropout 层的比率。

+   `layer_norm_eps` (`float`, *optional*, defaults to 1e-6) — 层归一化层使用的 epsilon。

+   `initializer_factor` (`float`, *optional*, defaults to 1) — 用于初始化所有权重矩阵的因子（应保持为 1，用于内部初始化测试）。

+   `feed_forward_proj` (`string`, *optional*, defaults to `"relu"`) — 要使用的前向层类型。应该是`"relu"`或`"gated-gelu"`之一。LongT5v1.1 使用`"gated-gelu"`前向投影。原始 LongT5 实现使用`"gated-gelu"`。

+   `encoder_attention_type` (`string`, *optional*, defaults to `"local"`) — 要使用的编码器注意类型。应该是 LongT5 实现支持的`"local"`或`"transient-global"`之一。

+   `use_cache` (`bool`, *optional*, defaults to `True`) — 模型是否应返回最后的键/值注意力（并非所有模型都使用）。

这是配置类，用于存储 LongT5Model 或 FlaxLongT5Model 的配置。根据指定的参数实例化一个 LongT5 模型，定义模型架构。使用默认值实例化配置将产生类似于 LongT5 [google/long-t5-local-base](https://huggingface.co/google/long-t5-local-base)架构的配置。

配置对象继承自 PretrainedConfig，可用于控制模型输出。阅读 PretrainedConfig 的文档以获取更多信息。

PytorchHide Pytorch 内容

## LongT5Model

### `class transformers.LongT5Model`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_longt5.py#L1749)

```py
( config: LongT5Config )
```

参数

+   `config`（LongT5Config）— 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

LONGT5 模型是一个裸的 transformer 模型，输出原始的隐藏状态，没有特定的头部。

LongT5 模型是由 Mandy Guo、Joshua Ainslie、David Uthus、Santiago Ontanon、Jianmo Ni、Yun-Hsuan Sung 和 Yinfei Yang 在[LongT5: Efficient Text-To-Text Transformer for Long Sequences](https://arxiv.org/abs/2112.07916)中提出的。它是一个在文本到文本去噪生成设置中预训练的编码器-解码器 transformer。LongT5 模型是 T5 模型的扩展，它可以使用两种不同的高效注意力机制之一 - (1) 本地注意力，或者(2) 瞬时-全局注意力。

这个模型继承自 PreTrainedModel。查看超类文档以获取库为所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头等）。

这个模型也是一个 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取与一般用法和行为相关的所有内容。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_longt5.py#L1805)

```py
( input_ids: Optional = None attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None past_key_values: Optional = None inputs_embeds: Optional = None decoder_inputs_embeds: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`）— 输入序列标记在词汇表中的索引。LongT5 是一个带有相对位置嵌入的模型，因此您应该能够在右侧和左侧都填充输入。

    可以使用 AutoTokenizer 获取索引。查看 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()获取详细信息。

    什么是输入 ID？

    要了解有关如何为预训练准备`input_ids`的更多信息，请查看长 T5 训练。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`，*可选*）— 避免在填充标记索引上执行注意力的掩码。掩码值选在`[0, 1]`之间：

    +   对于`未屏蔽`的标记，

    +   对于`屏蔽`的标记为 0。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）— 解码器输入序列标记在词汇表中的索引。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。

    什么是解码器输入 ID？

    LONGT5 使用 `pad_token_id` 作为 `decoder_input_ids` 生成的起始标记。如果使用 `past_key_values`，则可以选择仅输入最后的 `decoder_input_ids`（参见 `past_key_values`）。

    要了解有关如何为预训练准备 `decoder_input_ids` 的更多信息，请查看 LONGT5 Training。

+   `decoder_attention_mask`（形状为 `(batch_size, target_sequence_length)` 的 `torch.BoolTensor`，*可选*）- 默认行为：生成一个忽略 `decoder_input_ids` 中填充标记的张量。因果掩码也将默认使用。

+   `head_mask`（形状为 `(num_heads,)` 或 `(num_layers, num_heads)` 的 `torch.FloatTensor`，*可选*）- 用于在编码器中使自注意力模块中选择的头部失效的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示头部未被 `masked`，

    +   0 表示头部被 `masked`。

+   `decoder_head_mask`（形状为 `(num_heads,)` 或 `(num_layers, num_heads)` 的 `torch.FloatTensor`，*可选*）- 用于在解码器中使自注意力模块中选择的头部失效的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示头部未被 `masked`，

    +   0 表示头部被 `masked`。

+   `cross_attn_head_mask`（形状为 `(num_heads,)` 或 `(num_layers, num_heads)` 的 `torch.Tensor`，*可选*）- 用于在解码器中使交叉注意力模块中选择的头部失效的掩码。掩码值在 `[0, 1]` 中选择：

    +   1 表示头部未被 `masked`，

    +   0 表示头部被 `masked`。

+   `encoder_outputs`（`tuple(tuple(torch.FloatTensor)`，*可选*）- 元组包含 (`last_hidden_state`，*可选*：*hidden_states*，*可选*：*attentions*) `last_hidden_state` 的形状为 `(batch_size, sequence_length, hidden_size)`，是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（长度为 `config.n_layers` 的 `tuple(tuple(torch.FloatTensor))`，每个元组有 4 个形状为 `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)` 的张量）- 包含注意力块的预计算键和值隐藏状态。可用于加速解码。

    如果使用 `past_key_values`，用户可以选择仅输入最后的 `decoder_input_ids`（这些没有将它们的过去键值状态提供给此模型）的形状为 `(batch_size, 1)` 的张量，而不是所有形状为 `(batch_size, sequence_length)` 的 `decoder_input_ids`。

+   `inputs_embeds`（形状为 `(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor`，*可选*）- 可选地，您可以选择直接传递嵌入表示而不是传递 `input_ids`。如果您想要更多控制如何将 `input_ids` 索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，这将非常有用。

+   `decoder_inputs_embeds`（形状为 `(batch_size, target_sequence_length, hidden_size)` 的 `torch.FloatTensor`，*可选*）- 可选地，您可以选择直接传递嵌入表示而不是传递 `decoder_input_ids`。如果使用 `past_key_values`，则可以选择仅输入最后的 `decoder_inputs_embeds`（参见 `past_key_values`）。如果您想要更多控制如何将 `decoder_input_ids` 索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，这将非常有用。

    如果未设置 `decoder_input_ids` 和 `decoder_inputs_embeds`，则 `decoder_inputs_embeds` 将取 `inputs_embeds` 的值。

+   `use_cache`（`bool`，*可选*）- 如果设置为 `True`，将返回 `past_key_values` 键值状态，可用于加速解码（参见 `past_key_values`）。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回一个 ModelOutput 而不是一个普通元组。

返回

transformers.modeling_outputs.Seq2SeqModelOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.Seq2SeqModelOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`时）包含根据配置（LongT5Config）和输入的不同元素。

+   `last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`）— 模型解码器最后一层的隐藏状态序列输出。

    如果仅使用`past_key_values`，则输出形状为`(batch_size, 1, hidden_size)`的序列的最后隐藏状态。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）— 长度为`config.n_layers`的`tuple(torch.FloatTensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）— 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则包括嵌入层输出和每层输出）。

    解码器在每一层的隐藏状态以及可选的初始嵌入输出。

+   `decoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）— 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则包括嵌入层输出和每层输出）。

    每层编码器的隐藏状态以及可选的初始嵌入输出。

+   `encoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

LongT5Model 的前向方法覆盖了`__call__`特殊方法。

虽然前向传递的步骤需要在这个函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, LongT5Model

>>> tokenizer = AutoTokenizer.from_pretrained("google/long-t5-local-base")
>>> model = LongT5Model.from_pretrained("google/long-t5-local-base")

>>> # Let's try a very long encoder input.
>>> input_ids = tokenizer(
...     100 * "Studies have been shown that owning a dog is good for you", return_tensors="pt"
... ).input_ids  # Batch size 1

>>> decoder_input_ids = tokenizer("Studies show that", return_tensors="pt").input_ids  # Batch size 1

>>> # forward pass
>>> outputs = model(input_ids=input_ids, decoder_input_ids=decoder_input_ids)
>>> last_hidden_states = outputs.last_hidden_state
```

## LongT5ForConditionalGeneration

### `class transformers.LongT5ForConditionalGeneration`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_longt5.py#L1907)

```py
( config: LongT5Config )
```

参数

+   `config`（LongT5Config）- 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

在顶部带有`语言建模`头的 LONGT5 模型。

LongT5 模型是由 Mandy Guo、Joshua Ainslie、David Uthus、Santiago Ontanon、Jianmo Ni、Yun-Hsuan Sung 和 Yinfei Yang 在[LongT5: Efficient Text-To-Text Transformer for Long Sequences](https://arxiv.org/abs/2112.07916)中提出的。它是一个在文本到文本去噪生成设置中预训练的编码器-解码器 transformer。LongT5 模型是 T5 模型的扩展，它可以使用两种不同的高效注意力机制之一 - (1) 本地注意力，或者(2) 瞬时全局注意力。

这个模型继承自 PreTrainedModel。检查超类文档以获取库为所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头等）。

这个模型也是一个 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_longt5.py#L1962)

```py
( input_ids: Optional = None attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None past_key_values: Optional = None inputs_embeds: Optional = None decoder_inputs_embeds: Optional = None labels: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqLMOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`）- 词汇表中输入序列标记的索引。LongT5 是一个具有相对位置嵌入的模型，因此您应该能够在右侧和左侧都填充输入。

    可以使用 AutoTokenizer 获取索引。详细信息请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    要了解有关如何为预训练准备`input_ids`的更多信息，请查看长 T5 训练。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`，*可选*）- 用于避免在填充标记索引上执行注意力的掩码。掩码值选在`[0, 1]`之间：

    +   对于未被`masked`的标记为 1，

    +   对于被`masked`的标记为 0。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）— 解码器输入序列标记在词汇表中的索引。

    索引可以使用 AutoTokenizer 获得。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    解码器输入 ID 是什么？

    LONGT5 使用`pad_token_id`作为`decoder_input_ids`生成的起始标记。如果使用了`past_key_values`，可以选择只输入最后一个`decoder_input_ids`（参见`past_key_values`）。

    要了解有关如何为预训练准备`decoder_input_ids`的更多信息，请查看 LONGT5 训练。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`torch.BoolTensor`，*可选*）— 默认行为：生成一个忽略`decoder_input_ids`中填充标记的张量。因果掩码也将默认使用。

+   `head_mask`（形状为`(num_heads,)`或`(num_layers, num_heads)`的`torch.FloatTensor`，*可选*）— 用于使编码器中自注意力模块中的选定头部失效的掩码。掩码值选定在`[0, 1]`中：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `decoder_head_mask`（形状为`(num_heads,)`或`(num_layers, num_heads)`的`torch.FloatTensor`，*可选*）— 用于使解码器中自注意力模块中的选定头部失效的掩码。掩码值选定在`[0, 1]`中：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `cross_attn_head_mask`（形状为`(num_heads,)`或`(num_layers, num_heads)`的`torch.Tensor`，*可选*）— 用于使解码器中交叉注意力模块中的选定头部失效的掩码。掩码值选定在`[0, 1]`中：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `encoder_outputs`（`tuple(tuple(torch.FloatTensor)`，*可选*）— 元组包括（`last_hidden_state`，*可选*：*hidden_states*，*可选*：*attentions*）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（长度为`config.n_layers`的`tuple(tuple(torch.FloatTensor))`，每个元组包含形状为`(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`的 4 个张量）— 包含注意力块的预计算键和值隐藏状态。可用于加速解码。

    如果使用了`past_key_values`，用户可以选择只输入最后一个形状为`(batch_size, 1)`的`decoder_input_ids`（那些没有将它们的过去键值状态提供给该模型的）而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

+   `inputs_embeds`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选地，可以直接传递嵌入表示而不是传递`input_ids`。如果您想要更多控制如何将`input_ids`索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，这将非常有用。

+   `decoder_inputs_embeds`（形状为`(batch_size, target_sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选地，可以直接传递嵌入表示而不是传递`decoder_input_ids`。如果使用了`past_key_values`，可以选择只输入最后一个`decoder_inputs_embeds`（参见`past_key_values`）。如果您想要更多控制如何将`decoder_input_ids`索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，这将非常有用。

    如果`decoder_input_ids`和`decoder_inputs_embeds`都未设置，`decoder_inputs_embeds`将取`inputs_embeds`的值。

+   `use_cache`（`bool`，*可选*）— 如果设置为`True`，将返回`past_key_values`键值状态，并可用于加速解码（请参见`past_key_values`）。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回 ModelOutput 而不是普通元组。

+   `labels`（形状为`(batch_size,)`的`torch.LongTensor`，*可选*）— 用于计算序列分类/回归损失的标签。索引应在`[-100, 0, ..., config.vocab_size - 1]`中。所有标签设置为`-100`都将被忽略（掩码），损失仅计算在`[0, ..., config.vocab_size]`中的标签。

返回

transformers.modeling_outputs.Seq2SeqLMOutput 或`torch.FloatTensor`的元组

一个 transformers.modeling_outputs.Seq2SeqLMOutput 或一个`torch.FloatTensor`的元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（LongT5Config）和输入的不同元素。

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，当提供`labels`时返回）— 语言建模损失。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`torch.FloatTensor`）— 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）— 长度为`config.n_layers`的`tuple(torch.FloatTensor)`的元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（请参见`past_key_values`输入）。

+   `decoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）— 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`的元组（如果模型有嵌入层，则为嵌入的输出的一个+每层输出的一个）。

    解码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`的元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`的元组（每层一个）。

    解码器交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`，*可选*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或当`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入的输出+每层的输出）。

    编码器在每一层的隐藏状态以及初始嵌入输出。

+   `encoder_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

LongT5ForConditionalGeneration 的前向方法重写了`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者会处理运行前后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, LongT5ForConditionalGeneration

>>> tokenizer = AutoTokenizer.from_pretrained("Stancld/longt5-tglobal-large-16384-pubmed-3k_steps")
>>> model = LongT5ForConditionalGeneration.from_pretrained(
...     "Stancld/longt5-tglobal-large-16384-pubmed-3k_steps"
... )

>>> # Let's try a very long input.
>>> inputs = tokenizer(100 * "studies have shown that owning a dog is good for you ", return_tensors="pt")
>>> input_ids = inputs.input_ids

>>> outputs = model.generate(input_ids)
>>> print(tokenizer.decode(outputs[0], skip_special_tokens=True))
abstractthe aim of this article is to provide an overview of the literature on the role of dog
```

## LongT5EncoderModel

### `class transformers.LongT5EncoderModel`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_longt5.py#L2156)

```py
( config: LongT5Config )
```

参数

+   `config` (LongT5Config) — 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

裸 LONGT5 模型 transformer 输出编码器的原始隐藏状态，没有特定的头部。

LongT5 模型是由 Mandy Guo、Joshua Ainslie、David Uthus、Santiago Ontanon、Jianmo Ni、Yun-Hsuan Sung 和 Yinfei Yang 在[LongT5: Efficient Text-To-Text Transformer for Long Sequences](https://arxiv.org/abs/2112.07916)中提出的。它是一个在文本到文本去噪生成设置中预训练的编码器-解码器 transformer。LongT5 模型是 T5 模型的扩展，它可以使用两种不同的高效注意机制之一 - (1) 本地注意力，或者(2) 瞬时-全局注意力。

此模型继承自 PreTrainedModel。查看超类文档以了解库为所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头等）。

这个模型也是一个 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_longt5.py#L2198)

```py
( input_ids: Optional = None attention_mask: Optional = None head_mask: Optional = None inputs_embeds: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.BaseModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`torch.LongTensor`，形状为`(batch_size, sequence_length)`) — 输入序列标记在词汇表中的索引。LongT5 是一个带有相对位置嵌入的模型，因此您应该能够在右侧和左侧都填充输入。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。

    要了解有关如何为预训练准备 `input_ids` 的更多信息，请查看 LONGT5 Training。

+   `attention_mask` (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*) — 用于避免在填充标记索引上执行注意力的掩码。掩码值选定在 `[0, 1]`：

    +   1 表示未被掩码的标记，

    +   0 表示被掩码的标记。

    什么是注意力掩码？

+   `head_mask` (`torch.FloatTensor` of shape `(num_heads,)` or `(num_layers, num_heads)`, *optional*) — 用于使自注意力模块中的选定头部失效的掩码。掩码值选定在 `[0, 1]`：

    +   1 表示头部未被掩码，

    +   0 表示头部被掩码。

+   `inputs_embeds` (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*) — 可选地，可以直接传递嵌入表示而不是传递 `input_ids`。如果您想要更多控制如何将 `input_ids` 索引转换为相关向量，则这很有用，而不是使用模型的内部嵌入查找矩阵。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的 `attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的 `hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

返回

transformers.modeling_outputs.BaseModelOutput 或 `tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.BaseModelOutput 或一个 `torch.FloatTensor` 元组（如果传递 `return_dict=False` 或 `config.return_dict=False`）包含各种元素，具体取决于配置（LongT5Config）和输入。

+   `last_hidden_state` (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`) — 模型最后一层的隐藏状态序列输出。

+   `hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递 `output_hidden_states=True` 或 `config.output_hidden_states=True` 时返回) — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor` 元组。

    模型在每一层输出的隐藏状态以及可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递 `output_attentions=True` 或 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组。

    在自注意力头中用于计算加权平均值的注意力 softmax 后的注意力权重。

LongT5EncoderModel 的前向方法，覆盖了 `__call__` 特殊方法。

虽然前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者会负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, LongT5ForConditionalGeneration

>>> tokenizer = AutoTokenizer.from_pretrained("google/long-t5-local-base")
>>> model = LongT5EncoderModel.from_pretrained("google/long-t5-local-base")
>>> input_ids = tokenizer(
...     100 * "Studies have been shown that owning a dog is good for you ", return_tensors="pt"
... ).input_ids  # Batch size 1
>>> outputs = model(input_ids=input_ids)
>>> last_hidden_states = outputs.last_hidden_state
```

JAXHide JAX content

## FlaxLongT5Model

### `class transformers.FlaxLongT5Model`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_flax_longt5.py#L2108)

```py
( config: LongT5Config input_shape: Tuple = (1, 1) seed: int = 0 dtype: dtype = <class 'jax.numpy.float32'> _do_init: bool = True **kwargs )
```

#### `__call__`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_flax_longt5.py#L1724)

```py
( input_ids: Array attention_mask: Optional = None decoder_input_ids: Array = None decoder_attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size, sequence_length)`的`jnp.ndarray`）- 词汇表中输入序列令牌的索引。LongT5 是一个具有相对位置嵌入的模型，因此您应该能够在右侧和左侧填充输入。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    要了解有关如何为预训练准备`input_ids`的更多信息，请查看长 T5 训练。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`jnp.ndarray`，*可选*）- 用于避免在填充令牌索引上执行注意力的掩码。掩码值选在`[0, 1]`之间：

    +   对于未被`masked`的令牌为 1。

    +   对于被`masked`的令牌为 0。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`jnp.ndarray`，*可选*）- 词汇表中解码器输入序列令牌的索引。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是解码器输入 ID？

    LONGT5 使用`pad_token_id`作为`decoder_input_ids`生成的起始令牌。如果使用了`past_key_values`，可以选择仅输入最后一个`decoder_input_ids`（参见`past_key_values`）。

    要了解有关如何为预训练准备`decoder_input_ids`的更多信息，请查看长 T5 训练。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`jnp.ndarray`，*可选*）- 默认行为：生成一个张量，忽略`decoder_input_ids`中的填充令牌。因果掩码也将默认使用。

+   `encoder_outputs`（`tuple(tuple(jnp.ndarray)`，*可选*）- 元组包含（`last_hidden_state`，*可选*：*hidden_states*，*可选*：*attentions*）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（长度为`config.n_layers`的`tuple(tuple(jnp.ndarray))`，每个元组包含 4 个形状为`(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`的张量）- 包含注意力块的预计算键和值隐藏状态。可用于加速解码。

    如果使用了`past_key_values`，用户可以选择仅输入最后一个`decoder_input_ids`（那些没有将它们的过去键值状态提供给此模型的）的形状为`(batch_size, 1)`，而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

返回

transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput 或`tuple(torch.FloatTensor)`

transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（LongT5Config）和输入的不同元素。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`jnp.ndarray`） — 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values`（`tuple(tuple(jnp.ndarray))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回） — 长度为`config.n_layers`的`tuple(jnp.ndarray)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可以用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states`（`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入的输出，一个用于每一层的输出）。

    解码器在每一层的隐藏状态加上初始嵌入输出。

+   `decoder_attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`，*可选*） — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入的输出，一个用于每一层的输出）。

    编码器在每一层的隐藏状态加上初始嵌入输出。

+   `encoder_attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

`FlaxLongT5PreTrainedModel`的前向方法，覆盖了`__call__`特殊方法。

尽管前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者会处理运行前后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, FlaxLongT5Model

>>> tokenizer = AutoTokenizer.from_pretrained("t5-base")
>>> model = FlaxLongT5Model.from_pretrained("google/long-t5-local-base")

>>> input_ids = tokenizer(
...     "Studies have been shown that owning a dog is good for you", return_tensors="np"
... ).input_ids
>>> decoder_input_ids = tokenizer("Studies show that", return_tensors="np").input_ids

>>> # forward pass
>>> outputs = model(input_ids=input_ids, decoder_input_ids=decoder_input_ids)
>>> last_hidden_states = outputs.last_hidden_state
```

#### `encode`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_flax_longt5.py#L1810)

```py
( input_ids: Array attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxBaseModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`jnp.ndarray`，形状为`(batch_size, sequence_length)`) — 词汇表中输入序列标记的索引。LongT5 是一个具有相对位置嵌入的模型，因此您应该能够在右侧和左侧都填充输入。

    可以使用 AutoTokenizer 获取索引。查看 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()获取详细信息。

    要了解如何为预训练准备`input_ids`，请查看长 T5 训练。

+   `attention_mask` (`jnp.ndarray`，形状为`(batch_size, sequence_length)`，*可选*) — 用于避免在填充标记索引上执行注意力的掩码。掩码值选择在`[0, 1]`之间：

    +   对于未被`masked`的标记为 1，

    +   对于被`masked`的标记为 0。

    什么是注意力掩码？

+   `output_attentions` (`bool`，*可选*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请查看返回张量下的`attentions`。

+   `output_hidden_states` (`bool`，*可选*) — 是否返回所有层的隐藏状态。有关更多详细信息，请查看返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *可选*) — 是否返回一个 ModelOutput 而不是一个普通的元组。

返回

transformers.modeling_flax_outputs.FlaxBaseModelOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_flax_outputs.FlaxBaseModelOutput 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`）包含根据配置（`<class 'transformers.models.longt5.configuration_longt5.LongT5Config'>`）和输入而异的各种元素。

+   `last_hidden_state` (`jnp.ndarray`，形状为`(batch_size, sequence_length, hidden_size)`) — 模型最后一层的隐藏状态序列输出。

+   `hidden_states` (`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入输出，一个用于每一层的输出）。

    模型在每一层输出的隐藏状态以及初始嵌入输出。

+   `attentions` (`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    注意力 softmax 后的注意力权重，用于计算自注意力头中的加权平均值。

示例：

```py
>>> from transformers import AutoTokenizer, FlaxLongT5ForConditionalGeneration

>>> tokenizer = AutoTokenizer.from_pretrained("t5-base")
>>> model = FlaxLongT5ForConditionalGeneration.from_pretrained("google/long-t5-local-base")

>>> text = "My friends are cool but they eat too many carbs."
>>> inputs = tokenizer(text, return_tensors="np")
>>> encoder_outputs = model.encode(**inputs)
```

#### `decode`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_flax_longt5.py#L1868)

```py
( decoder_input_ids encoder_outputs encoder_attention_mask: Optional = None decoder_attention_mask: Optional = None past_key_values: dict = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxBaseModelOutputWithPastAndCrossAttentions or tuple(torch.FloatTensor)
```

参数

+   `decoder_input_ids` (`jnp.ndarray`，形状为`(batch_size, target_sequence_length)`) — 词汇表中解码器输入序列标记的索引。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是解码器输入 ID？

    在训练中，应提供`decoder_input_ids`。

+   `encoder_outputs` (`tuple(tuple(jnp.ndarray)`) — 元组包括(`last_hidden_state`，*optional*：`hidden_states`，*optional*：`attentions`) `last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*optional*)是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `encoder_attention_mask` (`jnp.ndarray`，形状为`(batch_size, sequence_length)`，*optional*) — 避免在填充标记索引上执行注意力的掩码。选择的掩码值为`[0, 1]`：

    +   对于未被掩码的标记，为 1，

    +   对于被掩码的标记为 0。

    什么是注意力掩码？

+   `decoder_attention_mask` (`jnp.ndarray`，形状为`(batch_size, target_sequence_length)`，*optional*) — 默认行为：生成一个忽略`decoder_input_ids`中填充标记的张量。默认情况下还将使用因果掩码。

    如果要更改填充行为，应根据需要进行修改。有关默认策略的更多信息，请参见[论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `past_key_values` (`Dict[str, np.ndarray]`，*optional*，由`init_cache`返回或传递先前的`past_key_values`时返回） — 预先计算的隐藏状态字典（注意力块中的键和值），可用于快速自回归解码。预先计算的键和值隐藏状态的形状为*[batch_size, max_length]*。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

返回

transformers.modeling_flax_outputs.FlaxBaseModelOutputWithPastAndCrossAttentions 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_flax_outputs.FlaxBaseModelOutputWithPastAndCrossAttentions 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（`<class 'transformers.models.longt5.configuration_longt5.LongT5Config'>`）和输入的不同元素。

+   `last_hidden_state` (`jnp.ndarray`，形状为`(batch_size, sequence_length, hidden_size)`) — 模型最后一层的隐藏状态序列。

    如果仅使用`past_key_values`，则输出形状为`(batch_size, 1, hidden_size)`的序列的最后隐藏状态。

+   `past_key_values` (`tuple(tuple(jnp.ndarray))`, *optional*, 当传递`use_cache=True`或`config.use_cache=True`时返回 — 长度为`config.n_layers`的元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量，如果`config.is_encoder_decoder=True`，还有 2 个形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块中的键和值，以及在交叉注意力块中，如果`config.is_encoder_decoder=True`，可以使用（查看`past_key_values`输入）来加速顺序解码。

+   `hidden_states`（`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或传递`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入的输出，一个用于每个层的输出）。

    模型在每一层输出的隐藏状态以及初始嵌入输出。

+   `attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或传递`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    在注意力 softmax 之后的注意力权重，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`和`config.add_cross_attention=True`或传递`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

示例：

```py
>>> from transformers import AutoTokenizer, FlaxLongT5ForConditionalGeneration
>>> import jax.numpy as jnp

>>> tokenizer = AutoTokenizer.from_pretrained("t5-base")
>>> model = FlaxLongT5ForConditionalGeneration.from_pretrained("google/long-t5-local-base")

>>> text = "My friends are cool but they eat too many carbs."
>>> inputs = tokenizer(text, return_tensors="np")
>>> encoder_outputs = model.encode(**inputs)

>>> decoder_start_token_id = model.config.decoder_start_token_id
>>> decoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype="i4") * decoder_start_token_id

>>> outputs = model.decode(decoder_input_ids, encoder_outputs)
>>> logits = outputs.logits
```

## FlaxLongT5ForConditionalGeneration

### `class transformers.FlaxLongT5ForConditionalGeneration`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_flax_longt5.py#L2253)

```py
( config: LongT5Config input_shape: Tuple = (1, 1) seed: int = 0 dtype: dtype = <class 'jax.numpy.float32'> _do_init: bool = True **kwargs )
```

#### `__call__`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_flax_longt5.py#L1724)

```py
( input_ids: Array attention_mask: Optional = None decoder_input_ids: Array = None decoder_attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size, sequence_length)`的`jnp.ndarray`）- 词汇表中输入序列标记的索引。LongT5 是一个具有相对位置嵌入的模型，因此您应该能够在右侧和左侧都填充输入。

    可以使用 AutoTokenizer 获取索引。详细信息请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    了解如何为预训练准备`input_ids`，请查看 LONGT5 Training。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`jnp.ndarray`，*可选*）- 用于避免在填充标记索引上执行注意力的掩码。掩码值选在`[0, 1]`之间：

    +   对于未被`masked`的标记，值为 1。

    +   对于被`masked`的标记，值为 0。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`jnp.ndarray`，*可选*）- 词汇表中解码器输入序列标记的索引。

    可以使用 AutoTokenizer 获取索引。详细信息请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是解码器输入 ID？

    LONGT5 使用`pad_token_id`作为`decoder_input_ids`生成的起始标记。如果使用了`past_key_values`，可选择只需输入最后的`decoder_input_ids`（查看`past_key_values`）。

    了解如何为预训练准备`decoder_input_ids`，请查看 LONGT5 Training。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`jnp.ndarray`，*可选*）- 默认行为：生成一个忽略`decoder_input_ids`中填充标记的张量。因果膜也将默认使用。

+   `encoder_outputs`（`tuple(tuple(jnp.ndarray)`，*可选*）- 元组包括（`last_hidden_state`，*可选*：*hidden_states*，*可选*：*attentions*）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（长度为`config.n_layers`的`tuple(tuple(jnp.ndarray))`，每个元组有 4 个形状为`(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`的张量）- 包含注意力块的预先计算的键和值隐藏状态。可用于加速解码。

    如果使用了`past_key_values`，用户可以选择性地只输入最后一个形状为`(batch_size, 1)`的`decoder_input_ids`（那些没有将它们的过去键值状态提供给该模型的输入），而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

返回

transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput 或`tuple(torch.FloatTensor)`

transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`时）包括根据配置（LongT5Config）和输入的不同元素。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`jnp.ndarray`）- 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values`（`tuple(tuple(jnp.ndarray))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）- 长度为`config.n_layers`的元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值）可以用（参见`past_key_values`输入）加速顺序解码。

+   `decoder_hidden_states`（`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 元组包括（嵌入输出的输出+每层输出的输出）的`jnp.ndarray`（每层一个）的形状为`(batch_size, sequence_length, hidden_size)`。

    解码器在每一层输出的隐藏状态以及初始嵌入输出。

+   `decoder_attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`，*可选*）- 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或者当`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入输出，一个用于每一层的输出）。

    编码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或者当`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

`FlaxLongT5PreTrainedModel`的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, FlaxLongT5ForConditionalGeneration

>>> tokenizer = AutoTokenizer.from_pretrained("t5-base")
>>> model = FlaxLongT5ForConditionalGeneration.from_pretrained("google/long-t5-local-base")

>>> ARTICLE_TO_SUMMARIZE = "summarize: My friends are cool but they eat too many carbs."
>>> inputs = tokenizer([ARTICLE_TO_SUMMARIZE], return_tensors="np")

>>> # Generate Summary
>>> summary_ids = model.generate(inputs["input_ids"]).sequences
>>> print(tokenizer.decode(summary_ids[0], skip_special_tokens=True, clean_up_tokenization_spaces=False))
```

#### `encode`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_flax_longt5.py#L1810)

```py
( input_ids: Array attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxBaseModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size, sequence_length)`的`jnp.ndarray`） — 词汇表中输入序列标记的索引。LongT5 是一个带有相对位置嵌入的模型，因此您应该能够在右侧和左侧都填充输入。

    可以使用 AutoTokenizer 获取索引。查看 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()获取详细信息。

    要了解有关如何为预训练准备`input_ids`的更多信息，请查看长 T5 训练。

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`jnp.ndarray`，*可选*） — 避免在填充标记索引上执行注意力的掩码。掩码值选择在`[0, 1]`范围内：

    +   对于`未被掩码`的标记为 1，

    +   对于`被掩码`的标记为 0。

    什么是注意力掩码？

+   `output_attentions`（`bool`，*可选*） — 是否返回所有注意力层的注意力张量。有关更多详细信息，请查看返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*） — 是否返回所有层的隐藏状态。有关更多详细信息，请查看返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*） — 是否返回一个 ModelOutput 而不是一个普通元组。

返回

transformers.modeling_flax_outputs.FlaxBaseModelOutput 或者`tuple(torch.FloatTensor)`

一个 transformers.modeling_flax_outputs.FlaxBaseModelOutput 或者一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或者当`config.return_dict=False`时）包括各种元素，取决于配置（`<class 'transformers.models.longt5.configuration_longt5.LongT5Config'>`）和输入。

+   `last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`） — 模型最后一层的隐藏状态序列。

+   `hidden_states`（`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或者当`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入输出，一个用于每一层的输出）。

    模型每一层的隐藏状态加上初始嵌入输出。

+   `attentions` (`tuple(jnp.ndarray)`, *optional*, 当传递 `output_attentions=True` 或者 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `jnp.ndarray` 元组（每层一个）。

    注意力 softmax 后的注意力权重，用于计算自注意力头中的加权平均值。

示例：

```py
>>> from transformers import AutoTokenizer, FlaxLongT5ForConditionalGeneration

>>> tokenizer = AutoTokenizer.from_pretrained("t5-base")
>>> model = FlaxLongT5ForConditionalGeneration.from_pretrained("google/long-t5-local-base")

>>> text = "My friends are cool but they eat too many carbs."
>>> inputs = tokenizer(text, return_tensors="np")
>>> encoder_outputs = model.encode(**inputs)
```

#### `decode`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/longt5/modeling_flax_longt5.py#L2256)

```py
( decoder_input_ids encoder_outputs encoder_attention_mask: Optional = None decoder_attention_mask: Optional = None past_key_values: dict = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxCausalLMOutputWithCrossAttentions or tuple(torch.FloatTensor)
```

参数

+   `decoder_input_ids` (`jnp.ndarray` 形状为 `(batch_size, target_sequence_length)`) — 词汇表中解码器输入序列标记的索引。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。

    什么是解码器输入 ID？

    对于训练，应提供 `decoder_input_ids`。

+   `encoder_outputs` (`tuple(tuple(jnp.ndarray)`) — 元组包括 (`last_hidden_state`, *optional*: `hidden_states`, *optional*: `attentions`) `last_hidden_state` 的形状为 `(batch_size, sequence_length, hidden_size)`，*optional*) 是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `encoder_attention_mask` (`jnp.ndarray` 形状为 `(batch_size, sequence_length)`，*optional*) — 避免在填充标记索引上执行注意力的掩码。掩码值选在 `[0, 1]`：

    +   1 代表 `未被掩码` 的标记，

    +   0 代表 `被掩码` 的标记。

    什么是注意力掩码？

+   `decoder_attention_mask` (`jnp.ndarray` 形状为 `(batch_size, target_sequence_length)`，*optional*) — 默认行为：生成一个忽略 `decoder_input_ids` 中填充标记的张量。因果掩码也将默认使用。

    如果要更改填充行为，应根据需要进行修改。有关默认策略的更多信息，请参见 [论文](https://arxiv.org/abs/1910.13461) 中的图表 1。

+   `past_key_values` (`Dict[str, np.ndarray]`, *optional*, 由 `init_cache` 返回或传递先前的 `past_key_values` 时返回) — 预先计算的隐藏状态字典（注意力块中的键和值），可用于快速自回归解码。预先计算的键和值隐藏状态的形状为 *[batch_size, max_length]*。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量中的 `attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量中的 `hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

返回

transformers.modeling_flax_outputs.FlaxCausalLMOutputWithCrossAttentions 或 `tuple(torch.FloatTensor)`

一个 transformers.modeling_flax_outputs.FlaxCausalLMOutputWithCrossAttentions 或一个 `torch.FloatTensor` 元组（如果传递 `return_dict=False` 或者 `config.return_dict=False`）包含根据配置 (`<class 'transformers.models.longt5.configuration_longt5.LongT5Config'>`) 和输入的各种元素。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`jnp.ndarray`）- 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `hidden_states`（`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入的输出，一个用于每个层的输出）。

    模型在每一层输出的隐藏状态以及初始嵌入输出。

+   `attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    在自注意力头中用于计算加权平均的注意力权重 softmax 后的值。

+   `cross_attentions`（`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    在交叉注意力头中用于计算加权平均的注意力权重 softmax 后的值。

+   `past_key_values`（`tuple(tuple(jnp.ndarray))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）- 长度为`config.n_layers`的`jnp.ndarray`元组的元组，每个元组包含自注意力和交叉注意力层的缓存键、值状态，如果模型在编码器-解码器设置中使用，则相关。仅在`config.is_decoder = True`时相关。

    包含预先计算的隐藏状态（注意力块中的键和值），可用于加速顺序解码。

示例：

```py
>>> from transformers import AutoTokenizer, FlaxLongT5ForConditionalGeneration
>>> import jax.numpy as jnp

>>> tokenizer = AutoTokenizer.from_pretrained("t5-base")
>>> model = FlaxLongT5ForConditionalGeneration.from_pretrained("google/long-t5-local-base")

>>> text = "summarize: My friends are cool but they eat too many carbs."
>>> inputs = tokenizer(text, return_tensors="np")
>>> encoder_outputs = model.encode(**inputs)

>>> decoder_start_token_id = model.config.decoder_start_token_id
>>> decoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype="i4") * decoder_start_token_id

>>> outputs = model.decode(decoder_input_ids, encoder_outputs)
>>> logits = outputs.logits
```
