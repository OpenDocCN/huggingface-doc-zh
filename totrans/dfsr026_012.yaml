- en: Accelerate inference of text-to-image diffusion models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://huggingface.co/docs/diffusers/tutorials/fast_diffusion](https://huggingface.co/docs/diffusers/tutorials/fast_diffusion)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link href="/docs/diffusers/v0.26.3/en/_app/immutable/assets/0.e3b0c442.css"
    rel="modulepreload"> <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/entry/start.99629b4a.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/scheduler.182ea377.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/singletons.fade7992.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/index.1f6d62f6.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/paths.108a236d.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/entry/app.2b3eaeb0.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/index.abf12888.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/nodes/0.3862a335.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/each.e59479a4.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/nodes/154.959bff20.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/Tip.230e2334.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/CodeBlock.57fe6e13.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/Heading.16916d63.js">
  prefs: []
  type: TYPE_NORMAL
- en: Diffusion models are slower than their GAN counterparts because of the iterative
    and sequential reverse diffusion process. There are several techniques that can
    address this limitation such as progressive timestep distillation ([LCM LoRA](../using-diffusers/inference_with_lcm_lora)),
    model compression ([SSD-1B](https://huggingface.co/segmind/SSD-1B)), and reusing
    adjacent features of the denoiser ([DeepCache](../optimization/deepcache)).
  prefs: []
  type: TYPE_NORMAL
- en: However, you don’t necessarily need to use these techniques to speed up inference.
    With PyTorch 2 alone, you can accelerate the inference latency of text-to-image
    diffusion pipelines by up to 3x. This tutorial will show you how to progressively
    apply the optimizations found in PyTorch 2 to reduce inference latency. You’ll
    use the [Stable Diffusion XL (SDXL)](../using-diffusers/sdxl) pipeline in this
    tutorial, but these techniques are applicable to other text-to-image diffusion
    pipelines too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you’re using the latest version of Diffusers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then upgrade the other required libraries too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Install [PyTorch nightly](https://pytorch.org/) to benefit from the latest
    and fastest kernels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The results reported below are from a 80GB 400W A100 with its clock rate set
    to the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in the full benchmarking code, take a look at [huggingface/diffusion-fast](https://github.com/huggingface/diffusion-fast).
  prefs: []
  type: TYPE_NORMAL
- en: Baseline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a baseline. Disable reduced precision and the [`scaled_dot_product_attention`
    (SDPA)](../optimization/torch2.0#scaled-dot-product-attention) function which
    is automatically used by Diffusers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This default setup takes 7.36 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/584efcadbeb310692fb90a60e06360d2.png)'
  prefs: []
  type: TYPE_IMG
- en: bfloat16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enable the first optimization, reduced precision or more specifically bfloat16\.
    There are several benefits of using reduced precision:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a reduced numerical precision (such as float16 or bfloat16) for inference
    doesn’t affect the generation quality but significantly improves latency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of using bfloat16 compared to float16 are hardware dependent, but
    modern GPUs tend to favor bfloat16.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bfloat16 is much more resilient when used with quantization compared to float16,
    but more recent versions of the quantization library ([torchao](https://github.com/pytorch-labs/ao))
    we used don’t have numerical issues with float16.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: bfloat16 reduces the latency from 7.36 seconds to 4.63 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/831463c6351d9fc036c263c31b10cd4b.png)'
  prefs: []
  type: TYPE_IMG
- en: In our later experiments with float16, recent versions of torchao do not incur
    numerical problems from float16.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the [Speed up inference](../optimization/fp16) guide to learn
    more about running inference with reduced precision.
  prefs: []
  type: TYPE_NORMAL
- en: SDPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attention blocks are intensive to run. But with PyTorch’s [`scaled_dot_product_attention`](../optimization/torch2.0#scaled-dot-product-attention)
    function, it is a lot more efficient. This function is used by default in Diffusers
    so you don’t need to make any changes to the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Scaled dot product attention improves the latency from 4.63 seconds to 3.31
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/01dcfc49da5fef775ed409609c41b519.png)'
  prefs: []
  type: TYPE_IMG
- en: torch.compile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PyTorch 2 includes `torch.compile` which uses fast and optimized kernels. In
    Diffusers, the UNet and VAE are usually compiled because these are the most compute-intensive
    modules. First, configure a few compiler flags (refer to the [full list](https://github.com/pytorch/pytorch/blob/main/torch/_inductor/config.py)
    for more options):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is also important to change the UNet and VAE’s memory layout to “channels_last”
    when compiling them to ensure maximum speed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compile and perform inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`torch.compile` offers different backends and modes. For maximum inference
    speed, use “max-autotune” for the inductor backend. “max-autotune” uses CUDA graphs
    and optimizes the compilation graph specifically for latency. CUDA graphs greatly
    reduces the overhead of launching GPU operations by using a mechanism to launch
    multiple GPU operations through a single CPU operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Using SDPA attention and compiling both the UNet and VAE cuts the latency from
    3.31 seconds to 2.54 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4c34eff89c0a052eb3a44e922e8075c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Prevent graph breaks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifying `fullgraph=True` ensures there are no graph breaks in the underlying
    model to take full advantage of `torch.compile` without any performance degradation.
    For the UNet and VAE, this means changing how you access the return variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remove GPU sync after compilation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the iterative reverse diffusion process, the `step()` function is [called](https://github.com/huggingface/diffusers/blob/1d686bac8146037e97f3fd8c56e4063230f71751/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L1228)
    on the scheduler each time after the denoiser predicts the less noisy latent embeddings.
    Inside `step()`, the `sigmas` variable is [indexed](https://github.com/huggingface/diffusers/blob/1d686bac8146037e97f3fd8c56e4063230f71751/src/diffusers/schedulers/scheduling_euler_discrete.py#L476)
    which when placed on the GPU, causes a communication sync between the CPU and
    GPU. This introduces latency and it becomes more evident when the denoiser has
    already been compiled.
  prefs: []
  type: TYPE_NORMAL
- en: But if the `sigmas` array always [stays on the CPU](https://github.com/huggingface/diffusers/blob/35a969d297cba69110d175ee79c59312b9f49e1e/src/diffusers/schedulers/scheduling_euler_discrete.py#L240),
    the CPU and GPU sync doesn’t occur and you don’t get any latency. In general,
    any CPU and GPU communication sync should be none or be kept to a bare minimum
    because it can impact inference latency.
  prefs: []
  type: TYPE_NORMAL
- en: Combine the attention block’s projection matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UNet and VAE in SDXL use Transformer-like blocks which consists of attention
    blocks and feed-forward blocks.
  prefs: []
  type: TYPE_NORMAL
- en: In an attention block, the input is projected into three sub-spaces using three
    different projection matrices – Q, K, and V. These projections are performed separately
    on the input. But we can horizontally combine the projection matrices into a single
    matrix and perform the projection in one step. This increases the size of the
    matrix multiplications of the input projections and improves the impact of quantization.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine the projection matrices with just a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This provides a minor improvement from 2.54 seconds to 2.52 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe24b44eafbe3b39c1b11f09cd41d343.png)'
  prefs: []
  type: TYPE_IMG
- en: Support for [fuse_qkv_projections()](/docs/diffusers/v0.26.3/en/api/pipelines/stable_diffusion/stable_diffusion_xl#diffusers.StableDiffusionXLPipeline.fuse_qkv_projections)
    is limited and experimental. It’s not available for many non-Stable Diffusion
    pipelines such as [Kandinsky](../using-diffusers/kandinsky). You can refer to
    this [PR](https://github.com/huggingface/diffusers/pull/6179) to get an idea about
    how to enable this for the other pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic quantization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also use the ultra-lightweight PyTorch quantization library, [torchao](https://github.com/pytorch-labs/ao)
    (commit SHA `54bcd5a10d0abbe7b0c045052029257099f83fd9`), to apply [dynamic int8
    quantization](https://pytorch.org/tutorials/recipes/recipes/dynamic_quantization.html)
    to the UNet and VAE. Quantization adds additional conversion overhead to the model
    that is hopefully made up for by faster matmuls (dynamic quantization). If the
    matmuls are too small, these techniques may degrade performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, configure all the compiler tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Certain linear layers in the UNet and VAE don’t benefit from dynamic int8 quantization.
    You can filter out those layers with the [`dynamic_quant_filter_fn`](https://github.com/huggingface/diffusion-fast/blob/0f169640b1db106fe6a479f78c1ed3bfaeba3386/utils/pipeline_utils.py#L16)
    shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, apply all the optimizations discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since dynamic quantization is only limited to the linear layers, convert the
    appropriate pointwise convolution layers into linear layers to maximize its benefit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply dynamic quantization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, compile and perform inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Applying dynamic quantization improves the latency from 2.52 seconds to 2.43
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7e2e919818cd16899daafab4ae5ab1ea.png)'
  prefs: []
  type: TYPE_IMG
