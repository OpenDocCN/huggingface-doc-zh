["```py\nnpx create-next-app@latest\n```", "```py\n\u221a What is your project named? ... next\n\u221a Would you like to use TypeScript? ... No / Yes\n\u221a Would you like to use ESLint? ... No / Yes\n\u221a Would you like to use Tailwind CSS? ... No / Yes\n\u221a Would you like to use `src/` directory? ... No / Yes\n\u221a Would you like to use App Router? (recommended) ... No / Yes\n\u221a Would you like to customize the default import alias? ... No / Yes\n\n```", "```py\nnpm i @xenova/transformers\n```", "```py\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n    // (Optional) Export as a static site\n    // See https://nextjs.org/docs/pages/building-your-application/deploying/static-exports#configuration\n    output: 'export', // Feel free to modify/remove this option\n\n    // Override the default webpack configuration\n    webpack: (config) => {\n        // See https://webpack.js.org/configuration/resolve/#resolvealias\n        config.resolve.alias = {\n            ...config.resolve.alias,\n            \"sharp$\": false,\n            \"onnxruntime-node$\": false,\n        }\n        return config;\n    },\n}\n\nmodule.exports = nextConfig\n```", "```py\nimport { pipeline, env } from \"@xenova/transformers\";\n\n// Skip local model check\nenv.allowLocalModels = false;\n\n// Use the Singleton pattern to enable lazy construction of the pipeline.\nclass PipelineSingleton {\n    static task = 'text-classification';\n    static model = 'Xenova/distilbert-base-uncased-finetuned-sst-2-english';\n    static instance = null;\n\n    static async getInstance(progress_callback = null) {\n        if (this.instance === null) {\n            this.instance = pipeline(this.task, this.model, { progress_callback });\n        }\n        return this.instance;\n    }\n}\n\n// Listen for messages from the main thread\nself.addEventListener('message', async (event) => {\n    // Retrieve the classification pipeline. When called for the first time,\n    // this will load the pipeline and save it for future use.\n    let classifier = await PipelineSingleton.getInstance(x => {\n        // We also add a progress callback to the pipeline so that we can\n        // track model loading.\n        self.postMessage(x);\n    });\n\n    // Actually perform the classification\n    let output = await classifier(event.data.text);\n\n    // Send the output back to the main thread\n    self.postMessage({\n        status: 'complete',\n        output: output,\n    });\n});\n\n```", "```py\n'use client'\n\nimport { useState, useEffect, useRef, useCallback } from 'react'\n\nexport default function Home() {\n  /* TODO: Add state variables */\n\n  // Create a reference to the worker object.\n  const worker = useRef(null);\n\n  // We use the `useEffect` hook to set up the worker as soon as the `App` component is mounted.\n  useEffect(() => {\n    if (!worker.current) {\n      // Create the worker if it does not yet exist.\n      worker.current = new Worker(new URL('./worker.js', import.meta.url), {\n        type: 'module'\n      });\n    }\n\n    // Create a callback function for messages from the worker thread.\n    const onMessageReceived = (e) => { /* TODO: See below */};\n\n    // Attach the callback function as an event listener.\n    worker.current.addEventListener('message', onMessageReceived);\n\n    // Define a cleanup function for when the component is unmounted.\n    return () => worker.current.removeEventListener('message', onMessageReceived);\n  });\n\n  const classify = useCallback((text) => {\n    if (worker.current) {\n      worker.current.postMessage({ text });\n    }\n  }, []);\n\n  return ( /* TODO: See below */ )\n}\n```", "```py\n// Keep track of the classification result and the model loading status.\nconst [result, setResult] = useState(null);\nconst [ready, setReady] = useState(null);\n```", "```py\nconst onMessageReceived = (e) => {\n  switch (e.data.status) {\n    case 'initiate':\n      setReady(false);\n      break;\n    case 'ready':\n      setReady(true);\n      break;\n    case 'complete':\n      setResult(e.data.output[0])\n      break;\n  }\n};\n```", "```py\n<main className=\"flex min-h-screen flex-col items-center justify-center p-12\">\n  <h1 className=\"text-5xl font-bold mb-2 text-center\">Transformers.js</h1>\n  <h2 className=\"text-2xl mb-4 text-center\">Next.js template</h2>\n\n  <input\n    className=\"w-full max-w-xs p-2 border border-gray-300 rounded mb-4\"\n    type=\"text\"\n    placeholder=\"Enter text here\"\n    onInput={e => {\n        classify(e.target.value);\n    }}\n  />\n\n  {ready !== null && (\n    <pre className=\"bg-gray-100 p-2 rounded\">\n      { (!ready || !result) ? 'Loading...' : JSON.stringify(result, null, 2) }\n    </pre>\n  )}\n</main>\n```", "```py\nnpm run dev\n```", "```py\nnpm run build\n```", "```py\nnpx create-next-app@latest\n```", "```py\n\u221a What is your project named? ... next\n\u221a Would you like to use TypeScript? ... No / Yes\n\u221a Would you like to use ESLint? ... No / Yes\n\u221a Would you like to use Tailwind CSS? ... No / Yes\n\u221a Would you like to use `src/` directory? ... No / Yes\n\u221a Would you like to use App Router? (recommended) ... No / Yes\n\u221a Would you like to customize the default import alias? ... No / Yes\n\n```", "```py\nnpm i @xenova/transformers\n```", "```py\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n    // (Optional) Export as a standalone site\n    // See https://nextjs.org/docs/pages/api-reference/next-config-js/output#automatically-copying-traced-files\n    output: 'standalone', // Feel free to modify/remove this option\n\n    // Indicate that these packages should not be bundled by webpack\n    experimental: {\n        serverComponentsExternalPackages: ['sharp', 'onnxruntime-node'],\n    },\n};\n\nmodule.exports = nextConfig\n```", "```py\n    import { pipeline } from \"@xenova/transformers\";\n\n    // Use the Singleton pattern to enable lazy construction of the pipeline.\n    // NOTE: We wrap the class in a function to prevent code duplication (see below).\n    const P = () => class PipelineSingleton {\n        static task = 'text-classification';\n        static model = 'Xenova/distilbert-base-uncased-finetuned-sst-2-english';\n        static instance = null;\n\n        static async getInstance(progress_callback = null) {\n            if (this.instance === null) {\n                this.instance = pipeline(this.task, this.model, { progress_callback });\n            }\n            return this.instance;\n        }\n    }\n\n    let PipelineSingleton;\n    if (process.env.NODE_ENV !== 'production') {\n        // When running in development mode, attach the pipeline to the\n        // global object so that it's preserved between hot reloads.\n        // For more information, see https://vercel.com/guides/nextjs-prisma-postgres\n        if (!global.PipelineSingleton) {\n            global.PipelineSingleton = P();\n        }\n        PipelineSingleton = global.PipelineSingleton;\n    } else {\n        PipelineSingleton = P();\n    }\n    export default PipelineSingleton;\n    ```", "```py\n    import { NextResponse } from 'next/server'\n    import PipelineSingleton from './pipeline.js';\n\n    export async function GET(request) {\n        const text = request.nextUrl.searchParams.get('text');\n        if (!text) {\n            return NextResponse.json({\n                error: 'Missing text parameter',\n            }, { status: 400 });\n        }\n        // Get the classification pipeline. When called for the first time,\n        // this will load the pipeline and cache it for future use.\n        const classifier = await PipelineSingleton.getInstance();\n\n        // Actually perform the classification\n        const result = await classifier(text);\n\n        return NextResponse.json(result);\n    }\n    ```", "```py\n'use client'\n\nimport { useState } from 'react'\n\nexport default function Home() {\n\n  // Keep track of the classification result and the model loading status.\n  const [result, setResult] = useState(null);\n  const [ready, setReady] = useState(null);\n\n  const classify = async (text) => {\n    if (!text) return;\n    if (ready === null) setReady(false);\n\n    // Make a request to the /classify route on the server.\n    const result = await fetch(`/classify?text=${encodeURIComponent(text)}`);\n\n    // If this is the first time we've made a request, set the ready flag.\n    if (!ready) setReady(true);\n\n    const json = await result.json();\n    setResult(json);\n  };\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-center p-12\">\n      <h1 className=\"text-5xl font-bold mb-2 text-center\">Transformers.js</h1>\n      <h2 className=\"text-2xl mb-4 text-center\">Next.js template (server-side)</h2>\n      <input\n        type=\"text\"\n        className=\"w-full max-w-xs p-2 border border-gray-300 rounded mb-4\"\n        placeholder=\"Enter text here\"\n        onInput={e => {\n          classify(e.target.value);\n        }}\n      />\n\n      {ready !== null && (\n        <pre className=\"bg-gray-100 p-2 rounded\">\n          {\n            (!ready || !result) ? 'Loading...' : JSON.stringify(result, null, 2)}\n        </pre>\n      )}\n    </main>\n  )\n}\n```", "```py\nnpm run dev\n```", "```py\n    ---\n    title: Next Server Example App\n    emoji: \ud83d\udd25\n    colorFrom: yellow\n    colorTo: red\n    sdk: docker\n    pinned: false\n    app_port: 3000\n    ---\n    ```"]