- en: Create reproducible pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Original text: [https://huggingface.co/docs/diffusers/using-diffusers/reproducibility](https://huggingface.co/docs/diffusers/using-diffusers/reproducibility)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en:  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  prefs: []
  type: TYPE_NORMAL
- en: Reproducibility is important for testing, replicating results, and can even
    be used to [improve image quality](reusing_seeds). However, the randomness in
    diffusion models is a desired property because it allows the pipeline to generate
    different images every time it is run. While you canâ€™t expect to get the exact
    same results across platforms, you can expect results to be reproducible across
    releases and platforms within a certain tolerance range. Even then, tolerance
    varies depending on the diffusion pipeline and checkpoint.
  prefs: []
  type: TYPE_NORMAL
- en: This is why itâ€™s important to understand how to control sources of randomness
    in diffusion models or use deterministic algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'ðŸ’¡ We strongly recommend reading PyTorchâ€™s [statement about reproducibility](https://pytorch.org/docs/stable/notes/randomness.html):'
  prefs: []
  type: TYPE_NORMAL
- en: Completely reproducible results are not guaranteed across PyTorch releases,
    individual commits, or different platforms. Furthermore, results may not be reproducible
    between CPU and GPU executions, even when using identical seeds.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Control randomness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During inference, pipelines rely heavily on random sampling operations which
    include creating the Gaussian noise tensors to denoise and adding noise to the
    scheduling step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the tensor values in the [DDIMPipeline](/docs/diffusers/v0.26.3/en/api/pipelines/ddim#diffusers.DDIMPipeline)
    after two inference steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Running the code above prints one value, but if you run it again you get a different
    value. What is going on here?
  prefs: []
  type: TYPE_NORMAL
- en: Every time the pipeline is run, [`torch.randn`](https://pytorch.org/docs/stable/generated/torch.randn.html)
    uses a different random seed to create Gaussian noise which is denoised stepwise.
    This leads to a different result each time it is run, which is great for diffusion
    pipelines since it generates a different random image each time.
  prefs: []
  type: TYPE_NORMAL
- en: But if you need to reliably generate the same image, thatâ€™ll depend on whether
    youâ€™re running the pipeline on a CPU or GPU.
  prefs: []
  type: TYPE_NORMAL
- en: CPU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To generate reproducible results on a CPU, youâ€™ll need to use a PyTorch [`Generator`](https://pytorch.org/docs/stable/generated/torch.Generator.html)
    and set a seed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now when you run the code above, it always prints a value of `1491.1711` no
    matter what because the `Generator` object with the seed is passed to all the
    random functions of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this code example on your specific hardware and PyTorch version,
    you should get a similar, if not the same, result.
  prefs: []
  type: TYPE_NORMAL
- en: ðŸ’¡ It might be a bit unintuitive at first to pass `Generator` objects to the
    pipeline instead of just integer values representing the seed, but this is the
    recommended design when dealing with probabilistic models in PyTorch, as `Generator`s
    are *random states* that can be passed to multiple pipelines in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: GPU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing a reproducible pipeline on a GPU is a bit trickier, and full reproducibility
    across different hardware is not guaranteed because matrix multiplication - which
    diffusion pipelines require a lot of - is less deterministic on a GPU than a CPU.
    For example, if you run the same code example above on a GPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result is not the same even though youâ€™re using an identical seed because
    the GPU uses a different random number generator than the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: To circumvent this problem, ðŸ§¨ Diffusers has a `randn_tensor()` function for
    creating random noise on the CPU, and then moving the tensor to a GPU if necessary.
    The `randn_tensor` function is used everywhere inside the pipeline, allowing the
    user to **always** pass a CPU `Generator` even if the pipeline is run on a GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Youâ€™ll see the results are much closer now!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ðŸ’¡ If reproducibility is important, we recommend always passing a CPU generator.
    The performance loss is often neglectable, and youâ€™ll generate much more similar
    values than if the pipeline had been run on a GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for more complex pipelines such as [UnCLIPPipeline](/docs/diffusers/v0.26.3/en/api/pipelines/unclip#diffusers.UnCLIPPipeline),
    these are often extremely susceptible to precision error propagation. Donâ€™t expect
    similar results across different GPU hardware or PyTorch versions. In this case,
    youâ€™ll need to run exactly the same hardware and PyTorch version for full reproducibility.
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also configure PyTorch to use deterministic algorithms to create a reproducible
    pipeline. However, you should be aware that deterministic algorithms may be slower
    than nondeterministic ones and you may observe a decrease in performance. But
    if reproducibility is important to you, then this is the way to go!
  prefs: []
  type: TYPE_NORMAL
- en: Nondeterministic behavior occurs when operations are launched in more than one
    CUDA stream. To avoid this, set the environment variable [`CUBLAS_WORKSPACE_CONFIG`](https://docs.nvidia.com/cuda/cublas/index.html#results-reproducibility)
    to `:16:8` to only use one buffer size during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: PyTorch typically benchmarks multiple algorithms to select the fastest one,
    but if you want reproducibility, you should disable this feature because the benchmark
    may select different algorithms each time. Lastly, pass `True` to [`torch.use_deterministic_algorithms`](https://pytorch.org/docs/stable/generated/torch.use_deterministic_algorithms.html)
    to enable deterministic algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now when you run the same pipeline twice, youâ€™ll get identical results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
