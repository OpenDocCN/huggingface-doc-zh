["```py\n( num_train_timesteps: int = 1000 beta_start: float = 0.0001 beta_end: float = 0.02 beta_schedule: str = 'linear' trained_betas: Union = None clip_sample: bool = True set_alpha_to_one: bool = True steps_offset: int = 0 prediction_type: str = 'epsilon' clip_sample_range: float = 1.0 timestep_spacing: str = 'leading' rescale_betas_zero_snr: bool = False **kwargs )\n```", "```py\n( sample: FloatTensor timestep: Optional = None ) \u2192 export const metadata = 'undefined';torch.FloatTensor\n```", "```py\n( num_inference_steps: int device: Union = None )\n```", "```py\n( model_output: FloatTensor timestep: int sample: FloatTensor return_dict: bool = True ) \u2192 export const metadata = 'undefined';~schedulers.scheduling_ddim_inverse.DDIMInverseSchedulerOutput or tuple\n```"]