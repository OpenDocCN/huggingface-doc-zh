# LED

> 原始文本：[`huggingface.co/docs/transformers/v4.37.2/en/model_doc/led`](https://huggingface.co/docs/transformers/v4.37.2/en/model_doc/led)

## 概述

LED 模型是由 Iz Beltagy、Matthew E. Peters、Arman Cohan 在[Longformer: The Long-Document Transformer](https://arxiv.org/abs/2004.05150)中提出的。

论文的摘要如下：

*基于 Transformer 的模型由于其自注意力操作，无法处理长序列，其操作随着序列长度呈二次方增长。为了解决这一限制，我们引入了 Longformer，其注意力机制与序列长度呈线性增长，使得处理数千个标记或更长文档变得容易。Longformer 的注意力机制是标准自注意力的替代品，结合了局部窗口注意力和任务驱动的全局注意力。在长序列 Transformer 的先前工作基础上，我们在字符级语言建模上评估 Longformer，并在 text8 和 enwik8 上取得了最先进的结果。与大多数先前的工作相比，我们还对 Longformer 进行预训练，并在各种下游任务上进行微调。我们的预训练 Longformer 在长文档任务上始终优于 RoBERTa，并在 WikiHop 和 TriviaQA 上取得了最新的最先进结果。最后，我们介绍了 Longformer-Encoder-Decoder（LED），这是 Longformer 的一种变体，用于支持长文档生成的序列到序列任务，并展示了其在 arXiv 摘要数据集上的有效性。*

## 使用提示

+   LEDForConditionalGeneration 是 BartForConditionalGeneration 的扩展，用*Longformer*的*分块自注意力*层替换传统的*自注意力*层。LEDTokenizer 是 BartTokenizer 的别名。

+   LED 在长距离*序列到序列*任务中表现非常出色，其中`input_ids`大部分超过 1024 个标记的长度。

+   如果需要，LED 会将`input_ids`填充为`config.attention_window`的倍数。因此，当 LEDTokenizer 与`pad_to_multiple_of`参数一起使用时，可以获得一定的加速。

+   LED 通过`global_attention_mask`（参见 LongformerModel）利用*全局注意力*。对于摘要，建议仅在第一个`<s>`标记上放置*全局注意力*。对于问答，建议在问题的所有标记上放置*全局注意力*。

+   要在所有 16384 上微调 LED，如果训练导致内存不足（OOM）错误，可以启用*梯度检查点*。这可以通过执行`model.gradient_checkpointing_enable()`来实现。此外，可以使用`use_cache=False`标志来禁用缓存机制以节省内存。

+   LED 是一个具有绝对位置嵌入的模型，因此通常建议在右侧而不是左侧填充输入。

此模型由[patrickvonplaten](https://huggingface.co/patrickvonplaten)贡献。

## 资源

+   [展示如何评估 LED 的笔记本](https://colab.research.google.com/drive/12INTTR6n64TzS4RrXZxMSXfrOd9Xzamo?usp=sharing)。

+   [展示如何微调 LED 的笔记本](https://colab.research.google.com/drive/12LjJazBl7Gam0XBPy_y0CTOJZeZ34c2v?usp=sharing)。

+   文本分类任务指南

+   问答任务指南

+   翻译任务指南

+   总结任务指南

## LEDConfig

### `class transformers.LEDConfig`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/configuration_led.py#L31)

```py
( vocab_size = 50265 max_encoder_position_embeddings = 16384 max_decoder_position_embeddings = 1024 encoder_layers = 12 encoder_ffn_dim = 4096 encoder_attention_heads = 16 decoder_layers = 12 decoder_ffn_dim = 4096 decoder_attention_heads = 16 encoder_layerdrop = 0.0 decoder_layerdrop = 0.0 use_cache = True is_encoder_decoder = True activation_function = 'gelu' d_model = 1024 dropout = 0.1 attention_dropout = 0.0 activation_dropout = 0.0 init_std = 0.02 decoder_start_token_id = 2 classifier_dropout = 0.0 pad_token_id = 1 bos_token_id = 0 eos_token_id = 2 attention_window: Union = 512 **kwargs )
```

参数

+   `vocab_size` (`int`, *optional*, defaults to 50265) — LED 模型的词汇表大小。定义了在调用 LEDModel 或 TFLEDModel 时可以表示的不同标记数量。

+   `d_model` (`int`, *optional*, defaults to 1024) — 层和池化器层的维度。

+   `encoder_layers` (`int`, *optional*, defaults to 12) — 编码器层数。

+   `decoder_layers` (`int`, *optional*, defaults to 12) — 解码器层数。

+   `encoder_attention_heads` (`int`, *optional*, defaults to 16) — Transformer 编码器中每个注意力层的注意力头数。

+   `decoder_attention_heads` (`int`, *optional*, defaults to 16) — Transformer 解码器中每个注意力层的注意力头数。

+   `decoder_ffn_dim` (`int`, *optional*, defaults to 4096) — 解码器中“中间”（通常称为前馈）层的维度。

+   `encoder_ffn_dim` (`int`, *optional*, defaults to 4096) — 解码器中“中间”（通常称为前馈）层的维度。

+   `activation_function` (`str` or `function`, *optional*, defaults to `"gelu"`) — 编码器和池化器中的非线性激活函数（函数或字符串）。如果是字符串，支持`"gelu"`、`"relu"`、`"silu"`和`"gelu_new"`。

+   `dropout` (`float`, *optional*, defaults to 0.1) — 嵌入层、编码器和池化器中所有全连接层的 dropout 概率。

+   `attention_dropout` (`float`, *optional*, defaults to 0.0) — 注意力概率的 dropout 比率。

+   `activation_dropout` (`float`, *optional*, defaults to 0.0) — 全连接层内激活的 dropout 比率。

+   `classifier_dropout` (`float`, *optional*, defaults to 0.0) — 分类器的 dropout 比率。

+   `max_encoder_position_embeddings` (`int`, *optional*, defaults to 16384) — 编码器可能使用的最大序列长度。

+   `max_decoder_position_embeddings` (`int`, *optional*, defaults to 16384) — 解码器可能使用的最大序列长度。

+   `init_std` (`float`, *optional*, defaults to 0.02) — 用于初始化所有权重矩阵的截断正态初始化器的标准差。

+   `encoder_layerdrop` (`float`, *optional*, defaults to 0.0) — 编码器的 LayerDrop 概率。更多细节请参阅 LayerDrop paper)。

+   `decoder_layerdrop` (`float`, *optional*, defaults to 0.0) — 解码器的 LayerDrop 概率。更多细节请参阅 LayerDrop paper)。

+   `use_cache` (`bool`, *optional*, defaults to `True`) — 模型是否应返回最后的键/值注意力（并非所有模型都使用）。

这是用于存储 LEDModel 配置的配置类。根据指定的参数实例化一个 LED 模型，定义模型架构。使用默认值实例化配置将产生类似于[allenai/led-base-16384](https://huggingface.co/allenai/led-base-16384)架构的配置。

配置对象继承自 PretrainedConfig，可用于控制模型输出。阅读 PretrainedConfig 的文档以获取更多信息。

示例：

```py
>>> from transformers import LEDModel, LEDConfig

>>> # Initializing a LED allenai/led-base-16384 style configuration
>>> configuration = LEDConfig()

>>> # Initializing a model from the allenai/led-base-16384 style configuration
>>> model = LEDModel(configuration)

>>> # Accessing the model configuration
>>> configuration = model.config
```

## LEDTokenizer

### `class transformers.LEDTokenizer`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/tokenization_led.py#L93)

```py
( vocab_file merges_file errors = 'replace' bos_token = '<s>' eos_token = '</s>' sep_token = '</s>' cls_token = '<s>' unk_token = '<unk>' pad_token = '<pad>' mask_token = '<mask>' add_prefix_space = False **kwargs )
```

参数

+   `vocab_file` (`str`) — 词汇文件的路径。

+   `merges_file` (`str`) — 合并文件的路径。

+   `errors` (`str`, *optional*, defaults to `"replace"`) — 解码字节为 UTF-8 时要遵循的范例。有关更多信息，请参阅[bytes.decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)。

+   `bos_token` (`str`, *optional*, defaults to `"<s>"`) — 在预训练期间使用的序列开头标记。可用作序列分类器标记。

    在使用特殊标记构建序列时，不是用于序列开头的标记。使用的标记是 `cls_token`。

+   `eos_token` (`str`, *optional*, defaults to `"</s>"`) — 序列结束标记。

    在使用特殊标记构建序列时，不是用于序列结尾的标记。使用的标记是 `sep_token`。

+   `sep_token` (`str`, *optional*, defaults to `"</s>"`) — 分隔符标记，在从多个序列构建序列时使用，例如用于序列分类的两个序列或用于问答的文本和问题。它还用作使用特殊标记构建的序列的最后一个标记。

+   `cls_token` (`str`, *optional*, defaults to `"<s>"`) — 在进行序列分类（整个序列的分类而不是每个标记的分类）时使用的分类器标记。在使用特殊标记构建时，它是序列的第一个标记。

+   `unk_token` (`str`, *optional*, defaults to `"<unk>"`) — 未知标记。词汇表中不存在的标记无法转换为 ID，而是设置为此标记。

+   `pad_token` (`str`, *optional*, defaults to `"<pad>"`) — 用于填充的标记，例如在批处理不同长度的序列时。

+   `mask_token` (`str`, *optional*, defaults to `"<mask>"`) — 用于屏蔽值的标记。在使用掩码语言建模训练此模型时使用的标记。这是模型将尝试预测的标记。

+   `add_prefix_space` (`bool`, *optional*, defaults to `False`) — 是否在输入前添加一个初始空格。这允许将前导单词视为任何其他单词。（BART 分词器通过前面的空格检测单词的开头）。

构建一个 LED 分词器，类似于 ROBERTa 分词器，使用字节级字节对编码。

此分词器已经训练过，将空格视为标记的一部分（有点像 sentencepiece），因此一个单词将

在句子开头（无空格）或不在句子开头时，将以不同方式编码：

```py
>>> from transformers import LEDTokenizer

>>> tokenizer = LEDTokenizer.from_pretrained("allenai/led-base-16384")
>>> tokenizer("Hello world")["input_ids"]
[0, 31414, 232, 2]

>>> tokenizer(" Hello world")["input_ids"]
[0, 20920, 232, 2]
```

您可以通过在实例化此分词器时或在对某些文本调用它时传递 `add_prefix_space=True` 来避免这种行为，但由于模型不是以这种方式进行预训练的，因此可能会降低性能。

当与 `is_split_into_words=True` 一起使用时，此分词器将在每个单词之前添加一个空格（甚至是第一个单词）。

此分词器继承自 PreTrainedTokenizer，其中包含大多数主要方法。用户应参考此超类以获取有关这些方法的更多信息。

#### `build_inputs_with_special_tokens`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/tokenization_led.py#L342)

```py
( token_ids_0: List token_ids_1: Optional = None ) → export const metadata = 'undefined';List[int]
```

参数

+   `token_ids_0` (`List[int]`) — 将添加特殊标记的 ID 列表。

+   `token_ids_1` (`List[int]`, *optional*) — 序列对的可选第二个 ID 列表。

返回

`List[int]`

具有适当特殊标记的输入 ID 列表。

通过连接和添加特殊标记从序列或序列对构建用于序列分类任务的模型输入。LED 序列的格式如下：

+   单个序列：`<s> X </s>`

+   序列对：`<s> A </s></s> B </s>`

#### `get_special_tokens_mask`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/tokenization_led.py#L368)

```py
( token_ids_0: List token_ids_1: Optional = None already_has_special_tokens: bool = False ) → export const metadata = 'undefined';List[int]
```

参数

+   `token_ids_0`（`List[int]`）— ID 列表。

+   `token_ids_1`（`List[int]`，*可选*）— 序列对的可选第二个 ID 列表。

+   `already_has_special_tokens`（`bool`，*可选*，默认为`False`）— 标记列表是否已经格式化为模型的特殊标记。

返回

`List[int]`

一个整数列表，范围为[0, 1]：1 表示特殊标记，0 表示序列标记。

从没有添加特殊标记的标记列表中检索序列 ID。在使用标记器`prepare_for_model`方法添加特殊标记时调用此方法。

#### `create_token_type_ids_from_sequences`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/tokenization_led.py#L396)

```py
( token_ids_0: List token_ids_1: Optional = None ) → export const metadata = 'undefined';List[int]
```

参数

+   `token_ids_0`（`List[int]`）— ID 列表。

+   `token_ids_1`（`List[int]`，*可选*）— 序列对的可选第二个 ID 列表。

返回

`List[int]`

零列表。

从传递的两个序列创建一个用于序列对分类任务的掩码。LED 不使用标记类型 ID，因此返回一个零列表。

#### `save_vocabulary`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/tokenization_led.py#L312)

```py
( save_directory: str filename_prefix: Optional = None )
```

## LEDTokenizerFast

### `class transformers.LEDTokenizerFast`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/tokenization_led_fast.py#L50)

```py
( vocab_file = None merges_file = None tokenizer_file = None errors = 'replace' bos_token = '<s>' eos_token = '</s>' sep_token = '</s>' cls_token = '<s>' unk_token = '<unk>' pad_token = '<pad>' mask_token = '<mask>' add_prefix_space = False trim_offsets = True **kwargs )
```

参数

+   `vocab_file`（`str`）— 词汇文件的路径。

+   `merges_file`（`str`）— 合并文件的路径。

+   `errors`（`str`，*可选*，默认为`"replace"`）— 解码字节为 UTF-8 时要遵循的范例。有关更多信息，请参见[bytes.decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)。

+   `bos_token`（`str`，*可选*，默认为`"<s>"`）— 在预训练期间使用的序列开头标记。可以用作序列分类器标记。

    在使用特殊标记构建序列时，这不是用于序列开头的标记。使用的标记是`cls_token`。

+   `eos_token`（`str`，*可选*，默认为`"</s>"`）— 序列结束标记。

    在使用特殊标记构建序列时，这不是用于序列结尾的标记。使用的标记是`sep_token`。

+   `sep_token`（`str`，*可选*，默认为`"</s>"`）— 分隔符标记，在从多个序列构建序列时使用，例如用于序列分类的两个序列或用于文本和问题的问题回答。它还用作使用特殊标记构建的序列的最后一个标记。

+   `cls_token`（`str`，*可选*，默认为`"<s>"`）— 在进行序列分类（对整个序列而不是每个标记进行分类）时使用的分类器标记。在使用特殊标记构建序列时，它是序列的第一个标记。

+   `unk_token`（`str`，*可选*，默认为`"<unk>"`）— 未知标记。词汇表中没有的标记无法转换为 ID，而是设置为此标记。

+   `pad_token`（`str`，*可选*，默认为`"<pad>"`）— 用于填充的标记，例如在批处理不同长度的序列时。

+   `mask_token`（`str`，*可选*，默认为`"<mask>"`）— 用于屏蔽值的标记。在使用掩码语言建模训练此模型时使用的标记。这是模型将尝试预测的标记。

+   `add_prefix_space`（`bool`，*可选*，默认为`False`）— 是否在输入前添加一个初始空格。这允许将前导单词视为任何其他单词。（LED 标记器通过前导空格检测单词的开头）。

+   `trim_offsets`（`bool`，*可选*，默认为`True`）— 后处理步骤是否应修剪偏移以避免包含空格。

构建一个“快速”LED 分词器（由 HuggingFace 的*tokenizers*库支持），源自 GPT-2 分词器，使用字节级字节对编码。

这个分词器已经训练过，将空格视为标记的一部分（有点像 sentencepiece），所以一个单词会被编码成不同的方式

无论是在句子开头（没有空格）还是不是，都会被编码成不同的方式：

```py
>>> from transformers import LEDTokenizerFast

>>> tokenizer = LEDTokenizerFast.from_pretrained("allenai/led-base-16384")
>>> tokenizer("Hello world")["input_ids"]
[0, 31414, 232, 2]

>>> tokenizer(" Hello world")["input_ids"]
[0, 20920, 232, 2]
```

您可以通过在实例化这个分词器时或在对一些文本调用它时传递`add_prefix_space=True`来避免这种行为，但由于模型不是以这种方式进行预训练的，可能会导致性能下降。

当与`is_split_into_words=True`一起使用时，这个分词器需要用`add_prefix_space=True`实例化。

这个分词器继承自 PreTrainedTokenizerFast，其中包含大部分主要方法。用户应该参考这个超类以获取有关这些方法的更多信息。

#### `create_token_type_ids_from_sequences`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/tokenization_led_fast.py#L279)

```py
( token_ids_0: List token_ids_1: Optional = None ) → export const metadata = 'undefined';List[int]
```

参数

+   `token_ids_0`（`List[int]`）— ID 列表。

+   `token_ids_1`（`List[int]`，*可选*）— 序列对的可选第二个 ID 列表。

返回

`List[int]`

零的列表。

从传递的两个序列中创建一个用于序列对分类任务的掩码。LED 不使用标记类型 ID，因此返回一个零的列表。

## LED 特定的输出

`class transformers.models.led.modeling_led.LEDEncoderBaseModelOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L1155)

```py
( last_hidden_state: FloatTensor hidden_states: Optional = None attentions: Optional = None global_attentions: Optional = None )
```

参数

+   `last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`）— 模型最后一层的隐藏状态的序列。

+   `hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或当`config.output_hidden_states=True`时返回）— 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（一个用于嵌入的输出，一个用于每一层的输出）。

    模型在每一层输出的隐藏状态加上初始嵌入输出。

+   `attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, x + attention_window + 1)`的`torch.FloatTensor`元组（每层一个），其中`x`是具有全局注意力掩码的标记数。

    在注意力 softmax 之后的局部注意力权重，用于计算自注意力头中的加权平均值。这些是从序列中的每个标记到具有全局注意力的每个标记（前`x`个值）和到注意力窗口中的每个标记（剩余`attention_window`个值）的注意力权重

    +   1`values)。注意，前`x`个值是指文本中固定位置的标记，但剩余的`attention_window + 1`个值是指相对位置的标记：一个标记到自身的注意力权重位于索引`x + attention_window / 2`，前（后）`attention_window / 2`个值是指到前（后）`attention_window / 2`个标记的注意力权重。如果注意力窗口包含一个具有全局注意力的标记，相应索引处的注意力权重设置为 0；值应该从前`x`个注意力权重中访问。如果一个标记具有全局注意力，那么`attentions`中所有其他标记的注意力权重都设置为 0，值应该从`global_attentions`中访问。

+   `global_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, x)`的`torch.FloatTensor`元组（每层一个），其中`x`是具有全局注意力掩码的令牌数。

    注意力 softmax 之后的全局注意力权重，用于计算自注意力头中的加权平均值。这些是每个令牌与序列中每个令牌的全局注意力的注意力权重。

LEDEncoder 输出的基类，具有潜在的隐藏状态、局部和全局注意力。

### `class transformers.models.led.modeling_led.LEDSeq2SeqModelOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L1199)

```py
( last_hidden_state: FloatTensor = None past_key_values: Optional = None decoder_hidden_states: Optional = None decoder_attentions: Optional = None cross_attentions: Optional = None encoder_last_hidden_state: Optional = None encoder_hidden_states: Optional = None encoder_attentions: Optional = None encoder_global_attentions: Optional = None )
```

参数

+   `last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`) — 模型解码器最后一层的隐藏状态序列输出。

    如果使用`past_key_values`，则仅输出形状为`(batch_size, 1, hidden_size)`的序列的最后隐藏状态。

+   `past_key_values` (`List[torch.FloatTensor]`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回） — 长度为`config.n_layers`的`torch.FloatTensor`列表，每个张量的形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预计算隐藏状态（注意力块中的键和值），可用于加速顺序解码。

+   `decoder_hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（一个用于嵌入的输出 + 一个用于每层的输出）。

    每层解码器的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`，*可选*) — 模型编码器最后一层的隐藏状态序列输出。

+   `encoder_hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（一个用于嵌入的输出 + 一个用于每层的输出）。

    每层解码器的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `encoder_global_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, x)`的`torch.FloatTensor`元组，其中`x`是具有全局注意力掩码的令牌数。

    在注意力 softmax 之后的全局注意力权重，用于计算自注意力头中的加权平均值。这些是每个令牌对序列中每个令牌的全局注意力的注意力权重。

模型编码器输出的基类，还包含：可加速顺序解码的预计算隐藏状态。

### `class transformers.models.led.modeling_led.LEDSeq2SeqLMOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L1267)

```py
( loss: Optional = None logits: FloatTensor = None past_key_values: Optional = None decoder_hidden_states: Optional = None decoder_attentions: Optional = None cross_attentions: Optional = None encoder_last_hidden_state: Optional = None encoder_hidden_states: Optional = None encoder_attentions: Optional = None encoder_global_attentions: Optional = None )
```

参数

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，当提供`labels`时返回）- 语言建模损失。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`torch.FloatTensor`）- 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values`（`List[torch.FloatTensor]`，*可选*，当传递`use_cache=True`或当`config.use_cache=True`时返回）- 长度为`config.n_layers`的`torch.FloatTensor`列表，每个张量形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预计算隐藏状态（注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或当`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组。

    解码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    解码器交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）- 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或当`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组。

    编码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `encoder_global_attentions` (`tuple(torch.FloatTensor)`, *可选*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, x)`的`torch.FloatTensor`元组（每层一个），其中`x`是具有全局注意力掩码的令牌数。

    在注意力 SoftMax 之后的全局注意力权重，用于计算自注意力头中的加权平均值。这些是来自每个具有全局注意力的令牌对序列中每个令牌的注意力权重。

用于序列到序列语言模型输出的基类。

### `class transformers.models.led.modeling_led.LEDSeq2SeqSequenceClassifierOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L1334)

```py
( loss: Optional = None logits: FloatTensor = None past_key_values: Optional = None decoder_hidden_states: Optional = None decoder_attentions: Optional = None cross_attentions: Optional = None encoder_last_hidden_state: Optional = None encoder_hidden_states: Optional = None encoder_attentions: Optional = None encoder_global_attentions: Optional = None )
```

参数

+   `loss` (`torch.FloatTensor`，形状为`(1,)`, *可选*, 当提供`label`时返回) — 分类（如果`config.num_labels==1`则为回归）损失。

+   `logits` (`torch.FloatTensor`，形状为`(batch_size, config.num_labels)`) — SoftMax 之前的分类（如果`config.num_labels==1`则为回归）分数。

+   `past_key_values` (`List[torch.FloatTensor]`, *可选*, 当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`torch.FloatTensor`列表，每个张量的形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预计算隐藏状态（注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states` (`tuple(torch.FloatTensor)`, *可选*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（一个用于嵌入输出，一个用于每层输出）。

    每层解码器的隐藏状态以及初始嵌入输出。

+   `decoder_attentions` (`tuple(torch.FloatTensor)`, *可选*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的注意力权重，在注意力 SoftMax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(torch.FloatTensor)`, *可选*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器交叉注意力层的注意力权重，在注意力 SoftMax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`，*可选*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(torch.FloatTensor)`, *可选*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（一个用于嵌入输出，一个用于每层输出）。

    每层编码器的隐藏状态以及初始嵌入输出。

+   `encoder_attentions` (`tuple(torch.FloatTensor)`, *可选*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    编码器的注意力权重，在注意力 SoftMax 之后，用于计算自注意力头中的加权平均值。

+   `encoder_global_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, x)`的`torch.FloatTensor`元组，其中`x`是具有全局注意力掩码的令牌数量。

    全局注意力权重在注意力 softmax 之后，用于计算自注意力头中的加权平均值。这些是来自具有全局注意力的每个令牌到序列中每个令牌的注意力权重。

用于序列到序列句子分类模型输出的基类。

### `class transformers.models.led.modeling_led.LEDSeq2SeqQuestionAnsweringModelOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L1401)

```py
( loss: Optional = None start_logits: FloatTensor = None end_logits: FloatTensor = None past_key_values: Optional = None decoder_hidden_states: Optional = None decoder_attentions: Optional = None cross_attentions: Optional = None encoder_last_hidden_state: Optional = None encoder_hidden_states: Optional = None encoder_attentions: Optional = None encoder_global_attentions: Optional = None )
```

参数

+   `loss` (`torch.FloatTensor`，形状为`(1,)`，*optional*, 当提供`labels`时返回) — 总跨度提取损失是起始位置和结束位置的交叉熵之和。

+   `start_logits` (`torch.FloatTensor`，形状为`(batch_size, sequence_length)`) — 跨度起始分数（SoftMax 之前）。

+   `end_logits` (`torch.FloatTensor`，形状为`(batch_size, sequence_length)`) — 跨度结束分数（SoftMax 之前）。

+   `past_key_values` (`List[torch.FloatTensor]`, *optional*, 当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`torch.FloatTensor`列表，每个张量的形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预计算隐藏状态（注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组。

    解码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`，*optional*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组。

    编码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `encoder_global_attentions` (`tuple(torch.FloatTensor)`, *可选的*, 当传递 `output_attentions=True` 或者当 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, x)` 的 `torch.FloatTensor` 元组（每层一个），其中 `x` 是具有全局注意力掩码的令牌数量。

    在注意力 softmax 后的全局注意力权重，用于计算自注意力头中的加权平均值。这些是从具有全局注意力的每个令牌到序列中的每个令牌的注意力权重。

用于序列到序列问答模型输出的基类。

### `class transformers.models.led.modeling_tf_led.TFLEDEncoderBaseModelOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_tf_led.py#L1435)

```py
( last_hidden_state: tf.Tensor = None hidden_states: Tuple[tf.Tensor] | None = None attentions: Tuple[tf.Tensor] | None = None global_attentions: Tuple[tf.Tensor] | None = None )
```

参数

+   `last_hidden_state` (`tf.Tensor`，形状为 `(batch_size, sequence_length, hidden_size)`) — 模型最后一层的隐藏状态序列。

+   `hidden_states` (`tuple(tf.Tensor)`，*可选的*，当传递 `output_hidden_states=True` 或者当 `config.output_hidden_states=True` 时返回) — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `tf.Tensor` 元组（一个用于嵌入的输出 + 一个用于每一层的输出）。

    模型在每一层输出的隐藏状态以及初始嵌入输出。

+   `attentions` (`tuple(tf.Tensor)`，*可选的*，当传递 `output_attentions=True` 或者当 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, x + attention_window + 1)` 的 `tf.Tensor` 元组（每层一个），其中 `x` 是具有全局注意力掩码的令牌数量。

    在注意力 softmax 后的局部注意力权重，用于计算自注意力头中的加权平均值。这些是从序列中的每个令牌到具有全局注意力的每个令牌（前 `x` 个值）以及到注意力窗口中的每个令牌（剩余的 `attention_window`）的注意力权重。

    +   注意：前 `x` 个值指的是文本中具有固定位置的令牌，但剩余的 `attention_window + 1` 个值指的是具有相对位置的令牌：一个令牌到自身的注意力权重位于索引 `x + attention_window / 2`，前（后）的 `attention_window / 2` 个值是到前（后）的令牌的注意力权重。如果注意力窗口包含具有全局注意力的令牌，则相应索引处的注意力权重设置为 0；该值应从前 `x` 个注意力权重中获取。如果一个令牌具有全局注意力，则到`attentions`中的所有其他令牌的注意力权重设置为 0，应从`global_attentions`中获取值。

+   `global_attentions` (`tuple(tf.Tensor)`，*可选的*，当传递 `output_attentions=True` 或者当 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, x)` 的 `tf.Tensor` 元组（每层一个），其中 `x` 是具有全局注意力掩码的令牌数量。

    在注意力 softmax 后的全局注意力权重，用于计算自注意力头中的加权平均值。这些是从具有全局注意力的每个令牌到序列中的每个令牌的注意力权重。

Longformer 输出的基类，具有潜在的隐藏状态、局部和全局注意力。

### `class transformers.models.led.modeling_tf_led.TFLEDSeq2SeqModelOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_tf_led.py#L1479)

```py
( last_hidden_state: tf.Tensor = None past_key_values: List[tf.Tensor] | None = None decoder_hidden_states: Tuple[tf.Tensor] | None = None decoder_attentions: Tuple[tf.Tensor] | None = None cross_attentions: Tuple[tf.Tensor] | None = None encoder_last_hidden_state: tf.Tensor | None = None encoder_hidden_states: Tuple[tf.Tensor] | None = None encoder_attentions: Tuple[tf.Tensor] | None = None encoder_global_attentions: Tuple[tf.Tensor] | None = None )
```

参数

+   `last_hidden_state` (`tf.Tensor`，形状为 `(batch_size, sequence_length, hidden_size)`) — 解码器模型最后一层的隐藏状态序列。

    如果使用 `past_key_values`，则仅输出形状为 `(batch_size, 1, hidden_size)` 的序列的最后一个隐藏状态。

+   `past_key_values`（`List[tf.Tensor]`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）- 长度为`config.n_layers`的`tf.Tensor`列表，每个张量的形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预计算隐藏状态（注意力块中的键和值），可用于加速顺序解码。

+   `decoder_hidden_states`（`tuple(tf.Tensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入输出，一个用于每层输出）。

    每层解码器的隐藏状态加上初始嵌入输出。

+   `decoder_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    解码器的注意力权重，在注意力 SoftMax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 SoftMax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`，*可选*）- 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(tf.Tensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入输出，一个用于每层输出）。

    每层编码器的隐藏状态加上初始嵌入输出。

+   `encoder_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    编码器的注意力权重，在注意力 SoftMax 之后，用于计算自注意力头中的加权平均值。

+   `encoder_global_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, x)`的`tf.Tensor`元组（每层一个），其中`x`是具有全局注意力掩码的令牌数。

    在注意力 SoftMax 之后的全局注意力权重，用于计算自注意力头中的加权平均值。这些是每个具有全局注意力的令牌对序列中每个令牌的注意力权重。

模型编码器输出的基类，还包含：可加速顺序解码的预计算隐藏状态。

### `class transformers.models.led.modeling_tf_led.TFLEDSeq2SeqLMOutput`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_tf_led.py#L1547)

```py
( loss: tf.Tensor | None = None logits: tf.Tensor = None past_key_values: List[tf.Tensor] | None = None decoder_hidden_states: Tuple[tf.Tensor] | None = None decoder_attentions: Tuple[tf.Tensor] | None = None cross_attentions: Tuple[tf.Tensor] | None = None encoder_last_hidden_state: tf.Tensor | None = None encoder_hidden_states: Tuple[tf.Tensor] | None = None encoder_attentions: Tuple[tf.Tensor] | None = None encoder_global_attentions: Tuple[tf.Tensor] | None = None )
```

参数

+   `loss`（形状为`(1,)`的`tf.Tensor`，*可选*，当提供`labels`时返回）- 语言建模损失。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`tf.Tensor`）- 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values` (`List[tf.Tensor]`, *optional*, 当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tf.Tensor`列表，每个张量的形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预计算隐藏状态（注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states` (`tuple(tf.Tensor)`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入的输出 + 一个用于每个层的输出）。

    解码器在每个层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(tf.Tensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每个层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(tf.Tensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每个层一个）。

    解码器交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`tf.Tensor`，形状为`(batch_size, sequence_length, hidden_size)`，*optional*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(tf.Tensor)`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入的输出 + 一个用于每个层的输出）。

    编码器在每个层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(tf.Tensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每个层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `encoder_global_attentions` (`tuple(tf.Tensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, x)`的`tf.Tensor`元组（每个层一个），其中`x`是具有全局注意力掩码的令牌数。

    全局注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。这些是来自每个令牌对整个序列中每个令牌的全局注意力权重。

用于序列到序列语言模型输出的基类。

PytorchHide Pytorch content

## LEDModel

### `class transformers.LEDModel`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L2180)

```py
( config: LEDConfig )
```

参数

+   `config` (LEDConfig) — 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

裸 LED 模型输出原始隐藏状态，没有特定的头部。该模型继承自 PreTrainedModel。请参阅超类文档，了解库为所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头部等）。

该模型还是 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取一般用法和行为。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L2213)

```py
( input_ids: Optional = None attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None global_attention_mask: Optional = None past_key_values: Optional = None inputs_embeds: Optional = None decoder_inputs_embeds: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`）— 词汇表中输入序列标记的索引。默认情况下将忽略填充。

    可以使用 AutoTokenizer 来获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.Tensor`，*可选*）— 用于避免在填充标记索引上执行注意力的掩码。掩码值选在`[0, 1]`之间：

    +   1 表示未被屏蔽的标记，

    +   0 表示被屏蔽的标记。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）— 词汇表中解码器输入序列标记的索引。

    可以使用`LedTokenizer`来获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    LED 使用`eos_token_id`作为`decoder_input_ids`生成的起始标记。如果使用`past_key_values`，则可以选择仅输入最后的`decoder_input_ids`（请参阅`past_key_values`）。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）— 默认行为：生成一个忽略`decoder_input_ids`中填充标记的张量。因果掩码也将默认使用。

    如果要更改填充行为，应阅读`modeling_led._prepare_decoder_inputs`并根据需要进行修改。有关默认策略的更多信息，请参阅[论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `global_attention_mask`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`，*可选*）— 用于决定每个标记的注意力，编码器的局部注意力或全局注意力。具有全局注意力的标记会关注所有其他标记，而所有其他标记也会关注它们。这对于任务特定的微调非常重要，因为它使模型在表示任务时更加灵活。例如，对于分类，应该给予全局注意力。对于问答，所有问题标记也应该具有全局注意力。有关更多详细信息，请参阅[Longformer 论文](https://arxiv.org/abs/2004.05150)。掩码值选在`[0, 1]`之间：

    +   0 表示局部注意力（滑动窗口注意力），

    +   1 表示全局注意力（关注所有其他标记的标记，所有其他标记也关注它们）。

+   `head_mask`（形状为`(encoder_layers, encoder_attention_heads)`的`torch.Tensor`，*可选*）— 用于使编码器中注意力模块的选定头部失效的掩码。掩码值选在`[0, 1]`之间：

    +   1 表示头部未被屏蔽，

    +   0 表示头部被`masked`。

+   `decoder_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）— 用于使解码器中注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`中：

    +   1 表示头部未被`masked`。

    +   0 表示头部被`masked`。

+   `cross_attn_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）— 用于使解码器中交叉注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`中：

    +   1 表示头部未被`masked`，

    +   0 表示头部被`masked`。

+   `encoder_outputs`（`tuple(tuple(torch.FloatTensor)`，*可选*）— 元组包括（`last_hidden_state`，*可选*：`hidden_states`，*可选*：`attentions`）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*可选*是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）— 长度为`config.n_layers`的`tuple(torch.FloatTensor)`的元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

    如果使用了`past_key_values`，用户可以选择仅输入最后的`decoder_input_ids`（那些没有将它们的过去键值状态提供给此模型的）的形状为`(batch_size, 1)`的张量，而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

+   `inputs_embeds`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选地，您可以选择直接传递嵌入表示而不是传递`input_ids`。如果您想要更多控制如何将`input_ids`索引转换为相关向量，而不是模型的内部嵌入查找矩阵，则这很有用。

+   `decoder_inputs_embeds`（形状为`(batch_size, target_sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选地，您可以选择直接传递嵌入表示而不是传递`decoder_input_ids`。如果使用了`past_key_values`，则只需输入最后的`decoder_inputs_embeds`（参见`past_key_values`）。如果您想要更多控制如何将`decoder_input_ids`索引转换为相关向量，而不是模型的内部嵌入查找矩阵，则这很有用。

    如果`decoder_input_ids`和`decoder_inputs_embeds`都未设置，则`decoder_inputs_embeds`取`inputs_embeds`的值。

+   `use_cache`（`bool`，*可选*）— 如果设置为`True`，则返回`past_key_values`键值状态，并可用于加速解码（参见`past_key_values`）。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回一个 ModelOutput 而不是一个普通元组。

返回

transformers.modeling_outputs.Seq2SeqModelOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.Seq2SeqModelOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`时），包含根据配置(LEDConfig)和输入的不同元素。

+   `last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`) — 模型解码器最后一层的隐藏状态序列。

    如果使用`past_key_values`，则只输出形状为`(batch_size, 1, hidden_size)`的序列的最后一个隐藏状态。

+   `past_key_values` (`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的元组`tuple(torch.FloatTensor)`，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states` (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`) — 解码器隐藏状态的元组，形状为`(batch_size, sequence_length, hidden_size)`，其中包括嵌入层的输出和每个层的输出。

    解码器在每一层的输出的隐藏状态，以及可选的初始嵌入输出。

+   `decoder_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 元组`torch.FloatTensor`（每层一个），形状为`(batch_size, num_heads, sequence_length, sequence_length)`。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 元组`torch.FloatTensor`（每层一个），形状为`(batch_size, num_heads, sequence_length, sequence_length)`。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`，*可选*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 元组`torch.FloatTensor`（如果模型有嵌入层，则为一个，每个层的输出为一个），形状为`(batch_size, sequence_length, hidden_size)`。

    编码器在每一层的输出的隐藏状态，以及可选的初始嵌入输出。

+   `encoder_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 元组`torch.FloatTensor`（每层一个），形状为`(batch_size, num_heads, sequence_length, sequence_length)`。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

LEDModel 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者会负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, LEDModel
>>> import torch

>>> tokenizer = AutoTokenizer.from_pretrained("allenai/led-base-16384")
>>> model = LEDModel.from_pretrained("allenai/led-base-16384")

>>> inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
>>> outputs = model(**inputs)

>>> last_hidden_states = outputs.last_hidden_state
```

## LEDForConditionalGeneration

### `class transformers.LEDForConditionalGeneration`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L2305)

```py
( config: LEDConfig )
```

参数

+   `config`（LEDConfig）— 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

具有语言建模头的 LED 模型。可用于摘要。此模型继承自 PreTrainedModel。请参阅超类文档，了解库为所有模型实现的通用方法（例如下载或保存、调整输入嵌入、修剪头等）。

此模型还是 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取一般用法和行为。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L2348)

```py
( input_ids: Optional = None attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None global_attention_mask: Optional = None past_key_values: Optional = None inputs_embeds: Optional = None decoder_inputs_embeds: Optional = None labels: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqLMOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`）— 词汇表中输入序列标记的索引。默认情况下将忽略填充。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.Tensor`，*可选*）— 避免对填充标记索引执行注意力的掩码。掩码值选在`[0, 1]`中：

    +   1 表示“未屏蔽”的标记，

    +   0 表示“屏蔽”的标记。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）— 词汇表中解码器输入序列标记的索引。

    可以使用`LedTokenizer`获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    LED 使用`eos_token_id`作为`decoder_input_ids`生成的起始标记。如果使用`past_key_values`，则只需选择最后的`decoder_input_ids`作为输入（请参阅`past_key_values`）。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）— 默认行为：生成一个张量，忽略`decoder_input_ids`中的填充标记。默认情况下还将使用因果掩码。

    如果要更改填充行为，应阅读`modeling_led._prepare_decoder_inputs`并根据需要进行修改。有关默认策略的更多信息，请参阅[论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `global_attention_mask`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`，*可选*）— 用于决定每个标记的注意力分配，编码器的局部注意力或全局注意力。具有全局注意力的标记关注所有其他标记，所有其他标记也关注它们。这对于任务特定的微调很重要，因为它使模型在表示任务时更加灵活。例如，对于分类，应该给予全局注意力。对于问答，所有问题标记也应该具有全局注意力。有关更多详细信息，请参考[Longformer paper](https://arxiv.org/abs/2004.05150)。掩码值选在`[0, 1]`之间：

    +   0 表示局部注意力（滑动窗口注意力），

    +   全局注意力为 1（关注所有其他标记，所有其他标记也关注它们）。

+   `head_mask`（形状为`(encoder_layers, encoder_attention_heads)`的`torch.Tensor`，*可选*）— 用于在编码器中使注意力模块的特定头部失效的掩码。掩码值选在`[0, 1]`之间：

    +   1 表示头部未被遮蔽。

    +   0 表示头部被遮蔽。

+   `decoder_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）— 用于在解码器中使注意力模块的特定头部失效的掩码。掩码值选在`[0, 1]`之间：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `cross_attn_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）— 用于在解码器中使交叉注意力模块的特定头部失效的掩码。掩码值选在`[0, 1]`之间：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `encoder_outputs`（`tuple(tuple(torch.FloatTensor)`，*可选*）— 元组包括（`last_hidden_state`，*可选*：`hidden_states`，*可选*：`attentions`）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*可选*）是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）— 长度为`config.n_layers`的`tuple(torch.FloatTensor)`的元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码。

    如果使用了`past_key_values`，用户可以选择只输入最后的`decoder_input_ids`（那些没有将它们的过去键值状态提供给此模型的）的形状为`(batch_size, 1)`，而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

+   `inputs_embeds`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选择直接传递嵌入表示，而不是传递`input_ids`。如果您想要更多控制如何将`input_ids`索引转换为相关向量，而不是模型内部的嵌入查找矩阵，则这很有用。

+   `decoder_inputs_embeds`（形状为`(batch_size, target_sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选择直接传递嵌入表示，而不是传递`decoder_input_ids`。如果使用了`past_key_values`，可以选择只输入最后的`decoder_inputs_embeds`（参见`past_key_values`）。如果您想要更多控制如何将`decoder_input_ids`索引转换为相关向量，而不是模型内部的嵌入查找矩阵，则这很有用。

    如果`decoder_input_ids`和`decoder_inputs_embeds`都未设置，则`decoder_inputs_embeds`取`inputs_embeds`的值。

+   `use_cache`（`bool`，*可选*）- 如果设置为`True`，则返回`past_key_values`键值状态，可用于加速解码（参见`past_key_values`）。

+   `output_attentions`（`bool`，*可选*）- 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回的张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）- 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回的张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）- 是否返回一个 ModelOutput 而不是一个普通元组。

+   `labels`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`，*可选*）- 用于计算掩码语言建模损失的标签。索引应该在`[0, ..., config.vocab_size]`范围内，或者为-100（参见`input_ids`文档字符串）。索引设置为`-100`的标记将被忽略（掩码），损失仅计算具有`[0, ..., config.vocab_size]`标签的标记。

返回

transformers.modeling_outputs.Seq2SeqLMOutput 或`tuple(torch.FloatTensor)`

transformers.modeling_outputs.Seq2SeqLMOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（LEDConfig）和输入的不同元素。

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，当提供`labels`时返回）- 语言建模损失。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`torch.FloatTensor`）- 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）- 长度为`config.n_layers`的`tuple(torch.FloatTensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量，以及 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码。

+   `decoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型具有嵌入层，则为嵌入输出的一个，加上每层的一个）。

    每层解码器的隐藏状态加上初始嵌入输出。

+   `decoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*） — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或当`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出的输出+每层的输出）。

    每层编码器的隐藏状态加上初始嵌入输出。

+   `encoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

LEDForConditionalGeneration 的前向方法，覆盖了`__call__`特殊方法。

尽管前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

条件生成示例：

```py
>>> from transformers import AutoTokenizer, LEDForConditionalGeneration

>>> tokenizer = AutoTokenizer.from_pretrained("allenai/led-base-16384")
>>> TXT = "My friends are <mask> but they eat too many carbs."

>>> model = LEDForConditionalGeneration.from_pretrained("allenai/led-base-16384")
>>> input_ids = tokenizer([TXT], return_tensors="pt")["input_ids"]

>>> prediction = model.generate(input_ids)[0]
>>> print(tokenizer.decode(prediction, skip_special_tokens=True))
```

摘要示例：

```py
>>> import torch
>>> from transformers import AutoTokenizer, LEDForConditionalGeneration

>>> model = LEDForConditionalGeneration.from_pretrained("allenai/led-large-16384-arxiv")
>>> tokenizer = AutoTokenizer.from_pretrained("allenai/led-large-16384-arxiv")

>>> ARTICLE_TO_SUMMARIZE = '''Transformers (Vaswani et al., 2017) have achieved state-of-the-art
...     results in a wide range of natural language tasks including generative language modeling
...     (Dai et al., 2019; Radford et al., 2019) and discriminative ... language understanding (Devlin et al., 2019).
...     This success is partly due to the self-attention component which enables the network to capture contextual
...     information from the entire sequence. While powerful, the memory and computational requirements of
...     self-attention grow quadratically with sequence length, making it infeasible (or very expensive) to
...     process long sequences. To address this limitation, we present Longformer, a modified Transformer
...     architecture with a self-attention operation that scales linearly with the sequence length, making it
...     versatile for processing long documents (Fig 1). This is an advantage for natural language tasks such as
...     long document classification, question answering (QA), and coreference resolution, where existing approaches
...     partition or shorten the long context into smaller sequences that fall within the typical 512 token limit
...     of BERT-style pretrained models. Such partitioning could potentially result in loss of important
...     cross-partition information, and to mitigate this problem, existing methods often rely on complex
...     architectures to address such interactions. On the other hand, our proposed Longformer is able to build
...     contextual representations of the entire context using multiple layers of attention, reducing the need for
...     task-specific architectures.'''
>>> inputs = tokenizer.encode(ARTICLE_TO_SUMMARIZE, return_tensors="pt")

>>> # Global attention on the first token (cf. Beltagy et al. 2020)
>>> global_attention_mask = torch.zeros_like(inputs)
>>> global_attention_mask[:, 0] = 1

>>> # Generate Summary
>>> summary_ids = model.generate(inputs, global_attention_mask=global_attention_mask, num_beams=3, max_length=32)
>>> print(tokenizer.decode(summary_ids[0], skip_special_tokens=True, clean_up_tokenization_spaces=True))
```

## LEDForSequenceClassification

### `class transformers.LEDForSequenceClassification`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L2491)

```py
( config: LEDConfig **kwargs )
```

参数

+   `config`（LEDConfig） — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

在顶部具有序列分类/头（在汇总输出的顶部有一个线性层）的 LED 模型，例如用于 GLUE 任务。

该模型继承自 PreTrainedModel。查看超类文档以获取库为所有模型实现的通用方法（例如下载或保存，调整输入嵌入大小，修剪头等）。

该模型也是 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取一般用法和行为。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L2520)

```py
( input_ids: Optional = None attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None global_attention_mask: Optional = None inputs_embeds: Optional = None decoder_inputs_embeds: Optional = None labels: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqSequenceClassifierOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`） — 词汇表中输入序列标记的索引。默认情况下将忽略填充。

    可以使用 AutoTokenizer 获取索引。查看 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()获取详细信息。

    什么是输入 ID？

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.Tensor`，*可选*） — 避免在填充标记索引上执行注意力的掩码。掩码值选在`[0, 1]`之间：

    +   对于`未被掩盖`的标记为 1，

    +   对于`被掩盖`的标记为 0。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）- 词汇表中解码器输入序列标记的索引。

    可以使用`LedTokenizer`获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    LED 使用`eos_token_id`作为`decoder_input_ids`生成的起始标记。如果使用`past_key_values`，则只需输入最后的`decoder_input_ids`（参见`past_key_values`）。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）- 默认行为：生成一个张量，忽略`decoder_input_ids`中的填充标记。因果掩码也将默认使用。

    如果要更改填充行为，应阅读`modeling_led._prepare_decoder_inputs`并根据需要进行修改。有关默认策略的更多信息，请参阅[论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `global_attention_mask`（形状为`(batch_size, sequence_length)`的`torch.FloatTensor`，*可选*）- 用于决定每个标记上给定的注意力，编码器的局部注意力或全局注意力。具有全局注意力的标记会关注所有其他标记，而所有其他标记会关注它们。这对于任务特定的微调很重要，因为它使模型在表示任务时更加灵活。例如，对于分类，应该给予全局注意力。对于问答，所有问题标记也应该具有全局注意力。有关更多详细信息，请参阅[Longformer paper](https://arxiv.org/abs/2004.05150)。在`[0, 1]`中选择的掩码值：

    +   0 表示局部注意力（滑动窗口注意力），

    +   1 表示全局注意力（关注所有其他标记的标记，所有其他标记也关注它们）。

+   `head_mask`（形状为`(encoder_layers, encoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于在编码器中的注意力模块中使选定的头部失效的掩码。在`[0, 1]`中选择的掩码值：

    +   1 表示头部未被遮罩，

    +   0 表示头部被遮罩。

+   `decoder_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于在解码器中的注意力模块中使选定的头部失效的掩码。在`[0, 1]`中选择的掩码值：

    +   1 表示头部未被遮罩，

    +   0 表示头部被遮罩。

+   `cross_attn_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于在解码器中的交叉注意力模块中使选定的头部失效的掩码。在`[0, 1]`中选择的掩码值：

    +   1 表示头部未被遮罩。

    +   0 表示头部被遮罩。

+   `encoder_outputs`（`tuple(tuple(torch.FloatTensor)`，*可选*）- 元组包括（`last_hidden_state`，*可选*：`hidden_states`，*可选*：`attentions`）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*可选*）是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）- 长度为`config.n_layers`的元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（请参见`past_key_values`输入）。

    如果使用了`past_key_values`，用户可以选择仅输入形状为`(batch_size, 1)`的最后一个`decoder_input_ids`（那些没有将它们的过去键值状态提供给此模型的）而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

+   `inputs_embeds`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选择直接传递嵌入表示，而不是传递`input_ids`。如果您想要更多控制如何将`input_ids`索引转换为相关向量，而不是模型的内部嵌入查找矩阵，则这很有用。

+   `decoder_inputs_embeds`（形状为`(batch_size, target_sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选择直接传递嵌入表示，而不是传递`decoder_input_ids`。如果使用了`past_key_values`，则可以选择仅输入最后一个`decoder_inputs_embeds`（参见`past_key_values`）。如果您想要更多控制如何将`decoder_input_ids`索引转换为相关向量，而不是模型的内部嵌入查找矩阵，则这很有用。

    如果`decoder_input_ids`和`decoder_inputs_embeds`都未设置，则`decoder_inputs_embeds`取`inputs_embeds`的值。

+   `use_cache`（`bool`，*可选*）— 如果设置为`True`，则返回`past_key_values`键值状态，可用于加速解码（参见`past_key_values`）。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量中的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量中的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回 ModelOutput 而不是普通元组。

+   `labels`（形状为`(batch_size,)`的`torch.LongTensor`，*可选*）— 用于计算序列分类/回归损失的标签。索引应在`[0, ..., config.num_labels - 1]`范围内。如果`config.num_labels > 1`，则计算分类损失（交叉熵）。

返回

transformers.modeling_outputs.Seq2SeqSequenceClassifierOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.Seq2SeqSequenceClassifierOutput 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`时）包含根据配置（LEDConfig）和输入的不同元素。

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，当提供`label`时返回）— 分类（如果`config.num_labels==1`则为回归）损失。

+   `logits`（形状为`(batch_size, config.num_labels)`的`torch.FloatTensor`）— 分类（如果`config.num_labels==1`则为回归）得分（SoftMax 之前）。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）— 长度为`config.n_layers`的`tuple(torch.FloatTensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码。

+   `decoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出的一个+每层输出的一个）。

    解码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*） — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出的一个+每层输出的一个）。

    编码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions`（`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

LEDForSequenceClassification 的前向方法，覆盖了`__call__`特殊方法。

尽管前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者则默默地忽略它们。

单标签分类示例：

```py
>>> import torch
>>> from transformers import AutoTokenizer, LEDForSequenceClassification

>>> tokenizer = AutoTokenizer.from_pretrained("allenai/led-base-16384")
>>> model = LEDForSequenceClassification.from_pretrained("allenai/led-base-16384")

>>> inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

>>> with torch.no_grad():
...     logits = model(**inputs).logits

>>> predicted_class_id = logits.argmax().item()

>>> # To train a model on `num_labels` classes, you can pass `num_labels=num_labels` to `.from_pretrained(...)`
>>> num_labels = len(model.config.id2label)
>>> model = LEDForSequenceClassification.from_pretrained("allenai/led-base-16384", num_labels=num_labels)

>>> labels = torch.tensor([1])
>>> loss = model(**inputs, labels=labels).loss
```

多标签分类示例：

```py
>>> import torch
>>> from transformers import AutoTokenizer, LEDForSequenceClassification

>>> tokenizer = AutoTokenizer.from_pretrained("allenai/led-base-16384")
>>> model = LEDForSequenceClassification.from_pretrained("allenai/led-base-16384", problem_type="multi_label_classification")

>>> inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

>>> with torch.no_grad():
...     logits = model(**inputs).logits

>>> predicted_class_ids = torch.arange(0, logits.shape[-1])[torch.sigmoid(logits).squeeze(dim=0) > 0.5]

>>> # To train a model on `num_labels` classes, you can pass `num_labels=num_labels` to `.from_pretrained(...)`
>>> num_labels = len(model.config.id2label)
>>> model = LEDForSequenceClassification.from_pretrained(
...     "allenai/led-base-16384", num_labels=num_labels, problem_type="multi_label_classification"
... )

>>> labels = torch.sum(
...     torch.nn.functional.one_hot(predicted_class_ids[None, :].clone(), num_classes=num_labels), dim=1
... ).to(torch.float)
>>> loss = model(**inputs, labels=labels).loss
```

## LEDForQuestionAnswering

### `class transformers.LEDForQuestionAnswering`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L2627)

```py
( config )
```

参数

+   `config`（LEDConfig） — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

LED 模型顶部带有用于类似 SQuAD 的抽取式问答任务的跨度分类头（在隐藏状态输出顶部的线性层上计算`span start logits`和`span end logits`）。

此模型继承自 PreTrainedModel。请参阅超类文档，了解库为所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头部等）。

此模型也是 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) 的子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取一般用法和行为。

#### `forward`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_led.py#L2649)

```py
( input_ids: Optional = None attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None global_attention_mask: Optional = None start_positions: Optional = None end_positions: Optional = None inputs_embeds: Optional = None decoder_inputs_embeds: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqQuestionAnsweringModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为 `(batch_size, sequence_length)` 的 `torch.LongTensor`）— 词汇表中输入序列标记的索引。默认情况下会忽略填充。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

+   `attention_mask`（形状为 `(batch_size, sequence_length)` 的 `torch.Tensor`，*可选*）— 避免在填充标记索引上执行注意力的掩码。掩码值选在 `[0, 1]`：

    +   1 表示未被屏蔽的标记，

    +   0 表示被屏蔽的标记。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为 `(batch_size, target_sequence_length)` 的 `torch.LongTensor`，*可选*）— 词汇表中解码器输入序列标记的索引。

    可以使用 `LedTokenizer` 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    LED 使用 `eos_token_id` 作为 `decoder_input_ids` 生成的起始标记。如果使用 `past_key_values`，则可选择仅输入最后的 `decoder_input_ids`（参见 `past_key_values`）。

+   `decoder_attention_mask`（形状为 `(batch_size, target_sequence_length)` 的 `torch.LongTensor`，*可选*）— 默认行为：生成一个张量，忽略 `decoder_input_ids` 中的填充标记。默认情况下也会使用因果掩码。

    如果要更改填充行为，应阅读 `modeling_led._prepare_decoder_inputs` 并根据需要进行修改。有关默认策略的更多信息，请参阅 [论文](https://arxiv.org/abs/1910.13461) 中的图表 1。

+   `global_attention_mask`（形状为 `(batch_size, sequence_length)` 的 `torch.FloatTensor`，*可选*）— 决定给予每个标记的注意力，编码器的局部注意力或全局注意力。具有全局注意力的标记关注所有其他标记，所有其他标记也关注它们。这对于任务特定的微调很重要，因为它使模型在表示任务时更加灵活。例如，对于分类，应该给予全局注意力。对于问答，所有问题标记也应该具有全局注意力。有关更多详细信息，请参阅 [Longformer 论文](https://arxiv.org/abs/2004.05150)。掩码值选在 `[0, 1]`：

    +   0 表示局部注意力（滑动窗口注意力），

    +   1 表示全局注意力（关注所有其他标记，所有其他标记也关注它们）。

+   `head_mask`（形状为 `(encoder_layers, encoder_attention_heads)` 的 `torch.Tensor`，*可选*）— 在编码器中使注意力模块的选定头部失效的掩码。掩码值选在 `[0, 1]`：

    +   1 表示头部未被屏蔽，

    +   0 表示头部被屏蔽。

+   `decoder_head_mask`（`torch.Tensor`，形状为`(decoder_layers, decoder_attention_heads)`，*可选*）- 用于在解码器中使注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`中：

    +   1 表示头部未被`掩码`，

    +   0 表示头部被`掩码`。

+   `cross_attn_head_mask`（`torch.Tensor`，形状为`(decoder_layers, decoder_attention_heads)`，*可选*）- 用于在解码器中使交叉注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`中：

    +   1 表示头部未被`掩码`，

    +   0 表示头部被`掩码`。

+   `encoder_outputs`（`tuple(tuple(torch.FloatTensor)`，*可选*）- 元组包括（`last_hidden_state`，*可选*：`hidden_states`，*可选*：`attentions`）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*可选*）是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）- 长度为`config.n_layers`的`tuple(torch.FloatTensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量，以及 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码。

    如果使用了`past_key_values`，用户可以选择仅输入最后的`decoder_input_ids`（那些没有将其过去的键值状态提供给此模型的）的形状为`(batch_size, 1)`的张量，而不是所有形状为`(batch_size, sequence_length)`的`decoder_input_ids`。

+   `inputs_embeds`（`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`，*可选*）- 可选地，您可以选择直接传递嵌入表示，而不是传递`input_ids`。如果您希望更多地控制如何将`input_ids`索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，这将非常有用。

+   `decoder_inputs_embeds`（`torch.FloatTensor`，形状为`(batch_size, target_sequence_length, hidden_size)`，*可选*）- 可选地，您可以选择直接传递嵌入表示，而不是传递`decoder_input_ids`。如果使用了`past_key_values`，则可以选择仅输入最后的`decoder_inputs_embeds`（请参见`past_key_values`）。如果您希望更多地控制如何将`decoder_input_ids`索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，这将非常有用。

    如果`decoder_input_ids`和`decoder_inputs_embeds`都未设置，则`decoder_inputs_embeds`取`inputs_embeds`的值。

+   `use_cache`（`bool`，*可选*）- 如果设置为`True`，则返回`past_key_values`键值状态，并可用于加速解码（请参见`past_key_values`）。

+   `output_attentions`（`bool`，*可选*）- 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）- 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）- 是否返回一个 ModelOutput 而不是一个普通元组。

+   `start_positions`（`torch.LongTensor`，形状为`(batch_size,)`，*可选*）- 用于计算标记跨度的开始位置（索引）的标签。位置被夹紧到序列的长度（*sequence_length*）。序列外的位置不会用于计算损失。

+   `end_positions` (`torch.LongTensor` of shape `(batch_size,)`, *optional*) — 用于计算标记跨度结束位置的位置（索引）标签。位置被夹紧到序列的长度（*sequence_length*）。序列外的位置不会被考虑在内计算损失。

返回

transformers.modeling_outputs.Seq2SeqQuestionAnsweringModelOutput 或 `tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.Seq2SeqQuestionAnsweringModelOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（LEDConfig）和输入的不同元素。

+   `loss` (`torch.FloatTensor` of shape `(1,)`, *optional*, 当提供`labels`时返回) — 总跨度提取损失是开始和结束位置的交叉熵之和。

+   `start_logits` (`torch.FloatTensor` of shape `(batch_size, sequence_length)`) — 跨度开始得分（SoftMax 之前）。

+   `end_logits` (`torch.FloatTensor` of shape `(batch_size, sequence_length)`) — 跨度结束得分（SoftMax 之前）。

+   `past_key_values` (`tuple(tuple(torch.FloatTensor))`, *optional*, 当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tuple(torch.FloatTensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出的输出+每层的输出）。

    解码器在每一层的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的注意力权重，在注意力 Softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 Softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出的输出+每层的输出）。

    编码器在每一层的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(torch.FloatTensor)`, *可选*, 当传递 `output_attentions=True` 或当 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

LEDForQuestionAnswering 的前向方法，覆盖了 `__call__` 特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用 `Module` 实例，而不是在此处调用，因为前者会负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, LEDForQuestionAnswering
>>> import torch

>>> tokenizer = AutoTokenizer.from_pretrained("allenai/led-base-16384")
>>> model = LEDForQuestionAnswering.from_pretrained("allenai/led-base-16384")

>>> question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

>>> inputs = tokenizer(question, text, return_tensors="pt")
>>> with torch.no_grad():
...     outputs = model(**inputs)

>>> answer_start_index = outputs.start_logits.argmax()
>>> answer_end_index = outputs.end_logits.argmax()

>>> predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]

>>> # target is "nice puppet"
>>> target_start_index = torch.tensor([14])
>>> target_end_index = torch.tensor([15])

>>> outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
>>> loss = outputs.loss
```

TensorFlow 隐藏 TensorFlow 内容

## TFLEDModel

### `class transformers.TFLEDModel`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_tf_led.py#L2342)

```py
( config *inputs **kwargs )
```

参数

+   `config` (LEDConfig) — 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只会加载配置。查看 from_pretrained() 方法以加载模型权重。

裸 LED 模型输出原始隐藏状态，没有特定的头部。此模型继承自 TFPreTrainedModel。查看超类文档，了解库为其所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头等）。

此模型也是 [tf.keras.Model](https://www.tensorflow.org/api_docs/python/tf/keras/Model) 的子类。将其用作常规的 TF 2.0 Keras 模型，并参考 TF 2.0 文档以获取有关一般用法和行为的所有相关信息。

`transformers` 中的 TensorFlow 模型和层接受两种格式的输入：

+   将所有输入作为关键字参数（类似于 PyTorch 模型），或

+   将所有输入作为列表、元组或字典放在第一个位置参数中。

支持第二种格式的原因是，Keras 方法在将输入传递给模型和层时更喜欢这种格式。由于这种支持，当使用 `model.fit()` 等方法时，您应该可以“轻松使用” - 只需传递您的输入和标签，以任何 `model.fit()` 支持的格式！但是，如果您想在 Keras 方法之外使用第二种格式，比如在使用 Keras `Functional` API 创建自己的层或模型时，有三种可能性可以用来收集第一个位置参数中的所有输入张量：

+   只有一个包含 `input_ids` 的张量，没有其他内容：`model(input_ids)`

+   一个长度可变的列表，其中包含一个或多个输入张量，按照文档字符串中给出的顺序：`model([input_ids, attention_mask])` 或 `model([input_ids, attention_mask, token_type_ids])`

+   一个包含一个或多个与文档字符串中给出的输入名称相关联的输入张量的字典：`model({"input_ids": input_ids, "token_type_ids": token_type_ids})`

请注意，当使用 [子类化](https://keras.io/guides/making_new_layers_and_models_via_subclassing/) 创建模型和层时，您无需担心任何这些，因为您可以像对待任何其他 Python 函数一样传递输入！

#### `call`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_tf_led.py#L2358)

```py
( input_ids: TFModelInputType | None = None attention_mask: tf.Tensor | None = None decoder_input_ids: tf.Tensor | None = None decoder_attention_mask: tf.Tensor | None = None head_mask: tf.Tensor | None = None decoder_head_mask: tf.Tensor | None = None encoder_outputs: tf.Tensor | None = None global_attention_mask: tf.Tensor | None = None past_key_values: Tuple[Tuple[tf.Tensor]] | None = None inputs_embeds: tf.Tensor | None = None decoder_inputs_embeds: tf.Tensor | None = None use_cache: bool | None = None output_attentions: bool | None = None output_hidden_states: bool | None = None return_dict: bool | None = None training: bool = False **kwargs ) → export const metadata = 'undefined';transformers.models.led.modeling_tf_led.TFLEDSeq2SeqModelOutput or tuple(tf.Tensor)
```

参数

+   `input_ids` (`tf.Tensor`，形状为 `(batch_size, sequence_length)`) — 词汇表中输入序列标记的索引。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`tf.Tensor`，*可选*）— 用于避免在填充标记索引上执行注意力的遮罩。在`[0, 1]`中选择的遮罩值：

    +   1 表示未被遮罩的标记，

    +   0 表示被遮罩的标记。

    什么是注意力遮罩？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`tf.Tensor`，*可选*）— 词汇表中解码器输入序列标记的索引。

    可以使用`LedTokenizer`获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    LED 使用`eos_token_id`作为`decoder_input_ids`生成的起始标记。如果使用`past_key_values`，则只需输入最后的`decoder_input_ids`（参见`past_key_values`）。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`tf.Tensor`，*可选*）— 默认情况下将忽略填充标记并生成。不建议为大多数用例设置此选项。

+   `head_mask`（形状为`(encoder_layers, encoder_attention_heads)`的`tf.Tensor`，*可选*）— 用于在编码器中使注意力模块中的选定头部失效的遮罩。在`[0, 1]`中选择的遮罩值：

    +   1 表示头部未被遮罩，

    +   0 表示头部被遮罩。

+   `decoder_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`tf.Tensor`，*可选*）— 用于在解码器中使注意力模块中的选定头部失效的遮罩。在`[0, 1]`中选择的遮罩值：

    +   1 表示头部未被遮罩，

    +   0 表示头部被遮罩，

+   `encoder_outputs`（`tf.Tensor`，*可选*）— 编码器最后一层的隐藏状态的输出。在解码器的交叉注意力中使用。形状为`(batch_size, sequence_length, hidden_size)`的序列是

+   `past_key_values`（长度为`config.n_layers`的`Tuple[Tuple[tf.Tensor]]`）— 包含注意力块的预计算键和值隐藏状态。可用于加速解码。如果使用`past_key_values`，用户可以选择仅输入最后的`decoder_input_ids`（即未将其过去的键值状态提供给此模型的那些）的形状为`(batch_size, 1)`的张量，而不是所有形状为`(batch_size, sequence_length)`的`decoder_input_ids`。

+   `use_cache`（`bool`，*可选*，默认为`True`）— 如果设置为`True`，将返回`past_key_values`键值状态，并可用于加速解码（参见`past_key_values`）。在训练期间设置为`False`，在生成期间设置为`True`。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。此参数仅在急切模式下使用，在图模式下，将使用配置中的值。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。此参数仅在急切模式下使用，在图模式下，将使用配置中的值。

+   `return_dict`（`bool`，*可选*）— 是否返回 ModelOutput 而不是普通元组。此参数可在急切模式下使用，在图模式下，该值将始终设置为 True。

+   `training` (`bool`，*optional*，默认为 `False`) — 是否在训练模式下使用模型（一些模块如 dropout 模块在训练和评估之间有不同的行为）。

返回

transformers.models.led.modeling_tf_led.TFLEDSeq2SeqModelOutput 或 `tuple(tf.Tensor)`

一个 transformers.models.led.modeling_tf_led.TFLEDSeq2SeqModelOutput 或一个 `tf.Tensor` 元组（如果传递了 `return_dict=False` 或当 `config.return_dict=False` 时）包含根据配置（LEDConfig）和输入而异的各种元素。

+   `last_hidden_state` (`tf.Tensor`，形状为 `(batch_size, sequence_length, hidden_size)`) — 模型解码器最后一层的隐藏状态序列。

    如果仅使用 `past_key_values`，则输出形状为 `(batch_size, 1, hidden_size)` 的序列的最后一个隐藏状态。

+   `past_key_values` (`List[tf.Tensor]`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`) — 长度为 `config.n_layers` 的 `tf.Tensor` 列表，每个张量的形状为 `(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预计算隐藏状态（注意力块中的键和值），可用于加速顺序解码（参见 `past_key_values` 输入）。

+   `decoder_hidden_states` (`tuple(tf.Tensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`) — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `tf.Tensor` 元组（一个用于嵌入输出，一个用于每一层的输出）。

    解码器在每一层的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(tf.Tensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `tf.Tensor` 元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(tf.Tensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `tf.Tensor` 元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`tf.Tensor`，形状为 `(batch_size, sequence_length, hidden_size)`，*optional*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(tf.Tensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`) — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `tf.Tensor` 元组（一个用于嵌入输出，一个用于每一层的输出）。

    编码器在每一层的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(tf.Tensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `tf.Tensor` 元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `encoder_global_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, x)`的`tf.Tensor`元组，其中`x`是具有全局注意掩码的令牌数。

    在注意力 softmax 之后的全局注意力权重，用于计算自注意力头中的加权平均值。这些是来自具有全局注意力的每个令牌到序列中每个令牌的注意力权重。

TFLEDModel 的前向方法覆盖了`__call__`特殊方法。

虽然前向传递的方法需要在此函数内定义，但应该在此之后调用`Module`实例，而不是调用此函数，因为前者会负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, TFLEDModel
>>> import tensorflow as tf

>>> tokenizer = AutoTokenizer.from_pretrained("allenai/led-base-16384")
>>> model = TFLEDModel.from_pretrained("allenai/led-base-16384")

>>> inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
>>> outputs = model(inputs)

>>> last_hidden_states = outputs.last_hidden_state
```

## TFLEDForConditionalGeneration

### `class transformers.TFLEDForConditionalGeneration`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_tf_led.py#L2454)

```py
( config *inputs **kwargs )
```

参数

+   `config`（LEDConfig）- 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

具有语言建模头的 LED 模型。可用于摘要。此模型继承自 TFPreTrainedModel。查看超类文档以了解库为其所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头等）。

此模型还是一个[tf.keras.Model](https://www.tensorflow.org/api_docs/python/tf/keras/Model)子类。将其用作常规的 TF 2.0 Keras 模型，并参考 TF 2.0 文档以获取与一般用法和行为相关的所有信息。

`transformers`中的 TensorFlow 模型和层接受两种格式的输入：

+   将所有输入作为关键字参数（类似于 PyTorch 模型），

+   将所有输入作为列表、元组或字典放在第一个位置参数中。

支持第二种格式的原因是，Keras 方法在将输入传递给模型和层时更喜欢这种格式。由于有了这种支持，当使用`model.fit()`等方法时，应该可以“正常工作” - 只需传递您的输入和标签以任何`model.fit()`支持的格式！但是，如果您想在 Keras 方法之外使用第二种格式，比如在使用 Keras `Functional` API 创建自己的层或模型时，有三种可能性可以用来收集第一个位置参数中的所有输入张量：

+   只有一个包含`input_ids`的张量，没有其他内容：`model(input_ids)`

+   一个长度可变的列表，其中包含一个或多个按照文档字符串中给定的顺序的输入张量：`model([input_ids, attention_mask])`或`model([input_ids, attention_mask, token_type_ids])`

+   一个字典，其中包含一个或多个与文档字符串中给定的输入名称相关联的输入张量：`model({"input_ids": input_ids, "token_type_ids": token_type_ids})`

请注意，当使用[子类化](https://keras.io/guides/making_new_layers_and_models_via_subclassing/)创建模型和层时，您无需担心任何这些，因为您可以像对待任何其他 Python 函数一样传递输入！

#### `call`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/led/modeling_tf_led.py#L2499)

```py
( input_ids: TFModelInputType | None = None attention_mask: np.ndarray | tf.Tensor | None = None decoder_input_ids: np.ndarray | tf.Tensor | None = None decoder_attention_mask: np.ndarray | tf.Tensor | None = None head_mask: np.ndarray | tf.Tensor | None = None decoder_head_mask: np.ndarray | tf.Tensor | None = None encoder_outputs: TFLEDEncoderBaseModelOutput | None = None global_attention_mask: np.ndarray | tf.Tensor | None = None past_key_values: Tuple[Tuple[Union[np.ndarray, tf.Tensor]]] | None = None inputs_embeds: np.ndarray | tf.Tensor | None = None decoder_inputs_embeds: np.ndarray | tf.Tensor | None = None use_cache: bool | None = None output_attentions: bool | None = None output_hidden_states: bool | None = None return_dict: bool | None = None labels: tf.Tensor | None = None training: bool = False ) → export const metadata = 'undefined';transformers.models.led.modeling_tf_led.TFLEDSeq2SeqLMOutput or tuple(tf.Tensor)
```

参数

+   `input_ids`（形状为`({0})`的`tf.Tensor`）- 词汇表中输入序列标记的索引。

    可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

+   `attention_mask`（形状为`({0})`的`tf.Tensor`，*可选*）- 用于避免在填充标记索引上执行注意力的掩码。选择的掩码值为`[0, 1]`：

    +   1 用于未被“掩码”的标记，

    +   0 用于被“掩码”的标记。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`tf.Tensor`，*可选*）- 词汇表中解码器输入序列标记的索引。

    可以使用`LedTokenizer`获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是输入 ID？

    LED 使用`eos_token_id`作为`decoder_input_ids`生成的起始标记。如果使用了`past_key_values`，则可选择仅输入最后的`decoder_input_ids`（参见`past_key_values`）。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`tf.Tensor`，*可选*）- 将默认生成并忽略填充标记。不建议为大多数用例设置此项。

+   `head_mask`（形状为`(encoder_layers, encoder_attention_heads)`的`tf.Tensor`，*可选*）- 用于使编码器中的注意力模块中的选定头部无效的掩码。选择的掩码值为`[0, 1]`：

    +   1 表示头部未被“掩码”，

    +   0 表示头部被“掩码”。

+   `decoder_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`tf.Tensor`，*可选*）- 用于使解码器中的注意力模块中的选定头部无效的掩码。选择的掩码值为`[0, 1]`：

    +   1 表示头部未被“掩码”，

    +   0 表示头部被“掩码”。

+   `encoder_outputs`（`tf.Tensor`，*可选*）- 编码器最后一层的隐藏状态输出。用于解码器的交叉注意力。形状为`(batch_size, sequence_length, hidden_size)`的序列是

+   `past_key_values`（长度为`config.n_layers`的`Tuple[Tuple[tf.Tensor]]`）- 包含预先计算的注意力块的键和值隐藏状态。可用于加速解码。如果使用了`past_key_values`，用户可以选择仅输入最后的`decoder_input_ids`（即未将其过去的键值状态提供给此模型的那些）的形状为`(batch_size, 1)`的张量，而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

+   `use_cache`（`bool`，*可选*，默认为`True`）- 如果设置为`True`，将返回`past_key_values`键值状态，并可用于加速解码（参见`past_key_values`）。在训练期间设置为`False`，在生成期间设置为`True`。

+   `output_attentions`（`bool`，*可选*）- 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。此参数仅可在急切模式下使用，在图模式中将使用配置中的值。

+   `output_hidden_states`（`bool`，*可选*）- 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。此参数仅可在急切模式下使用，在图模式中将使用配置中的值。

+   `return_dict`（`bool`，*可选*）- 是否返回 ModelOutput 而不是普通元组。此参数可在急切模式下使用，在图模式中该值将始终设置为 True。

+   `training` (`bool`, *可选*, 默认为`False`) — 是否在训练模式下使用模型（一些模块如 dropout 模块在训练和评估之间有不同的行为）。

返回

transformers.models.led.modeling_tf_led.TFLEDSeq2SeqLMOutput 或 `tuple(tf.Tensor)`

transformers.models.led.modeling_tf_led.TFLEDSeq2SeqLMOutput 或 `tf.Tensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包括不同元素，取决于配置（LEDConfig）和输入。

+   `loss` (`形状为`(1,)`的`tf.Tensor`, *可选*, 当提供`labels`时返回) — 语言建模损失。

+   `logits` (`形状为`(batch_size, sequence_length, config.vocab_size)`的`tf.Tensor`) — 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values` (`List[tf.Tensor]`, *可选*, 当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tf.Tensor`列表，每个张量的形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预先计算的隐藏状态（注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states` (`tuple(tf.Tensor)`, *可选*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入输出，一个用于每一层的输出）。

    解码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(tf.Tensor)`, *可选*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(tf.Tensor)`, *可选*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`, *可选*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(tf.Tensor)`, *可选*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入输出，一个用于每一层的输出）。

    编码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(tf.Tensor)`, *可选*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `encoder_global_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, x)`的`tf.Tensor`元组（每层一个），其中`x`是具有全局注意力掩码的令牌数。

    在注意力 softmax 之后的全局注意力权重，用于计算自注意力头中的加权平均值。这些是来自每个令牌的注意力权重，对序列中的每个令牌进行全局注意力。

TFLEDForConditionalGeneration 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者负责运行前处理和后处理步骤，而后者则会默默地忽略它们。

示例：

```py
>>> from transformers import AutoTokenizer, TFLEDForConditionalGeneration
>>> import tensorflow as tf

>>> mname = "allenai/led-base-16384"
>>> tokenizer = AutoTokenizer.from_pretrained(mname)
>>> TXT = "My friends are <mask> but they eat too many carbs."
>>> model = TFLEDForConditionalGeneration.from_pretrained(mname)
>>> batch = tokenizer([TXT], return_tensors="tf")
>>> logits = model(inputs=batch.input_ids).logits
>>> probs = tf.nn.softmax(logits[0])
>>> # probs[5] is associated with the mask token
```
