["```py\n( num_train_timesteps: int = 1000 beta_start: float = 0.0001 beta_end: float = 0.02 beta_schedule: str = 'linear' trained_betas: Union = None prediction_type: str = 'epsilon' interpolation_type: str = 'linear' use_karras_sigmas: Optional = False sigma_min: Optional = None sigma_max: Optional = None timestep_spacing: str = 'linspace' timestep_type: str = 'discrete' steps_offset: int = 0 rescale_betas_zero_snr: bool = False )\n```", "```py\n( sample: FloatTensor timestep: Union ) \u2192 export const metadata = 'undefined';torch.FloatTensor\n```", "```py\n( num_inference_steps: int device: Union = None )\n```", "```py\n( model_output: FloatTensor timestep: Union sample: FloatTensor s_churn: float = 0.0 s_tmin: float = 0.0 s_tmax: float = inf s_noise: float = 1.0 generator: Optional = None return_dict: bool = True ) \u2192 export const metadata = 'undefined';EulerDiscreteSchedulerOutput or tuple\n```", "```py\n( prev_sample: FloatTensor pred_original_sample: Optional = None )\n```"]