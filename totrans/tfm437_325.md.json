["```py\n>>> from transformers import Wav2Vec2ConformerConfig, Wav2Vec2ConformerModel\n\n>>> # Initializing a Wav2Vec2Conformer facebook/wav2vec2-conformer-rel-pos-large style configuration\n>>> configuration = Wav2Vec2ConformerConfig()\n\n>>> # Initializing a model (with random weights) from the facebook/wav2vec2-conformer-rel-pos-large style configuration\n>>> model = Wav2Vec2ConformerModel(configuration)\n\n>>> # Accessing the model configuration\n>>> configuration = model.config\n```", "```py\n>>> from transformers import AutoProcessor, Wav2Vec2ConformerModel\n>>> import torch\n>>> from datasets import load_dataset\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> processor = AutoProcessor.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n>>> model = Wav2Vec2ConformerModel.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = processor(dataset[0][\"audio\"][\"array\"], sampling_rate=sampling_rate, return_tensors=\"pt\")\n>>> with torch.no_grad():\n...     outputs = model(**inputs)\n\n>>> last_hidden_states = outputs.last_hidden_state\n>>> list(last_hidden_states.shape)\n[1, 292, 1024]\n```", "```py\n>>> from transformers import AutoProcessor, Wav2Vec2ConformerForCTC\n>>> from datasets import load_dataset\n>>> import torch\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> processor = AutoProcessor.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n>>> model = Wav2Vec2ConformerForCTC.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = processor(dataset[0][\"audio\"][\"array\"], sampling_rate=sampling_rate, return_tensors=\"pt\")\n>>> with torch.no_grad():\n...     logits = model(**inputs).logits\n>>> predicted_ids = torch.argmax(logits, dim=-1)\n\n>>> # transcribe speech\n>>> transcription = processor.batch_decode(predicted_ids)\n>>> transcription[0]\n'MISTER QUILTER IS THE APOSTLE OF THE MIDDLE CLASSES AND WE ARE GLAD TO WELCOME HIS GOSPEL'\n\n>>> inputs[\"labels\"] = processor(text=dataset[0][\"text\"], return_tensors=\"pt\").input_ids\n\n>>> # compute loss\n>>> loss = model(**inputs).loss\n>>> round(loss.item(), 2)\n64.21\n```", "```py\n>>> from transformers import AutoFeatureExtractor, Wav2Vec2ConformerForSequenceClassification\n>>> from datasets import load_dataset\n>>> import torch\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> feature_extractor = AutoFeatureExtractor.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n>>> model = Wav2Vec2ConformerForSequenceClassification.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = feature_extractor(dataset[0][\"audio\"][\"array\"], sampling_rate=sampling_rate, return_tensors=\"pt\")\n\n>>> with torch.no_grad():\n...     logits = model(**inputs).logits\n\n>>> predicted_class_ids = torch.argmax(logits, dim=-1).item()\n>>> predicted_label = model.config.id2label[predicted_class_ids]\n\n>>> # compute loss - target_label is e.g. \"down\"\n>>> target_label = model.config.id2label[0]\n>>> inputs[\"labels\"] = torch.tensor([model.config.label2id[target_label]])\n>>> loss = model(**inputs).loss\n```", "```py\n>>> from transformers import AutoFeatureExtractor, Wav2Vec2ConformerForAudioFrameClassification\n>>> from datasets import load_dataset\n>>> import torch\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> feature_extractor = AutoFeatureExtractor.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n>>> model = Wav2Vec2ConformerForAudioFrameClassification.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = feature_extractor(dataset[0][\"audio\"][\"array\"], return_tensors=\"pt\", sampling_rate=sampling_rate)\n>>> with torch.no_grad():\n...     logits = model(**inputs).logits\n\n>>> probabilities = torch.sigmoid(logits[0])\n>>> # labels is a one-hot array of shape (num_frames, num_speakers)\n>>> labels = (probabilities > 0.5).long()\n```", "```py\n>>> from transformers import AutoFeatureExtractor, Wav2Vec2ConformerForXVector\n>>> from datasets import load_dataset\n>>> import torch\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> feature_extractor = AutoFeatureExtractor.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n>>> model = Wav2Vec2ConformerForXVector.from_pretrained(\"facebook/wav2vec2-conformer-rope-large-960h-ft\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = feature_extractor(\n...     [d[\"array\"] for d in dataset[:2][\"audio\"]], sampling_rate=sampling_rate, return_tensors=\"pt\", padding=True\n... )\n>>> with torch.no_grad():\n...     embeddings = model(**inputs).embeddings\n\n>>> embeddings = torch.nn.functional.normalize(embeddings, dim=-1).cpu()\n\n>>> # the resulting embeddings can be used for cosine similarity-based retrieval\n>>> cosine_sim = torch.nn.CosineSimilarity(dim=-1)\n>>> similarity = cosine_sim(embeddings[0], embeddings[1])\n>>> threshold = 0.7  # the optimal threshold is dataset-dependent\n>>> if similarity < threshold:\n...     print(\"Speakers are not the same!\")\n```", "```py\n>>> import torch\n>>> from transformers import AutoFeatureExtractor, Wav2Vec2ConformerForPreTraining\n>>> from transformers.models.wav2vec2_conformer.modeling_wav2vec2_conformer import _compute_mask_indices, _sample_negative_indices\n>>> from datasets import load_dataset\n\n>>> feature_extractor = AutoFeatureExtractor.from_pretrained(\"facebook/wav2vec2-conformer-rel-pos-large\")\n>>> model = Wav2Vec2ConformerForPreTraining.from_pretrained(\"facebook/wav2vec2-conformer-rel-pos-large\")\n\n>>> ds = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\n>>> input_values = feature_extractor(ds[0][\"audio\"][\"array\"], return_tensors=\"pt\").input_values  # Batch size 1\n\n>>> # compute masked indices\n>>> batch_size, raw_sequence_length = input_values.shape\n>>> sequence_length = model._get_feat_extract_output_lengths(raw_sequence_length).item()\n>>> mask_time_indices = _compute_mask_indices(\n...     shape=(batch_size, sequence_length), mask_prob=0.2, mask_length=2\n... )\n>>> sampled_negative_indices = _sample_negative_indices(\n...     features_shape=(batch_size, sequence_length),\n...     num_negatives=model.config.num_negatives,\n...     mask_time_indices=mask_time_indices,\n... )\n>>> mask_time_indices = torch.tensor(data=mask_time_indices, device=input_values.device, dtype=torch.long)\n>>> sampled_negative_indices = torch.tensor(\n...     data=sampled_negative_indices, device=input_values.device, dtype=torch.long\n... )\n\n>>> with torch.no_grad():\n...     outputs = model(input_values, mask_time_indices=mask_time_indices)\n\n>>> # compute cosine similarity between predicted (=projected_states) and target (=projected_quantized_states)\n>>> cosine_sim = torch.cosine_similarity(outputs.projected_states, outputs.projected_quantized_states, dim=-1)\n\n>>> # show that cosine similarity is much higher than random\n>>> cosine_sim[mask_time_indices.to(torch.bool)].mean() > 0.5\ntensor(True)\n\n>>> # for contrastive loss training model should be put into train mode\n>>> model = model.train()\n>>> loss = model(\n...     input_values, mask_time_indices=mask_time_indices, sampled_negative_indices=sampled_negative_indices\n... ).loss\n```"]