["```py\n( cpu: bool = False **kwargs )\n```", "```py\n( )\n```", "```py\n>>> from accelerate.state import PartialState\n\n>>> state = PartialState()\n>>> with state.local_main_process_first():\n...     # This will be printed first by local process 0 then in a seemingly\n...     # random order by the other processes.\n...     print(f\"This will be printed by process {state.local_process_index}\")\n```", "```py\n( )\n```", "```py\n>>> from accelerate import Accelerator\n\n>>> accelerator = Accelerator()\n>>> with accelerator.main_process_first():\n...     # This will be printed first by process 0 then in a seemingly\n...     # random order by the other processes.\n...     print(f\"This will be printed by process {accelerator.process_index}\")\n```", "```py\n( function: Callable[..., Any] )\n```", "```py\n# Assume we have 4 processes.\nfrom accelerate.state import PartialState\n\nstate = PartialState()\n\n@state.on_last_process\ndef print_something():\n    print(f\"Printed on process {state.process_index}\")\n\nprint_something()\n\"Printed on process 3\"\n```", "```py\n( function: Callable[..., Any] = None )\n```", "```py\n# Assume we have 2 servers with 4 processes each.\nfrom accelerate.state import PartialState\n\nstate = PartialState()\n\n@state.on_local_main_process\ndef print_something():\n    print(\"This will be printed by process 0 only on each server.\")\n\nprint_something()\n# On server 1:\n\"This will be printed by process 0 only\"\n# On server 2:\n\"This will be printed by process 0 only\"\n```", "```py\n( function: Callable[..., Any] = None local_process_index: int = None )\n```", "```py\n# Assume we have 2 servers with 4 processes each.\nfrom accelerate import Accelerator\n\naccelerator = Accelerator()\n\n@accelerator.on_local_process(local_process_index=2)\ndef print_something():\n    print(f\"Printed on process {accelerator.local_process_index}\")\n\nprint_something()\n# On server 1:\n\"Printed on process 2\"\n# On server 2:\n\"Printed on process 2\"\n```", "```py\n( function: Callable[..., Any] = None )\n```", "```py\n>>> from accelerate.state import PartialState\n\n>>> state = PartialState()\n\n>>> @state.on_main_process\n... def print_something():\n...     print(\"This will be printed by process 0 only.\")\n\n>>> print_something()\n\"This will be printed by process 0 only\"\n```", "```py\n( function: Callable[..., Any] = None process_index: int = None )\n```", "```py\n# Assume we have 4 processes.\nfrom accelerate.state import PartialState\n\nstate = PartialState()\n\n@state.on_process(process_index=2)\ndef print_something():\n    print(f\"Printed on process {state.process_index}\")\n\nprint_something()\n\"Printed on process 2\"\n```", "```py\n( inputs: list | tuple | dict | torch.Tensor apply_padding: bool = False )\n```", "```py\n# Assume there are two processes\nfrom accelerate import PartialState\n\nstate = PartialState()\nwith state.split_between_processes([\"A\", \"B\", \"C\"]) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\"]\n\nwith state.split_between_processes([\"A\", \"B\", \"C\"], apply_padding=True) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\", \"C\"]\n```", "```py\n( )\n```", "```py\n>>> # Assuming two GPU processes\n>>> import time\n>>> from accelerate.state import PartialState\n\n>>> state = PartialState()\n>>> if state.is_main_process:\n...     time.sleep(2)\n>>> else:\n...     print(\"I'm waiting for the main process to finish its sleep...\")\n>>> state.wait_for_everyone()\n>>> # Should print on every process at the same time\n>>> print(\"Everyone is here\")\n```", "```py\n( mixed_precision: str = None cpu: bool = False dynamo_plugin = None deepspeed_plugin = None fsdp_plugin = None megatron_lm_plugin = None _from_accelerator: bool = False **kwargs )\n```", "```py\n( )\n```", "```py\n( )\n```", "```py\n( inputs: list | tuple | dict | torch.Tensor apply_padding: bool = False )\n```", "```py\n# Assume there are two processes\nfrom accelerate.state import AcceleratorState\n\nstate = AcceleratorState()\nwith state.split_between_processes([\"A\", \"B\", \"C\"]) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\"]\n\nwith state.split_between_processes([\"A\", \"B\", \"C\"], apply_padding=True) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\", \"C\"]\n```", "```py\n( gradient_accumulation_plugin: Optional[GradientAccumulationPlugin] = None )\n```"]