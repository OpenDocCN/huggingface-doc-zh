# OWLv2

> 原始文本：[`huggingface.co/docs/transformers/v4.37.2/en/model_doc/owlv2`](https://huggingface.co/docs/transformers/v4.37.2/en/model_doc/owlv2)

## 概述

OWLv2 是由 Matthias Minderer、Alexey Gritsenko 和 Neil Houlsby 在[《扩展开放词汇目标检测》](https://arxiv.org/abs/2306.09683)中提出的。OWLv2 通过自训练扩展了 OWL-ViT，利用现有的检测器在图像-文本对上生成伪框注释。这导致在零样本目标检测方面取得了比先前最先进技术的巨大进展。

该论文的摘要如下：

*开放词汇目标检测受益于预训练的视觉语言模型，但仍受到可用检测训练数据量的限制。虽然可以通过使用 Web 图像-文本对作为弱监督来扩展检测训练数据，但这在可比较于图像级预训练的规模上尚未实现。在这里，我们通过自训练扩展检测数据，利用现有的检测器在图像-文本对上生成伪框注释。在扩展自训练中的主要挑战是标签空间的选择、伪注释过滤和训练效率。我们提出了 OWLv2 模型和 OWL-ST 自训练配方，以解决这些挑战。OWLv2 在可比较的训练规模下（约 1000 万个示例）已经超越了先前最先进的开放词汇检测器的性能。然而，通过 OWL-ST，我们可以扩展到超过 10 亿个示例，进一步取得了巨大的改进：在 L/14 架构下，OWL-ST 将 LVIS 稀有类别的 AP 从 31.2%提高到 44.6%（相对改进 43%）。OWL-ST 为开放世界定位解锁了 Web 规模的训练，类似于图像分类和语言建模所见到的情况。*

![drawing](img/66332976ce32b94eca100b548d25f741.png) OWLv2 高层次概述。摘自[原始论文](https://arxiv.org/abs/2306.09683)。

该模型由[nielsr](https://huggingface.co/nielsr)贡献。原始代码可以在[这里](https://github.com/google-research/scenic/tree/main/scenic/projects/owl_vit)找到。

## 用法示例

OWLv2 就像其前身 OWL-ViT 一样，是一个零样本文本条件的目标检测模型。OWL-ViT 使用 CLIP 作为其多模态骨干，具有类似 ViT 的 Transformer 来获取视觉特征和因果语言模型来获取文本特征。为了将 CLIP 用于检测，OWL-ViT 移除了视觉模型的最终标记池化层，并将轻量级分类和框头附加到每个 Transformer 输出标记上。通过用从文本模型获得的类名嵌入替换固定的分类层权重，实现了开放词汇分类。作者首先从头开始训练 CLIP，然后使用二部匹配损失在标准检测数据集上端到端地微调它，包括分类和框头。每个图像可以使用一个或多个文本查询来执行零样本文本条件的目标检测。

Owlv2ImageProcessor 可用于调整（或重新缩放）和规范化模型的图像，而 CLIPTokenizer 用于编码文本。Owlv2Processor 将 Owlv2ImageProcessor 和 CLIPTokenizer 包装成单个实例，以便同时编码文本和准备图像。以下示例展示了如何使用 Owlv2Processor 和 Owlv2ForObjectDetection 执行目标检测。

```py
>>> import requests
>>> from PIL import Image
>>> import torch

>>> from transformers import Owlv2Processor, Owlv2ForObjectDetection

>>> processor = Owlv2Processor.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> model = Owlv2ForObjectDetection.from_pretrained("google/owlv2-base-patch16-ensemble")

>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> texts = [["a photo of a cat", "a photo of a dog"]]
>>> inputs = processor(text=texts, images=image, return_tensors="pt")
>>> outputs = model(**inputs)

>>> # Target image sizes (height, width) to rescale box predictions [batch_size, 2]
>>> target_sizes = torch.Tensor([image.size[::-1]])
>>> # Convert outputs (bounding boxes and class logits) to Pascal VOC Format (xmin, ymin, xmax, ymax)
>>> results = processor.post_process_object_detection(outputs=outputs, target_sizes=target_sizes, threshold=0.1)
>>> i = 0  # Retrieve predictions for the first image for the corresponding text queries
>>> text = texts[i]
>>> boxes, scores, labels = results[i]["boxes"], results[i]["scores"], results[i]["labels"]
>>> for box, score, label in zip(boxes, scores, labels):
...     box = [round(i, 2) for i in box.tolist()]
...     print(f"Detected {text[label]} with confidence {round(score.item(), 3)} at location {box}")
Detected a photo of a cat with confidence 0.614 at location [341.67, 17.54, 642.32, 278.51]
Detected a photo of a cat with confidence 0.665 at location [6.75, 38.97, 326.62, 354.85]
```

## 资源

+   可以在[这里](https://github.com/NielsRogge/Transformers-Tutorials/tree/master/OWLv2)找到使用 OWLv2 进行零样本和一次性（图像引导）目标检测的演示笔记本。

+   零样本目标检测任务指南

OWLv2 的架构与 OWL-ViT 相同，但是目标检测头现在还包括一个物体性分类器，用于预测（与查询无关的）预测框包含物体（而不是背景）的可能性。物体性分数可用于独立于文本查询对预测进行排名或过滤。使用 OWLv2 与 OWL-ViT 相同，但使用新的、更新的图像处理器(Owlv2ImageProcessor)。

## Owlv2Config

### `class transformers.Owlv2Config`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/configuration_owlv2.py#L256)

```py
( text_config = None vision_config = None projection_dim = 512 logit_scale_init_value = 2.6592 return_dict = True **kwargs )
```

参数

+   `text_config` (`dict`, *可选*) — 用于初始化 Owlv2TextConfig 的配置选项字典。

+   `vision_config` (`dict`, *可选*) — 用于初始化 Owlv2VisionConfig 的配置选项字典。

+   `projection_dim` (`int`, *可选*, 默认为 512) — 文本和视觉投影层的维度。

+   `logit_scale_init_value` (`float`, *可选*, 默认为 2.6592) — *logit_scale* 参数的初始值。默认值与原始 OWLv2 实现相同。

+   `return_dict` (`bool`, *可选*, 默认为 `True`) — 模型是否应返回一个字典。如果为 `False`，则返回一个元组。

+   `kwargs` (*可选*) — 关键字参数的字典。

Owlv2Config 是存储 Owlv2Model 配置的配置类。它用于根据指定的参数实例化一个 OWLv2 模型，定义文本模型和视觉模型配置。使用默认值实例化配置将产生类似于 OWLv2 [google/owlv2-base-patch16](https://huggingface.co/google/owlv2-base-patch16) 架构的配置。

配置对象继承自 PretrainedConfig ，可用于控制模型输出。阅读来自 PretrainedConfig 的文档以获取更多信息。

#### `from_text_vision_configs`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/configuration_owlv2.py#L325)

```py
( text_config: Dict vision_config: Dict **kwargs ) → export const metadata = 'undefined';Owlv2Config
```

返回

Owlv2Config

配置对象的实例

从 owlv2 文本模型配置和 owlv2 视觉模型配置实例化一个 Owlv2Config（或派生类）。

## Owlv2TextConfig

### `class transformers.Owlv2TextConfig`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/configuration_owlv2.py#L36)

```py
( vocab_size = 49408 hidden_size = 512 intermediate_size = 2048 num_hidden_layers = 12 num_attention_heads = 8 max_position_embeddings = 16 hidden_act = 'quick_gelu' layer_norm_eps = 1e-05 attention_dropout = 0.0 initializer_range = 0.02 initializer_factor = 1.0 pad_token_id = 0 bos_token_id = 49406 eos_token_id = 49407 **kwargs )
```

参数

+   `vocab_size` (`int`, *optional*, defaults to 49408) — OWLv2 文本模型的词汇量。定义了在调用 Owlv2TextModel 时可以表示的不同标记的数量。

+   `hidden_size` (`int`, *optional*, defaults to 512) — 编码器层和池化器层的维度。

+   `intermediate_size` (`int`, *optional*, defaults to 2048) — Transformer 编码器中“中间”（即前馈）层的维度。

+   `num_hidden_layers` (`int`, *optional*, defaults to 12) — Transformer 编码器中的隐藏层数。

+   `num_attention_heads` (`int`, *optional*, defaults to 8) — Transformer 编码器中每个注意力层的注意力头数。

+   `max_position_embeddings` (`int`, *optional*, defaults to 16) — 该模型可能使用的最大序列长度。通常将其设置为较大的值以防万一（例如 512、1024 或 2048）。

+   `hidden_act` (`str` or `function`, *optional*, defaults to `"quick_gelu"`) — 编码器和池化器中的非线性激活函数（函数或字符串）。如果是字符串，支持`"gelu"`、`"relu"`、`"selu"`和`"gelu_new"`以及`"quick_gelu"`。

+   `layer_norm_eps` (`float`, *optional*, defaults to 1e-05) — 层归一化层使用的 epsilon。

+   `attention_dropout` (`float`, *optional*, defaults to 0.0) — 注意力概率的丢弃比率。

+   `initializer_range` (`float`, *optional*, defaults to 0.02) — 用于初始化所有权重矩阵的截断正态初始化器的标准差。

+   `initializer_factor` (`float`, *optional*, defaults to 1.0) — 用于初始化所有权重矩阵的因子（应保持为 1，用于内部初始化测试）。

+   `pad_token_id` (`int`, *optional*, defaults to 0) — 输入序列中填充标记的 id。

+   `bos_token_id` (`int`, *optional*, defaults to 49406) — 输入序列中序列开始标记的 id。

+   `eos_token_id` (`int`, *optional*, defaults to 49407) — 输入序列中序列结束标记的 id。

这是用于存储 Owlv2TextModel 配置的配置类。根据指定的参数实例化一个 Owlv2 文本编码器，定义模型架构。使用默认值实例化配置将产生类似于 Owlv2 [google/owlv2-base-patch16](https://huggingface.co/google/owlv2-base-patch16)架构的配置。

配置对象继承自 PretrainedConfig，可用于控制模型输出。阅读 PretrainedConfig 的文档以获取更多信息。

示例：

```py
>>> from transformers import Owlv2TextConfig, Owlv2TextModel

>>> # Initializing a Owlv2TextModel with google/owlv2-base-patch16 style configuration
>>> configuration = Owlv2TextConfig()

>>> # Initializing a Owlv2TextConfig from the google/owlv2-base-patch16 style configuration
>>> model = Owlv2TextModel(configuration)

>>> # Accessing the model configuration
>>> configuration = model.config
```

## Owlv2VisionConfig

### `class transformers.Owlv2VisionConfig`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/configuration_owlv2.py#L150)

```py
( hidden_size = 768 intermediate_size = 3072 num_hidden_layers = 12 num_attention_heads = 12 num_channels = 3 image_size = 768 patch_size = 16 hidden_act = 'quick_gelu' layer_norm_eps = 1e-05 attention_dropout = 0.0 initializer_range = 0.02 initializer_factor = 1.0 **kwargs )
```

参数

+   `hidden_size` (`int`, *optional*, defaults to 768) — 编码器层和池化器层的维度。

+   `intermediate_size` (`int`, *optional*, defaults to 3072) — Transformer 编码器中“中间”（即前馈）层的维度。

+   `num_hidden_layers` (`int`, *optional*, defaults to 12) — Transformer 编码器中的隐藏层数。

+   `num_attention_heads` (`int`, *optional*, defaults to 12) — Transformer 编码器中每个注意力层的注意力头数。

+   `num_channels` (`int`, *optional*, defaults to 3) — 输入图像中的通道数。

+   `image_size` (`int`, *optional*, defaults to 768) — 每个图像的大小（分辨率）。

+   `patch_size` (`int`, *optional*, defaults to 16) — 每个补丁的大小（分辨率）。

+   `hidden_act` (`str` or `function`, *optional*, defaults to `"quick_gelu"`) — 编码器和池化器中的非线性激活函数（函数或字符串）。如果是字符串，支持`"gelu"`、`"relu"`、`"selu"`和`"gelu_new"`以及`"quick_gelu"`。

+   `layer_norm_eps` (`float`, *optional*, defaults to 1e-05) — 层归一化层使用的 epsilon。

+   `attention_dropout` (`float`, *optional*, defaults to 0.0) — 注意力概率的丢弃比率。

+   `initializer_range` (`float`, *optional*, defaults to 0.02) — 用于初始化所有权重矩阵的截断正态初始化器的标准差。

+   `initializer_factor` (`float`, *optional*, defaults to 1.0) — 用于初始化所有权重矩阵的因子（应保持为 1，用于内部初始化测试）。

这是一个配置类，用于存储 Owlv2VisionModel 的配置。根据指定的参数实例化一个 OWLv2 图像编码器，定义模型架构。使用默认值实例化配置将产生类似于 OWLv2 [google/owlv2-base-patch16](https://huggingface.co/google/owlv2-base-patch16) 架构的配置。

配置对象继承自 PretrainedConfig，可用于控制模型输出。阅读 PretrainedConfig 的文档以获取更多信息。

示例：

```py
>>> from transformers import Owlv2VisionConfig, Owlv2VisionModel

>>> # Initializing a Owlv2VisionModel with google/owlv2-base-patch16 style configuration
>>> configuration = Owlv2VisionConfig()

>>> # Initializing a Owlv2VisionModel model from the google/owlv2-base-patch16 style configuration
>>> model = Owlv2VisionModel(configuration)

>>> # Accessing the model configuration
>>> configuration = model.config
```

## Owlv2ImageProcessor

### `class transformers.Owlv2ImageProcessor`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/image_processing_owlv2.py#L176)

```py
( do_rescale: bool = True rescale_factor: Union = 0.00392156862745098 do_pad: bool = True do_resize: bool = True size: Dict = None resample: Resampling = <Resampling.BILINEAR: 2> do_normalize: bool = True image_mean: Union = None image_std: Union = None **kwargs )
```

参数

+   `do_rescale` (`bool`, *optional*, defaults to `True`) — 是否按指定的比例`rescale_factor`对图像进行重新缩放。可以被`preprocess`方法中的`do_rescale`覆盖。

+   `rescale_factor` (`int` or `float`, *optional*, defaults to `1/255`) — 如果重新缩放图像，要使用的缩放因子。可以被`preprocess`方法中的`rescale_factor`覆盖。

+   `do_pad` (`bool`, *optional*, defaults to `True`) — 是否将图像填充为带有灰色像素的正方形，位于底部和右侧。可以被`preprocess`方法中的`do_pad`覆盖。

+   `do_resize` (`bool`, *optional*, defaults to `True`) — 控制是否将图像的（高度、宽度）尺寸调整为指定的`size`。可以被`preprocess`方法中的`do_resize`覆盖。

+   `size` (`Dict[str, int]` *optional*, defaults to `{"height" -- 960, "width": 960}`): 要调整图像大小到的尺寸。可以被`preprocess`方法中的`size`覆盖。

+   `resample` (`PILImageResampling`, *optional*, defaults to `Resampling.BILINEAR`) — 如果调整图像大小，要使用的重采样方法。可以被`preprocess`方法中的`resample`覆盖。

+   `do_normalize` (`bool`, *optional*, defaults to `True`) — 是否对图像进行归一化。可以被`preprocess`方法中的`do_normalize`参数覆盖。

+   `image_mean` (`float` or `List[float]`, *optional*, defaults to `OPENAI_CLIP_MEAN`) — 如果对图像进行归一化要使用的均值。这是一个浮点数或与图像通道数相同长度的浮点数列表。可以被`preprocess`方法中的`image_mean`参数覆盖。

+   `image_std` (`float` 或 `List[float]`, *optional*, 默认为`OPENAI_CLIP_STD`) — 如果对图像进行归一化，则使用的标准差。这是一个浮点数或与图像中通道数相同长度的浮点数列表。可以被`preprocess`方法中的`image_std`参数覆盖。

构建一个 OWLv2 图像处理器。

#### `preprocess`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/image_processing_owlv2.py#L333)

```py
( images: Union do_pad: bool = None do_resize: bool = None size: Dict = None do_rescale: bool = None rescale_factor: float = None do_normalize: bool = None image_mean: Union = None image_std: Union = None return_tensors: Union = None data_format: ChannelDimension = <ChannelDimension.FIRST: 'channels_first'> input_data_format: Union = None **kwargs )
```

参数

+   `images` (`ImageInput`) — 要预处理的图像。期望单个或批量的像素值范围为 0 到 255 的图像。如果传入像素值在 0 到 1 之间的图像，请设置`do_rescale=False`。

+   `do_pad` (`bool`, *optional*, 默认为`self.do_pad`) — 是否将图像填充为带有灰色像素的正方形，位于底部和右侧。

+   `do_resize` (`bool`, *optional*, 默认为`self.do_resize`) — 是否调整图像大小。

+   `size` (`Dict[str, int]`, *optional*, 默认为`self.size`) — 调整图像大小的尺寸。

+   `do_rescale` (`bool`, *optional*, defaults to `self.do_rescale`) — 是否将图像值重新缩放到[0-1]之间。

+   `rescale_factor` (`float`, *optional*, 默认为`self.rescale_factor`) — 如果`do_rescale`设置为`True`，则重新缩放图像的重新缩放因子。

+   `do_normalize` (`bool`, *optional*, 默认为`self.do_normalize`) — 是否对图像进行归一化。

+   `image_mean` (`float` 或 `List[float]`, *optional*, 默认为`self.image_mean`) — 图像均值。

+   `image_std` (`float` 或 `List[float]`, *optional*, 默认为`self.image_std`) — 图像标准差。

+   `return_tensors` (`str` 或 `TensorType`, *optional*) — 要返回的张量类型。可以是以下之一：

    +   未设置：返回一个`np.ndarray`列表。

    +   `TensorType.TENSORFLOW` 或 `'tf'`: 返回类型为`tf.Tensor`的批次。

    +   `TensorType.PYTORCH` 或 `'pt'`: 返回类型为`torch.Tensor`的批次。

    +   `TensorType.NUMPY` 或 `'np'`: 返回类型为`np.ndarray`的批次。

    +   `TensorType.JAX` 或 `'jax'`: 返回类型为`jax.numpy.ndarray`的批次。

+   `data_format` (`ChannelDimension` 或 `str`, *optional*, 默认为`ChannelDimension.FIRST`) — 输出图像的通道维度格式。可以是以下之一：

    +   `"channels_first"` 或 `ChannelDimension.FIRST`: 图像格式为(num_channels, height, width)。

    +   `"channels_last"` 或 `ChannelDimension.LAST`: 图像格式为(height, width, num_channels)。

    +   未设置：使用输入图像的通道维度格式。

+   `input_data_format` (`ChannelDimension` 或 `str`, *optional*) — 输入图像的通道维度格式。如果未设置，将从输入图像中推断通道维度格式。可以是以下之一：

    +   `"channels_first"` 或 `ChannelDimension.FIRST`: 图像格式为(num_channels, height, width)。

    +   `"channels_last"` 或 `ChannelDimension.LAST`: 图像格式为(height, width, num_channels)。

    +   `"none"` 或 `ChannelDimension.NONE`: 图像格式为(height, width)。

预处理一个图像或图像批次。

#### `post_process_object_detection`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/image_processing_owlv2.py#L464)

```py
( outputs threshold: float = 0.1 target_sizes: Union = None ) → export const metadata = 'undefined';List[Dict]
```

参数

+   `outputs` (`OwlViTObjectDetectionOutput`) — 模型的原始输出。

+   `threshold` (`float`, *optional*) — 保留对象检测预测的分数阈值。

+   `target_sizes` (`torch.Tensor` 或 `List[Tuple[int, int]]`, *optional*) — 形状为`(batch_size, 2)`的张量或包含每个图像目标尺寸`(height, width)`的元组列表(`Tuple[int, int]`)。如果未设置，预测将不会被调整大小。

返回

`List[Dict]`

一个字典列表，每个字典包含模型预测的批次中每个图像的分数、标签和框。

将 OwlViTForObjectDetection 的原始输出转换为最终边界框，格式为(top_left_x, top_left_y, bottom_right_x, bottom_right_y)。

#### `post_process_image_guided_detection`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/image_processing_owlv2.py#L520)

```py
( outputs threshold = 0.0 nms_threshold = 0.3 target_sizes = None ) → export const metadata = 'undefined';List[Dict]
```

参数

+   `outputs` (`OwlViTImageGuidedObjectDetectionOutput`) — 模型的原始输出。

+   `threshold` (`float`, *可选*, 默认为 0.0) — 用于过滤预测框的最小置信度阈值。

+   `nms_threshold` (`float`, *可选*, 默认为 0.3) — 用于非最大抑制重叠框的 IoU 阈值。

+   `target_sizes` (`torch.Tensor`, *可选*) — 形状为(batch_size, 2)的张量，其中每个条目是批次中相应图像的(高度、宽度)。如果设置，预测的归一化边界框将重新缩放为目标大小。如果保持为 None，则预测不会被反归一化。

返回

`List[Dict]`

一个字典列表，每个字典包含批次中模型预测的图像的分数、标签和框。所有标签都设置为 None，因为`OwlViTForObjectDetection.image_guided_detection`执行一次性目标检测。

将 OwlViTForObjectDetection.image_guided_detection()的输出转换为 COCO api 期望的格式。

## Owlv2Processor

### `class transformers.Owlv2Processor`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/processing_owlv2.py#L28)

```py
( image_processor tokenizer **kwargs )
```

参数

+   `image_processor` (Owlv2ImageProcessor) — 图像处理器是必需的输入。

+   `tokenizer` ([`CLIPTokenizer`, `CLIPTokenizerFast`]) — 标记器是必需的输入。

构建一个 Owlv2 处理器，将 Owlv2ImageProcessor 和 CLIPTokenizer/CLIPTokenizerFast 包装成一个单一处理器，继承了图像处理器和标记器功能。有关更多信息，请参阅`__call__()`和 decode()。

#### `batch_decode`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/processing_owlv2.py#L178)

```py
( *args **kwargs )
```

此方法将其所有参数转发到 CLIPTokenizerFast 的 batch_decode()。有关更多信息，请参阅此方法的文档字符串。

#### `decode`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/processing_owlv2.py#L186)

```py
( *args **kwargs )
```

此方法将其所有参数转发到 CLIPTokenizerFast 的 decode()。有关更多信息，请参阅此方法的文档字符串。

#### `post_process_image_guided_detection`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/processing_owlv2.py#L170)

```py
( *args **kwargs )
```

此方法将其所有参数转发到`OwlViTImageProcessor.post_process_one_shot_object_detection`。有关更多信息，请参阅此方法的文档字符串。

#### `post_process_object_detection`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/processing_owlv2.py#L162)

```py
( *args **kwargs )
```

此方法将其所有参数转发到 OwlViTImageProcessor.post_process_object_detection()。有关更多信息，请参阅此方法的文档字符串。

## Owlv2Model

### `class transformers.Owlv2Model`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L1014)

```py
( config: Owlv2Config )
```

参数

+   `config` (`Owvl2Config`) — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

此模型继承自 PreTrainedModel。查看超类文档以获取库实现的所有模型的通用方法（例如下载或保存，调整输入嵌入大小，修剪头等）。

此模型还是 PyTorch 的[torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规的 PyTorch 模块，并参考 PyTorch 文档以获取与一般用法和行为相关的所有事项。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L1131)

```py
( input_ids: Optional = None pixel_values: Optional = None attention_mask: Optional = None return_loss: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_base_image_embeds: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.models.owlv2.modeling_owlv2.Owlv2Output or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`torch.LongTensor`，形状为`(batch_size, sequence_length)`) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `pixel_values` (`torch.FloatTensor`，形状为`(batch_size, num_channels, height, width)`) — 像素值。

+   `attention_mask` (`torch.Tensor`，形状为`(batch_size, sequence_length)`，*可选*) — 避免在填充标记索引上执行注意力的掩码。选择的掩码值在`[0, 1]`中：

    +   对于`未被掩盖`的标记为 1，

    +   对于`被掩盖`的标记为 0。什么是注意力掩码？

+   `return_loss` (`bool`, *可选*) — 是否返回对比损失。

+   `output_attentions` (`bool`, *可选*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回的张量下的`attentions`。

+   `output_hidden_states` (`bool`, *可选*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回的张量下的`hidden_states`。

+   `return_base_image_embeds` (`bool`, *可选*) — 是否返回基本图像嵌入。

+   `return_dict` (`bool`, *可选*) — 是否返回 ModelOutput 而不是普通元组。

返回

`transformers.models.owlv2.modeling_owlv2.Owlv2Output`或`tuple(torch.FloatTensor)`

一个`transformers.models.owlv2.modeling_owlv2.Owlv2Output`或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`）包含根据配置（`<class 'transformers.models.owlv2.configuration_owlv2.Owlv2Config'>`）和输入的各种元素。

+   `loss` (`torch.FloatTensor`，形状为`(1,)`，*可选*，当`return_loss`为`True`时返回) — 图像-文本相似性的对比损失。

+   `logits_per_image` (`torch.FloatTensor`，形状为`(image_batch_size, text_batch_size)`) — `image_embeds`和`text_embeds`之间的缩放点积分数。这代表图像-文本相似性分数。

+   `logits_per_text` (`torch.FloatTensor`，形状为`(text_batch_size, image_batch_size)`) — `text_embeds`和`image_embeds`之间的缩放点积分数。这代表文本-图像相似性分数。

+   `text_embeds` (`torch.FloatTensor` of shape `(batch_size * num_max_text_queries, output_dim`) — 通过将池化输出应用于 Owlv2TextModel 的投影层获得的文本嵌入。

+   `image_embeds` (`torch.FloatTensor` of shape `(batch_size, output_dim`) — 通过将池化输出应用于 Owlv2VisionModel 的投影层获得的图像嵌入。

+   `text_model_output` (Tuple`BaseModelOutputWithPooling`) — Owlv2TextModel 的输出。

+   `vision_model_output` (`BaseModelOutputWithPooling`) — Owlv2VisionModel 的输出。

Owlv2Model 的前向方法，覆盖了`__call__`特殊方法。

尽管前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者则默默地忽略它们。

示例：

```py
>>> from PIL import Image
>>> import requests
>>> from transformers import AutoProcessor, Owlv2Model

>>> model = Owlv2Model.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> processor = AutoProcessor.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> inputs = processor(text=[["a photo of a cat", "a photo of a dog"]], images=image, return_tensors="pt")
>>> outputs = model(**inputs)
>>> logits_per_image = outputs.logits_per_image  # this is the image-text similarity score
>>> probs = logits_per_image.softmax(dim=1)  # we can take the softmax to get the label probabilities
```

#### `get_text_features`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L1051)

```py
( input_ids: Optional = None attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';text_features (torch.FloatTensor of shape (batch_size, output_dim)
```

参数

+   `input_ids` (`torch.LongTensor` of shape `(batch_size * num_max_text_queries, sequence_length)`) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `attention_mask` (`torch.Tensor` of shape `(batch_size, num_max_text_queries, sequence_length)`, *optional*) — 避免在填充标记索引上执行注意力的掩码。选择在`[0, 1]`中的掩码值：

    +   1 表示未被掩盖的标记，

    +   0 表示被掩盖的标记。什么是注意力掩码？

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回一个 ModelOutput 而不是一个普通的元组。

返回

text_features (`torch.FloatTensor` of shape `(batch_size, output_dim`)

通过将池化输出应用于 Owlv2TextModel 的投影层获得的文本嵌入。

Owlv2Model 的前向方法，覆盖了`__call__`特殊方法。

尽管前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者则默默地忽略它们。

示例：

```py
>>> from transformers import AutoProcessor, Owlv2Model

>>> model = Owlv2Model.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> processor = AutoProcessor.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> inputs = processor(
...     text=[["a photo of a cat", "a photo of a dog"], ["photo of a astranaut"]], return_tensors="pt"
... )
>>> text_features = model.get_text_features(**inputs)
```

#### `get_image_features`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L1086)

```py
( pixel_values: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';image_features (torch.FloatTensor of shape (batch_size, output_dim)
```

参数

+   `pixel_values` (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`) — 像素值。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回 ModelOutput 而不是普通元组。

返回

image_features（形状为`(batch_size, output_dim)`的`torch.FloatTensor`

通过将投影层应用于 Owlv2VisionModel 的汇聚输出获得的图像嵌入。

Owlv2Model 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的方法需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from PIL import Image
>>> import requests
>>> from transformers import AutoProcessor, Owlv2Model

>>> model = Owlv2Model.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> processor = AutoProcessor.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> inputs = processor(images=image, return_tensors="pt")
>>> image_features = model.get_image_features(**inputs)
```

## Owlv2TextModel

### `class transformers.Owlv2TextModel`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L852)

```py
( config: Owlv2TextConfig )
```

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L867)

```py
( input_ids: Tensor attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.BaseModelOutputWithPooling or tuple(torch.FloatTensor)
```

参数

+   `input_ids`（形状为`(batch_size * num_max_text_queries, sequence_length)`的`torch.LongTensor`）— 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `attention_mask`（形状为`(batch_size, num_max_text_queries, sequence_length)`的`torch.Tensor`，*可选*）— 避免在填充标记索引上执行注意力的蒙版。在`[0, 1]`中选择的蒙版值：

    +   对于“未屏蔽”的标记返回 1，

    +   对于“屏蔽”的标记返回 0。什么是注意力蒙版？

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回 ModelOutput 而不是普通元组。

返回

transformers.modeling_outputs.BaseModelOutputWithPooling 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.BaseModelOutputWithPooling 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`时）包含各种元素，这取决于配置（`<class 'transformers.models.owlv2.configuration_owlv2.Owlv2TextConfig'>`）和输入。

+   `last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`）— 模型最后一层的隐藏状态序列。

+   `pooler_output` (`torch.FloatTensor` of shape `(batch_size, hidden_size)`) — 经过用于辅助预训练任务的层进一步处理后，序列中第一个标记（分类标记）的最后一层隐藏状态。例如，对于 BERT 系列模型，这将返回经过线性层和 tanh 激活函数处理后的分类标记。线性层的权重是在预训练期间从下一个句子预测（分类）目标中训练的。

+   `hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_hidden_states=True`或当`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入的输出+每层的输出）。

    模型在每一层输出的隐藏状态以及可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或当`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    注意力 softmax 后的注意力权重，用于计算自注意力头中的加权平均值。

Owlv2TextModel 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> from transformers import AutoProcessor, Owlv2TextModel

>>> model = Owlv2TextModel.from_pretrained("google/owlv2-base-patch16")
>>> processor = AutoProcessor.from_pretrained("google/owlv2-base-patch16")
>>> inputs = processor(
...     text=[["a photo of a cat", "a photo of a dog"], ["photo of a astranaut"]], return_tensors="pt"
... )
>>> outputs = model(**inputs)
>>> last_hidden_state = outputs.last_hidden_state
>>> pooled_output = outputs.pooler_output  # pooled (EOS token) states
```

## Owlv2VisionModel

### `class transformers.Owlv2VisionModel`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L964)

```py
( config: Owlv2VisionConfig )
```

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L977)

```py
( pixel_values: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.BaseModelOutputWithPooling or tuple(torch.FloatTensor)
```

参数

+   `pixel_values` (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`) — 像素值。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回一个 ModelOutput 而不是一个普通的元组。

返回

transformers.modeling_outputs.BaseModelOutputWithPooling 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.BaseModelOutputWithPooling 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或当`config.return_dict=False`时）包含根据配置(`<class 'transformers.models.owlv2.configuration_owlv2.Owlv2VisionConfig'>`)和输入的不同元素。

+   `last_hidden_state` (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`) — 模型最后一层的隐藏状态序列。

+   `pooler_output` (`torch.FloatTensor` of shape `(batch_size, hidden_size)`) — 序列的第一个标记（分类标记）的最后一层隐藏状态，在通过用于辅助预训练任务的层进一步处理后。例如，对于 BERT 系列模型，这返回经过线性层和双曲正切激活函数处理后的分类标记。线性层的权重是在预训练期间从下一个句子预测（分类）目标中训练的。

+   `hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递 `output_hidden_states=True` 或 `config.output_hidden_states=True` 时返回) — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor` 元组（如果模型有嵌入层，则为嵌入输出的输出 + 每层的输出）。

    模型在每一层输出的隐藏状态加上可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递 `output_attentions=True` 或 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组（每层一个）。

    在注意力 softmax 之后的注意力权重，用于计算自注意力头中的加权平均值。

Owlv2VisionModel 的前向方法，覆盖了 `__call__` 特殊方法。

尽管前向传递的配方需要在此函数内定义，但应该在此之后调用 `Module` 实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者则默默地忽略它们。

示例：

```py
>>> from PIL import Image
>>> import requests
>>> from transformers import AutoProcessor, Owlv2VisionModel

>>> model = Owlv2VisionModel.from_pretrained("google/owlv2-base-patch16")
>>> processor = AutoProcessor.from_pretrained("google/owlv2-base-patch16")
>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)

>>> inputs = processor(images=image, return_tensors="pt")

>>> outputs = model(**inputs)
>>> last_hidden_state = outputs.last_hidden_state
>>> pooled_output = outputs.pooler_output  # pooled CLS states
```

## Owlv2ForObjectDetection

### `class transformers.Owlv2ForObjectDetection`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L1300)

```py
( config: Owlv2Config )
```

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L1654)

```py
( input_ids: Tensor pixel_values: FloatTensor attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.models.owlv2.modeling_owlv2.Owlv2ObjectDetectionOutput or tuple(torch.FloatTensor)
```

参数

+   `pixel_values` (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`) — 像素值。

+   `input_ids` (`torch.LongTensor` of shape `(batch_size * num_max_text_queries, sequence_length)`, *optional*) — 词汇表中输入序列标记的索引。可以使用 AutoTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。什么是输入 ID？。

+   `attention_mask` (`torch.Tensor` of shape `(batch_size, num_max_text_queries, sequence_length)`, *optional*) — 用于避免在填充标记索引上执行注意力的掩码。掩码值选在 `[0, 1]` 之间：

    +   1 用于 `not masked` 的标记，

    +   0 用于 `masked` 的标记。什么是注意力掩码？

+   `output_hidden_states` (`bool`, *optional*) — 是否返回最后一个隐藏状态。有关更多详细信息，请参阅返回张量中的 `text_model_last_hidden_state` 和 `vision_model_last_hidden_state`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

返回

`transformers.models.owlv2.modeling_owlv2.Owlv2ObjectDetectionOutput` 或 `tuple(torch.FloatTensor)`

一个 `transformers.models.owlv2.modeling_owlv2.Owlv2ObjectDetectionOutput` 或一个 `torch.FloatTensor` 元组（如果传递了 `return_dict=False` 或 `config.return_dict=False` 或 `config.return_dict=False`）包含根据配置（`<class 'transformers.models.owlv2.configuration_owlv2.Owlv2Config'>`）和输入而异的各种元素。

+   `loss` (`torch.FloatTensor`，形状为`(1,)`，*可选*，当提供`labels`时返回)） — 总损失，作为类别预测的负对数似然（交叉熵）和边界框损失的线性组合。后者被定义为 L1 损失和广义尺度不变 IoU 损失的线性组合。

+   `loss_dict` (`Dict`，*可选*） — 包含各个损失的字典。用于记录。

+   `logits` (`torch.FloatTensor`，形状为`(batch_size, num_patches, num_queries)`) — 所有查询的分类 logits（包括无对象）。

+   `objectness_logits` (`torch.FloatTensor`，形状为`(batch_size, num_patches, 1)`) — 所有图像补丁的目标性 logits。OWL-ViT 将图像表示为一组图像补丁，其中补丁的总数为（图像大小/补丁大小）**2。

+   `pred_boxes` (`torch.FloatTensor`，形状为`(batch_size, num_patches, 4)`) — 所有查询的归一化框坐标，表示为（中心 _x，中心 _y，宽度，高度）。这些值在[0, 1]范围内归一化，相对于批处理中每个单独图像的大小（忽略可能的填充）。您可以使用 post_process_object_detection()来检索未归一化的边界框。

+   `text_embeds` (`torch.FloatTensor`，形状为`(batch_size, num_max_text_queries, output_dim`) — 通过将投影层应用于 Owlv2TextModel 的汇集输出获得的文本嵌入。

+   `image_embeds` (`torch.FloatTensor`，形状为`(batch_size, patch_size, patch_size, output_dim`) — Owlv2VisionModel 的汇集输出。OWLv2 将图像表示为一组图像补丁，并为每个补丁计算图像嵌入。

+   `class_embeds` (`torch.FloatTensor`，形状为`(batch_size, num_patches, hidden_size)`) — 所有图像补丁的类别嵌入。OWLv2 将图像表示为一组图像补丁，其中补丁的总数为（图像大小/补丁大小）**2。

+   `text_model_output` (Tuple`BaseModelOutputWithPooling`) — Owlv2TextModel 的输出。

+   `vision_model_output` (`BaseModelOutputWithPooling`) — Owlv2VisionModel 的输出。

Owlv2ForObjectDetection 的前向方法，覆盖`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> import requests
>>> from PIL import Image
>>> import numpy as np
>>> import torch
>>> from transformers import AutoProcessor, Owlv2ForObjectDetection
>>> from transformers.utils.constants import OPENAI_CLIP_MEAN, OPENAI_CLIP_STD

>>> processor = AutoProcessor.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> model = Owlv2ForObjectDetection.from_pretrained("google/owlv2-base-patch16-ensemble")

>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> texts = [["a photo of a cat", "a photo of a dog"]]
>>> inputs = processor(text=texts, images=image, return_tensors="pt")

>>> # forward pass
>>> with torch.no_grad():
...     outputs = model(**inputs)

>>> # Note: boxes need to be visualized on the padded, unnormalized image
>>> # hence we'll set the target image sizes (height, width) based on that

>>> def get_preprocessed_image(pixel_values):
...     pixel_values = pixel_values.squeeze().numpy()
...     unnormalized_image = (pixel_values * np.array(OPENAI_CLIP_STD)[:, None, None]) + np.array(OPENAI_CLIP_MEAN)[:, None, None]
...     unnormalized_image = (unnormalized_image * 255).astype(np.uint8)
...     unnormalized_image = np.moveaxis(unnormalized_image, 0, -1)
...     unnormalized_image = Image.fromarray(unnormalized_image)
...     return unnormalized_image

>>> unnormalized_image = get_preprocessed_image(inputs.pixel_values)

>>> target_sizes = torch.Tensor([unnormalized_image.size[::-1]])
>>> # Convert outputs (bounding boxes and class logits) to final bounding boxes and scores
>>> results = processor.post_process_object_detection(
...     outputs=outputs, threshold=0.2, target_sizes=target_sizes
... )

>>> i = 0  # Retrieve predictions for the first image for the corresponding text queries
>>> text = texts[i]
>>> boxes, scores, labels = results[i]["boxes"], results[i]["scores"], results[i]["labels"]

>>> for box, score, label in zip(boxes, scores, labels):
...     box = [round(i, 2) for i in box.tolist()]
...     print(f"Detected {text[label]} with confidence {round(score.item(), 3)} at location {box}")
Detected a photo of a cat with confidence 0.614 at location [512.5, 35.08, 963.48, 557.02]
Detected a photo of a cat with confidence 0.665 at location [10.13, 77.94, 489.93, 709.69]
```

#### `image_guided_detection`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/owlv2/modeling_owlv2.py#L1529)

```py
( pixel_values: FloatTensor query_pixel_values: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.models.owlv2.modeling_owlv2.Owlv2ImageGuidedObjectDetectionOutput or tuple(torch.FloatTensor)
```

参数

+   `pixel_values` (`torch.FloatTensor`，形状为`(batch_size, num_channels, height, width)`) — 像素值。

+   `query_pixel_values` (`torch.FloatTensor`，形状为`(batch_size, num_channels, height, width)`) — 要检测的查询图像的像素值。每个目标图像传入一个查询图像。

+   `output_attentions` (`bool`，*可选*） — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states` (`bool`，*可选*） — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict` (`bool`，*可选*） — 是否返回 ModelOutput 而不是普通元组。

返回

`transformers.models.owlv2.modeling_owlv2.Owlv2ImageGuidedObjectDetectionOutput` 或 `tuple(torch.FloatTensor)`

一个`transformers.models.owlv2.modeling_owlv2.Owlv2ImageGuidedObjectDetectionOutput` 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`）包含各种元素，具体取决于配置（`<class 'transformers.models.owlv2.configuration_owlv2.Owlv2Config'>`）和输入。

+   `logits` (`torch.FloatTensor`，形状为`(batch_size, num_patches, num_queries)`) — 所有查询的分类 logits（包括无对象）。

+   `target_pred_boxes` (`torch.FloatTensor`，形状为`(batch_size, num_patches, 4)`) — 所有查询的标准化框坐标，表示为（中心 _x，中心 _y，宽度，高度）。这些值在[0, 1]范围内标准化，相对于批处理中每个单独目标图像的大小（忽略可能的填充）。您可以使用 post_process_object_detection()来检索未标准化的边界框。

+   `query_pred_boxes` (`torch.FloatTensor`，形状为`(batch_size, num_patches, 4)`) — 所有查询的标准化框坐标，表示为（中心 _x，中心 _y，宽度，高度）。这些值在[0, 1]范围内标准化，相对于批处理中每个单独查询图像的大小（忽略可能的填充）。您可以使用 post_process_object_detection()来检索未标准化的边界框。

+   `image_embeds` (`torch.FloatTensor`，形状为`(batch_size, patch_size, patch_size, output_dim`) — Owlv2VisionModel 的汇总输出。OWLv2 将图像表示为一组图像补丁，并为每个补丁计算图像嵌入。

+   `query_image_embeds` (`torch.FloatTensor`，形状为`(batch_size, patch_size, patch_size, output_dim`) — Owlv2VisionModel 的汇总输出。OWLv2 将图像表示为一组图像补丁，并为每个补丁计算图像嵌入。

+   `class_embeds` (`torch.FloatTensor`，形状为`(batch_size, num_patches, hidden_size)`) — 所有图像补丁的类别嵌入。OWLv2 将图像表示为一组图像补丁，其中补丁的总数为（图像大小/补丁大小）**2。

+   `text_model_output` (Tuple`BaseModelOutputWithPooling`) — Owlv2TextModel 的输出。

+   `vision_model_output` (`BaseModelOutputWithPooling`) — Owlv2VisionModel 的输出。

Owlv2ForObjectDetection 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的配方需要在此函数内定义，但应该在之后调用`Module`实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> import requests
>>> from PIL import Image
>>> import torch
>>> import numpy as np
>>> from transformers import AutoProcessor, Owlv2ForObjectDetection
>>> from transformers.utils.constants import OPENAI_CLIP_MEAN, OPENAI_CLIP_STD

>>> processor = AutoProcessor.from_pretrained("google/owlv2-base-patch16-ensemble")
>>> model = Owlv2ForObjectDetection.from_pretrained("google/owlv2-base-patch16-ensemble")

>>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
>>> image = Image.open(requests.get(url, stream=True).raw)
>>> query_url = "http://images.cocodataset.org/val2017/000000001675.jpg"
>>> query_image = Image.open(requests.get(query_url, stream=True).raw)
>>> inputs = processor(images=image, query_images=query_image, return_tensors="pt")

>>> # forward pass
>>> with torch.no_grad():
...     outputs = model.image_guided_detection(**inputs)

>>> # Note: boxes need to be visualized on the padded, unnormalized image
>>> # hence we'll set the target image sizes (height, width) based on that

>>> def get_preprocessed_image(pixel_values):
...     pixel_values = pixel_values.squeeze().numpy()
...     unnormalized_image = (pixel_values * np.array(OPENAI_CLIP_STD)[:, None, None]) + np.array(OPENAI_CLIP_MEAN)[:, None, None]
...     unnormalized_image = (unnormalized_image * 255).astype(np.uint8)
...     unnormalized_image = np.moveaxis(unnormalized_image, 0, -1)
...     unnormalized_image = Image.fromarray(unnormalized_image)
...     return unnormalized_image

>>> unnormalized_image = get_preprocessed_image(inputs.pixel_values)

>>> target_sizes = torch.Tensor([unnormalized_image.size[::-1]])

>>> # Convert outputs (bounding boxes and class logits) to Pascal VOC format (xmin, ymin, xmax, ymax)
>>> results = processor.post_process_image_guided_detection(
...     outputs=outputs, threshold=0.9, nms_threshold=0.3, target_sizes=target_sizes
... )
>>> i = 0  # Retrieve predictions for the first image
>>> boxes, scores = results[i]["boxes"], results[i]["scores"]
>>> for box, score in zip(boxes, scores):
...     box = [round(i, 2) for i in box.tolist()]
...     print(f"Detected similar object with confidence {round(score.item(), 3)} at location {box}")
Detected similar object with confidence 0.938 at location [490.96, 109.89, 821.09, 536.11]
Detected similar object with confidence 0.959 at location [8.67, 721.29, 928.68, 732.78]
Detected similar object with confidence 0.902 at location [4.27, 720.02, 941.45, 761.59]
Detected similar object with confidence 0.985 at location [265.46, -58.9, 1009.04, 365.66]
Detected similar object with confidence 1.0 at location [9.79, 28.69, 937.31, 941.64]
Detected similar object with confidence 0.998 at location [869.97, 58.28, 923.23, 978.1]
Detected similar object with confidence 0.985 at location [309.23, 21.07, 371.61, 932.02]
Detected similar object with confidence 0.947 at location [27.93, 859.45, 969.75, 915.44]
Detected similar object with confidence 0.996 at location [785.82, 41.38, 880.26, 966.37]
Detected similar object with confidence 0.998 at location [5.08, 721.17, 925.93, 998.41]
Detected similar object with confidence 0.969 at location [6.7, 898.1, 921.75, 949.51]
Detected similar object with confidence 0.966 at location [47.16, 927.29, 981.99, 942.14]
Detected similar object with confidence 0.924 at location [46.4, 936.13, 953.02, 950.78]
```
