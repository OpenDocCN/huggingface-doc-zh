# Whisper

> 原文：[`huggingface.co/docs/transformers/v4.37.2/en/model_doc/whisper`](https://huggingface.co/docs/transformers/v4.37.2/en/model_doc/whisper)

## 概述

Whisper 模型由 Alec Radford、Jong Wook Kim、Tao Xu、Greg Brockman、Christine McLeavey、Ilya Sutskever 在[通过大规模弱监督实现稳健语音识别](https://cdn.openai.com/papers/whisper.pdf)中提出。

论文摘要如下：

*我们研究了简单训练以预测互联网上大量音频转录的语音处理系统的能力。当扩展到 680,000 小时的多语言和多任务监督时，得到的模型在标准基准上表现良好，并且通常与先前的完全监督结果竞争，但在零次迁移设置中无需任何微调。与人类相比，模型接近其准确性和稳健性。我们发布了模型和推理代码，以作为进一步研究稳健语音处理的基础。*

此模型由[Arthur Zucker](https://huggingface.co/ArthurZ)贡献。此模型的 Tensorflow 版本由[amyeroberts](https://huggingface.co/amyeroberts)贡献。原始代码可在[此处](https://github.com/openai/whisper)找到。

## 使用提示

+   该模型通常无需任何微调即可表现良好。

+   该架构遵循经典的编码器-解码器架构，这意味着它依赖于 generate()函数进行推理。

+   目前仅实现了短形式的推理，即音频被预分段为<=30 秒的片段。长形式（包括时间戳）将在未来的版本中实现。

+   可以使用 WhisperProcessor 来准备音频以供模型使用，并将预测的 ID 解码回文本。

+   要转换模型和处理器，我们建议使用以下方法：

```py
python src/transformers/models/whisper/convert_openai_to_hf.py --checkpoint_path "" --pytorch_dump_folder_path "Arthur/whisper-3" --convert_preprocessor True
```

脚本将自动从 OpenAI 检查点确定所有必要的参数。需要安装`tiktoken`库以执行将 OpenAI 分词器转换为`tokenizers`版本的转换。

## 推理

以下是使用预训练的 Whisper 模型转录音频样本的逐步指南：

```py
>>> from datasets import load_dataset
>>> from transformers import WhisperProcessor, WhisperForConditionalGeneration

>>> # Select an audio file and read it:
>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")
>>> audio_sample = ds[0]["audio"]
>>> waveform = audio_sample["array"]
>>> sampling_rate = audio_sample["sampling_rate"]

>>> # Load the Whisper model in Hugging Face format:
>>> processor = WhisperProcessor.from_pretrained("openai/whisper-tiny.en")
>>> model = WhisperForConditionalGeneration.from_pretrained("openai/whisper-tiny.en")

>>> # Use the model and processor to transcribe the audio:
>>> input_features = processor(
...     waveform, sampling_rate=sampling_rate, return_tensors="pt"
... ).input_features

>>> # Generate token ids
>>> predicted_ids = model.generate(input_features)

>>> # Decode token ids to text
>>> transcription = processor.batch_decode(predicted_ids, skip_special_tokens=True)

>>> transcription[0]
' Mr. Quilter is the apostle of the middle classes, and we are glad to welcome his gospel.'
```

## 资源

官方 Hugging Face 和社区（由🌎表示）资源列表，可帮助您开始使用 Whisper。如果您有兴趣提交资源以包含在此处，请随时提交拉取请求，我们将进行审核！资源应该展示一些新东西，而不是重复现有资源。

+   一个包含脚本的分支，用于[将 Hugging Face 格式的 Whisper 模型转换为 OpenAI 格式](https://github.com/zuazo-forks/transformers/blob/convert_hf_to_openai/src/transformers/models/whisper/convert_hf_to_openai.py)。🌎 使用示例：

```py
pip install -U openai-whisper
python convert_hf_to_openai.py \
    --checkpoint openai/whisper-tiny \
    --whisper_dump_path whisper-tiny-openai.pt
```

## WhisperConfig

### `class transformers.WhisperConfig`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/configuration_whisper.py#L62)

```py
( vocab_size = 51865 num_mel_bins = 80 encoder_layers = 4 encoder_attention_heads = 6 decoder_layers = 4 decoder_attention_heads = 6 decoder_ffn_dim = 1536 encoder_ffn_dim = 1536 encoder_layerdrop = 0.0 decoder_layerdrop = 0.0 decoder_start_token_id = 50257 use_cache = True is_encoder_decoder = True activation_function = 'gelu' d_model = 384 dropout = 0.0 attention_dropout = 0.0 activation_dropout = 0.0 init_std = 0.02 scale_embedding = False max_source_positions = 1500 max_target_positions = 448 pad_token_id = 50256 bos_token_id = 50256 eos_token_id = 50256 suppress_tokens = None begin_suppress_tokens = [220, 50256] use_weighted_layer_sum = False classifier_proj_size = 256 apply_spec_augment = False mask_time_prob = 0.05 mask_time_length = 10 mask_time_min_masks = 2 mask_feature_prob = 0.0 mask_feature_length = 10 mask_feature_min_masks = 0 median_filter_width = 7 **kwargs )
```

参数

+   `vocab_size`（`int`，*可选*，默认为 51865）— Whisper 模型的词汇量。定义了在调用 WhisperModel 时可以由`decoder_input_ids`表示的不同标记数量。

+   `num_mel_bins`（`int`，*可选*，默认为 80）— 每个输入特征中使用的 mel 特征数量。应与`WhisperProcessor`类中使用的值对应。

+   `encoder_layers`（`int`，*可选*，默认为 4）— 编码器层数。

+   `decoder_layers`（`int`，*可选*，默认为 4）— 解码器层数。

+   `encoder_attention_heads`（`int`，*可选*，默认为 6）— Transformer 编码器中每个注意力层的注意力头数。

+   `decoder_attention_heads` (`int`, *optional*, 默认为 6) — Transformer 解码器中每个注意力层的注意力头数。

+   `encoder_ffn_dim` (`int`, *optional*, 默认为 1536) — 编码器中“中间”（通常称为前馈）层的维度。

+   `decoder_ffn_dim` (`int`, *optional*, 默认为 1536) — 解码器中“中间”（通常称为前馈）层的维度。

+   `encoder_layerdrop` (`float`, *optional*, 默认为 0.0) — 编码器的 LayerDrop 概率。有关更多详细信息，请参阅 LayerDrop paper)。

+   `decoder_layerdrop` (`float`, *optional*, 默认为 0.0) — 解码器的 LayerDrop 概率。有关更多详细信息，请参阅 LayerDrop paper)。

+   `decoder_start_token_id`（`int`，*optional*，默认为 50257）--对应于`“<|startoftranscript|>”`标记，当没有向`generate`函数提供`decoder_input_ids`时，会自动使用该标记。它用于根据任务指导模型的生成过程。

+   `use_cache` (`bool`, *optional*, 默认为`True`) — 模型是否应返回最后的键/值注意力（并非所有模型都使用）。

+   `is_encoder_decoder` (`bool`, *optional*, 默认为`True`) — 模型是否用作编码器/解码器。

+   `activation_function` (`str`, *optional*, 默认为`"gelu"`) — 编码器和池化器中的非线性激活函数（函数或字符串）。如果是字符串，支持`"gelu"`、`"relu"`、`"silu"`和`"gelu_new"`。

+   `d_model` (`int`, *optional*, 默认为 384) — 层的维度。

+   `dropout` (`float`, *optional*, 默认为 0.1) — 嵌入层、编码器和池化层中所有全连接层的丢弃概率。

+   `attention_dropout` (`float`, *optional*, 默认为 0.0) — 注意力概率的丢弃比率。

+   `activation_dropout` (`float`, *optional*, 默认为 0.0) — 全连接层内部激活的丢弃比率。

+   `init_std` (`float`, *optional*, 默认为 0.02) — 用于初始化所有权重矩阵的截断正态初始化器的标准差。

+   `scale_embedding` (`bool`, *optional*, 默认为 False) — 通过除以 sqrt(d_model)来缩放嵌入。

+   `max_source_positions` (`int`, *optional*, 默认为 1500) — 该模型可能用于的对数梅尔滤波器组特征的最大序列长度。

+   `max_target_positions` (`int`, *optional*, 默认为 448) — 该模型可能用于的最大序列长度。通常将其设置为较大的值以防万一（例如 512、1024 或 2048）。

+   `pad_token_id` (`int`, *optional*, 默认为 50256) — 填充标记 id。

+   `bos_token_id` (`int`, *optional*, 默认为 50256) — 流的开始标记 id。

+   `eos_token_id` (`int`, *optional*, 默认为 50256) — 流的结束标记 id。

+   `suppress_tokens` (`List[int]`, *optional*) — 包含将在`generate`函数中由对数处理器使用的非语音标记的列表。NON_SPEECH_TOKENS 和 NON_SPEECH_TOKENS_MULTI 分别对应于`english-only`和`multilingual`模型。

+   `begin_suppress_tokens` (`List[int]`, *optional*, 默认为`[220,50256]`) — 包含在采样过程开始时将被抑制的标记的列表。初始化为`" "`（`blank_token_id`）和`eos_token_id`的标记。

+   `use_weighted_layer_sum` (`bool`, *optional*, 默认为`False`) — 是否使用带有学习权重的层输出的加权平均值。仅在使用 WhisperForAudioClassification 的实例时相关。

+   `classifier_proj_size` (`int`, *optional*, 默认为 256) — 分类前的投影维度，用于标记均值池化。仅在使用 WhisperForAudioClassification 的实例时相关。

+   `apply_spec_augment` (`bool`, *optional*, defaults to `False`) — 是否将*SpecAugment*数据增强应用于特征编码器的输出。有关详细信息，请参阅[SpecAugment: A Simple Data Augmentation Method for Automatic Speech Recognition](https://arxiv.org/abs/1904.08779)。

+   `mask_time_prob` (`float`, *optional*, defaults to 0.05) — 沿时间轴的所有特征向量的百分比（介于 0 和 1 之间）将被掩盖。掩盖过程在轴上生成`mask_time_prob*len(time_axis)/mask_time_length`个独立的掩码。如果从每个特征向量被选择为要掩盖的向量跨度的起始的概率推理，*mask_time_prob*应为`prob_vector_start*mask_time_length`。请注意，重叠可能会降低掩盖向量的实际百分比。只有在`apply_spec_augment == True`时才相关。

+   `mask_time_length` (`int`, *optional*, defaults to 10) — 沿时间轴的向量跨度长度。

+   `mask_time_min_masks` (`int`, *optional*, defaults to 2), — 沿时间轴生成的长度为`mask_feature_length`的掩码的最小数量，每个时间步，与`mask_feature_prob`无关。只有在”mask_time_prob*len(time_axis)/mask_time_length < mask_time_min_masks”时才相关。

+   `mask_feature_prob` (`float`, *optional*, defaults to 0.0) — 沿特征轴的所有特征向量的百分比（介于 0 和 1 之间）将被掩盖。掩盖过程在轴上生成`mask_feature_prob*len(feature_axis)/mask_time_length`个独立的掩码。如果从每个特征向量被选择为要掩盖的向量跨度的起始的概率推理，*mask_feature_prob*应为`prob_vector_start*mask_feature_length`。请注意，重叠可能会降低掩盖向量的实际百分比。只有在`apply_spec_augment`为 True 时才相关。

+   `mask_feature_length` (`int`, *optional*, defaults to 10) — 沿特征轴的向量跨度长度。

+   `mask_feature_min_masks` (`int`, *optional*, defaults to 0), — 沿特征轴生成的长度为`mask_feature_length`的掩码的最小数量，每个时间步，与`mask_feature_prob`无关。只有在`mask_feature_prob*len(feature_axis)/mask_feature_length < mask_feature_min_masks`时才相关。

+   `median_filter_width` (`int`, *optional*, defaults to 7) — 用于在计算标记时间戳时平滑交叉注意力输出的中值滤波器的宽度。应为奇数。

这是用于存储 WhisperModel 配置的配置类。它用于根据指定的参数实例化 Whisper 模型，定义模型架构。使用默认值实例化配置将产生类似于 Whisper [openai/whisper-tiny](https://huggingface.co/openai/whisper-tiny)架构的配置。

配置对象继承自 PretrainedConfig，可用于控制模型输出。阅读 PretrainedConfig 的文档以获取更多信息。

示例：

```py
>>> from transformers import WhisperConfig, WhisperModel

>>> # Initializing a Whisper tiny style configuration
>>> configuration = WhisperConfig()

>>> # Initializing a model (with random weights) from the tiny style configuration
>>> model = WhisperModel(configuration)

>>> # Accessing the model configuration
>>> configuration = model.config
```

## WhisperTokenizer

### `class transformers.WhisperTokenizer`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper.py#L217)

```py
( vocab_file merges_file normalizer_file = None errors = 'replace' unk_token = '<|endoftext|>' bos_token = '<|endoftext|>' eos_token = '<|endoftext|>' pad_token = None add_prefix_space = False language = None task = None predict_timestamps = False **kwargs )
```

参数

+   `vocab_file` (`str`) — 词汇文件的路径。

+   `merges_file` (`str`) — 合并文件的路径。

+   `normalizer_file` (`str`, *optional*) — 正则化器文件的路径。

+   `errors`（`str`，*optional*，默认为``"replace"``）--将字节解码为 UTF-8 时要遵循的示例。请参阅[bytes.decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode)了解更多信息。

+   `unk_token`（`str`，*optional*，默认为``"<|endoftext|>"``）--未知令牌。词汇表中没有的令牌无法转换为 ID，而是设置为该令牌。

+   `bos_token`（`str`，*optional*，默认为``"<|endoftext|>"``）--序列标记的开头。`decoder_start_token_id`用于在生成时将第一个令牌设置为``"<|startoftranscript|>"``。

+   `eos_token`（`str`，*optional*，默认为``"<|endoftext|>"``）--序列结束标记。

+   `pad_token` (`str`, *optional*) — 用于填充的标记，例如在批处理不同长度的序列时。

+   `add_prefix_space` (`bool`, *optional*, defaults to `False`) — 是否在输入前添加一个初始空格。这允许将前导单词视为任何其他单词。

+   `language`（`str`，*可选*）--转录文本的语言。对于多语言语音识别和语音翻译任务，相应的语言 id 标记被附加到序列的开头，例如对于西班牙语，标记``"<|es|>"``被附加到顺序的开头。这只能用于多语言微调。

+   `task`（`str`，*可选*）--要附加在序列开头的任务标识符（如果有）。这应用于多语言微调，`"transcribe"`用于语音识别，`"translate"`用于语音翻译。

+   predict_timestamps`（`bool`，*optional*，默认为`False`）--是否省略序列开头的`<|notimestamps|>`标记。

构建一个 Whisper tokenizer。

这个分词器继承自 PreTrainedTokenizer，其中包含一些主要方法。用户应参考超类以获取有关这些方法的更多信息。

#### `set_prefix_tokens`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper.py#L389)

```py
( language: str = None task: str = None predict_timestamps: bool = None )
```

参数

+   `language`（`str`，*可选*，默认为 `None`）— 转录文本的语言。

+   `task`（`str`，*可选*，默认为 `None`）— 任务标识符，附加在序列开头（如果有）。

+   `predict_timestamps`（`bool`，*optional*，默认为`None`）--是否省略序列开头的`<|notimestamps|>`标记。

覆盖附加到标签序列开头的前缀标记。此方法可以独立使用以

在微调时根据需要更新前缀标记。示例：

```py
>>> # instantiate the tokenizer and set the prefix token to Spanish
>>> tokenizer = WhisperTokenizer.from_pretrained("openai/whisper-tiny", language="spanish")
>>> # now switch the prefix token from Spanish to French
>>> tokenizer.set_prefix_tokens(language="french")
```

#### `build_inputs_with_special_tokens`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper.py#L448)

```py
( token_ids_0 token_ids_1 = None )
```

通过附加 eos_token_id 从序列构建模型输入。

#### `get_special_tokens_mask`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper.py#L456)

```py
( token_ids_0: List token_ids_1: Optional = None already_has_special_tokens: bool = False ) → export const metadata = 'undefined';List[int]
```

参数

+   `token_ids_0`（`List[int]`）— ID 列表。

+   `token_ids_1`（`List[int]`，*可选*）— 序列对的可选第二个 ID 列表。

+   `already_has_special_tokens`（`bool`，*可选*，默认为 `False`）— 标记列表是否已经格式化为模型的特殊标记。

返回

`List[int]`

一个整数列表，范围为 [0, 1]：1 表示特殊标记，0 表示序列标记。

从没有添加特殊标记的标记列表中检索序列 ID。在使用分词器的 `prepare_for_model` 方法添加特殊标记时调用此方法。

#### `create_token_type_ids_from_sequences`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/tokenization_utils_base.py#L3302)

```py
( token_ids_0: List token_ids_1: Optional = None ) → export const metadata = 'undefined';List[int]
```

参数

+   `token_ids_0`（`List[int]`）— 第一个标记化序列。

+   `token_ids_1`（`List[int]`，*可选*）— 第二个标记化序列。

返回

`List[int]`

标记类型 ID。

创建与传递的序列对应的标记类型 ID。什么是标记类型 ID？

如果模型有一种特殊的构建方式，则应在子类中重写它。

#### `save_vocabulary`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper.py#L763)

```py
( save_directory: str filename_prefix: Optional = None )
```

#### `batch_decode`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/tokenization_utils_base.py#L3692)

```py
( sequences: Union skip_special_tokens: bool = False clean_up_tokenization_spaces: bool = None **kwargs ) → export const metadata = 'undefined';List[str]
```

参数

+   `sequences`（`Union[List[int], List[List[int]], np.ndarray, torch.Tensor, tf.Tensor]`）— 标记化输入 ID 的列表。可以使用 `__call__` 方法获取。

+   `skip_special_tokens`（`bool`，*可选*，默认为 `False`）— 是否在解码时删除特殊标记。

+   `clean_up_tokenization_spaces`（`bool`，*可选*）— 是否清理分词空格。如果为 `None`，将默认为 `self.clean_up_tokenization_spaces`。

+   `kwargs`（额外的关键字参数，*可选*）— 将传递给底层模型特定的解码方法。

返回

`List[str]`

解码的句子列表。

通过调用解码将标记 ID 的列表列表转换为字符串列表。

#### `decode`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper.py#L639)

```py
( token_ids skip_special_tokens: bool = False clean_up_tokenization_spaces: bool = None output_offsets: bool = False time_precision: float = 0.02 decode_with_timestamps: bool = False normalize: bool = False basic_normalize: bool = False remove_diacritics: bool = False **kwargs ) → export const metadata = 'undefined';str
```

参数

+   `token_ids`（`Union[int, List[int], np.ndarray, torch.Tensor, tf.Tensor]`）— 标记化输入 ID 的列表。可以使用 `__call__` 方法获取。

+   `skip_special_tokens`（`bool`，*可选*，默认为 `False`）— 是否在解码时删除特殊标记。

+   `clean_up_tokenization_spaces`（`bool`，*可选*）— 是否清理分词空格。如果为 `None`，将默认为 `self.clean_up_tokenization_spaces`（在 `tokenizer_config` 中可用）。

+   `output_offsets` (`bool`, *optional*, 默认为 `False`) — 是否输出标记的偏移量。只有在模型预测时间戳时才应设置此选项。

+   `time_precision` (`float`, `optional`, 默认为 0.02) — 从标记转换为时间的时间比率。

+   `decode_with_timestamps` (`bool`, *optional*, 默认为 `False`) — 是否在原始文本中包含时间戳进行解码。

+   `normalize` (`bool`, *optional*, 默认为 `False`) — 是否对解码后的文本应用英文文本规范化。仅当目标文本为英文时适用。否则，应应用基本文本规范化。

+   `basic_normalize` (`bool`, *optional*, 默认为 `False`) — 是否对解码后的文本应用基本文本规范化。适用于多语言目标文本。

+   `remove_diacritics` (`bool`, *optional*, 默认为 `False`) — 在应用基本文本规范化时是否删除变音符号。删除变音符号可能会破坏解码后文本中的信息，因此应谨慎使用。

+   `kwargs`（其他关键字参数，*optional*） — 将传递给底层模型特定的解码方法。

返回值

`str`

解码后的句子。

将 id 序列转换为字符串，使用 tokenizer 和词汇表，可选择删除特殊标记并清除标记化空格。

类似于执行 `self.convert_tokens_to_string(self.convert_ids_to_tokens(token_ids))`。

## WhisperTokenizerFast

### `class transformers.WhisperTokenizerFast`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper_fast.py#L90)

```py
( vocab_file = None merges_file = None normalizer_file = None tokenizer_file = None unk_token = '<|endoftext|>' bos_token = '<|endoftext|>' eos_token = '<|endoftext|>' add_prefix_space = False language = None task = None predict_timestamps = False **kwargs )
```

参数

+   `vocab_file` (`str`, *optional*) — 词汇文件的路径。

+   `merges_file` (`str`, *optional*) — 合并文件的路径。

+   `normalizer_file` (`str`, *optional*) — 正规化文件的路径。

+   `tokenizer_file` (`str`, *optional*) — 包含加载 tokenizer 所需所有内容的 [tokenizers](https://github.com/huggingface/tokenizers) 文件的路径（通常具有 .json 扩展名）。

+   `unk_token`（`str`，*optional*，默认为``"<|endoftext|>"``）--未知令牌。词汇表中没有的令牌无法转换为 ID，而是设置为该令牌。

+   `bos_token`（`str`，*optional*，默认为``"<|endoftext|>"``）--序列标记的开头。`decoder_start_token_id`用于在生成时将第一个令牌设置为``"<|startoftranscript|>"``。

+   `eos_token`（`str`，*optional*，默认为``"<|endoftext|>"``）--序列结束标记。

+   `add_prefix_space` (`bool`, *optional*, 默认为 `False`) — 是否在输入前添加一个初始空格。这样可以将前导单词视为任何其他单词。（Whisper tokenizer 通过前面的空格检测单词的开头）。

+   `language`（`str`，*可选*）--转录文本的语言。对于多语言语音识别和语音翻译任务，相应的语言 id 标记被附加到序列的开头，例如对于西班牙语，标记`"<|es|>"`被附加到顺序的开头。这只能用于多语言微调。

+   `task`（`str`，*可选*）--要附加在序列开头的任务标识符（如果有）。这应用于多语言微调，“转录”用于语音识别，“翻译”用于语音翻译。

+   `predict_timestamps`（`bool`，*optional*，默认为`False`）--是否省略序列开头的`<|notimestamps|>`标记。

构建一个“快速”的 Whisper tokenizer（由 HuggingFace 的 *tokenizers* 库支持）。

此 tokenizer 继承自 PreTrainedTokenizerFast，其中包含大多数主要方法。用户应参考此超类以获取有关这些方法的更多信息。

#### `set_prefix_tokens`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper_fast.py#L462)

```py
( language: str = None task: str = None predict_timestamps: bool = None )
```

参数

+   `language` (`str`, *optional*, 默认为 `None`) — 转录文本的语言。

+   `task` (`str`, *optional*, 默认为 `None`) — 要附加到序列开头的任务标识符（如果有）。

+   `predict_timestamps`（`bool`，*optional*，默认为`None`）--是否省略序列开头的`<|notimestamps|>`标记。

覆盖附加到标签序列开头的前缀标记。此方法可单独使用以

根据需要更新前缀标记进行微调。示例：

```py
>>> # instantiate the tokenizer and set the prefix token to Spanish
>>> tokenizer = WhisperTokenizerFast.from_pretrained("openai/whisper-tiny", language="spanish")
>>> # now switch the prefix token from Spanish to French
>>> tokenizer.set_prefix_tokens(language="french")
```

#### `build_inputs_with_special_tokens`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper_fast.py#L536)

```py
( token_ids_0 token_ids_1 = None )
```

通过附加 eos_token_id 从序列构建模型输入。

#### `get_special_tokens_mask`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper_fast.py#L544)

```py
( token_ids_0: List token_ids_1: Optional = None already_has_special_tokens: bool = False ) → export const metadata = 'undefined';List[int]
```

参数

+   `token_ids_0`（`List[int]`）— ID 列表。

+   `token_ids_1`（`List[int]`，*可选*）— 序列对的第二个 ID 列表。

+   `already_has_special_tokens`（`bool`，*可选*，默认为`False`）— 标记列表是否已经使用特殊标记格式化为模型。

返回

`List[int]`

整数列表在范围[0, 1]内：1 表示特殊标记，0 表示序列标记。

从没有添加特殊标记的标记列表中检索序列 ID。当使用 tokenizer 的`prepare_for_model`方法添加特殊标记时，将调用此方法。

#### `create_token_type_ids_from_sequences`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/tokenization_utils_base.py#L3302)

```py
( token_ids_0: List token_ids_1: Optional = None ) → export const metadata = 'undefined';List[int]
```

参数

+   `token_ids_0`（`List[int]`）— 第一个标记化序列。

+   `token_ids_1`（`List[int]`，*可选*）— 第二个标记化序列。

返回

`List[int]`

标记类型 ID。

创建与传递的序列对应的标记类型 ID。什么是标记类型 ID？

如果模型有特殊构建方式，则应在子类中重写。

#### `save_vocabulary`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper_fast.py#L447)

```py
( save_directory: str filename_prefix: Optional = None )
```

#### `batch_decode`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/tokenization_utils_base.py#L3692)

```py
( sequences: Union skip_special_tokens: bool = False clean_up_tokenization_spaces: bool = None **kwargs ) → export const metadata = 'undefined';List[str]
```

参数

+   `sequences`（`Union[List[int], List[List[int]], np.ndarray, torch.Tensor, tf.Tensor]`）— 标记化输入 ID 的列表。可以使用`__call__`方法获得。

+   `skip_special_tokens`（`bool`，*可选*，默认为`False`）— 是否在解码中删除特殊标记。

+   `clean_up_tokenization_spaces`（`bool`，*可选*）— 是否清除标记空格。如果为`None`，将默认为`self.clean_up_tokenization_spaces`。

+   `kwargs`（其他关键字参数，*可选*）— 将传递给底层模型特定解码方法。

返回

`List[str]`

解码句子的列表。

通过调用解码将标记 ID 列表的列表转换为字符串列表。

#### `decode`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/tokenization_whisper_fast.py#L338)

```py
( token_ids skip_special_tokens: bool = False clean_up_tokenization_spaces: bool = None output_offsets: bool = False time_precision: float = 0.02 decode_with_timestamps: bool = False normalize: bool = False basic_normalize: bool = False remove_diacritics: bool = False **kwargs ) → export const metadata = 'undefined';str
```

参数

+   `token_ids`（`Union[int, List[int], np.ndarray, torch.Tensor, tf.Tensor]`）— 标记化输入 ID 的列表。可以使用`__call__`方法获得。

+   `skip_special_tokens`（`bool`，*可选*，默认为`False`）— 是否在解码中删除特殊标记。

+   `clean_up_tokenization_spaces`（`bool`，*可选*）— 是否清除标记空格。如果为`None`，将默认为`self.clean_up_tokenization_spaces`（在`tokenizer_config`中可用）。

+   `output_offsets`（`bool`，*可选*，默认为`False`）— 是否输出标记的偏移量。只有在模型预测时间戳时才应设置此选项。

+   `time_precision`（`float`，`可选`，默认为 0.02）— 从标记到时间的转换时间比率。

+   `decode_with_timestamps`（`bool`，*可选*，默认为`False`）— 是否在原始文本中包含时间戳进行解码。

+   `normalize`（`bool`，*可选*，默认为`False`）— 是否对解码文本应用英文文本规范化。仅在目标文本为英文时适用。否则，应应用基本文本规范化。

+   `basic_normalize`（`bool`，*可选*，默认为`False`）— 是否对解码文本应用基本文本规范化。适用于多语言目标文本。

+   `remove_diacritics`（`bool`，*可选*，默认为`False`）— 是否在应用基本文本规范化时删除变音符号。删除变音符号可能会破坏解码文本中的信息，因此应谨慎使用。

+   `kwargs`（额外的关键字参数，*可选*）- 将传递给底层模型特定的解码方法。

返回

`str`

解码后的句子。

将字符串中的 ids 序列转换为字符串，使用 tokenizer 和词汇表，可选择删除特殊标记并清理标记化空格。

类似于执行`self.convert_tokens_to_string(self.convert_ids_to_tokens(token_ids))`。

## WhisperFeatureExtractor

### `class transformers.WhisperFeatureExtractor`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/feature_extraction_whisper.py#L35)

```py
( feature_size = 80 sampling_rate = 16000 hop_length = 160 chunk_length = 30 n_fft = 400 padding_value = 0.0 return_attention_mask = False **kwargs )
```

参数

+   `feature_size`（`int`，默认为 80）- 提取特征的特征维度。

+   `sampling_rate`（`int`，默认为 16000）- 音频文件应数字化的采样率，以赫兹（Hz）表示。

+   `hop_length`（`int`，默认为 160）- 用于获取梅尔频率系数的 STFT 的重叠窗口的长度。

+   `chunk_length`（`int`，默认为 30）- 用于修剪和填充较长或较短音频序列的`sampling_rate`样本的最大块数。

+   `n_fft`（`int`，默认为 400）- 傅立叶变换的大小。

+   `padding_value`（`float`，*可选*，默认为 0.0）- 用于填充音频的填充值。应对应于静音。

构建一个 Whisper 特征提取器。

该特征提取器继承自 SequenceFeatureExtractor，其中包含大部分主要方法。用户应参考此超类以获取有关这些方法的更多信息。

该类使用自定义的 numpy 实现从原始语音中提取 mel 滤波器组特征，该实现应与 pytorch 的`torch.stft`等效。

#### `__call__`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/feature_extraction_whisper.py#L157)

```py
( raw_speech: Union truncation: bool = True pad_to_multiple_of: Optional = None return_tensors: Union = None return_attention_mask: Optional = None padding: Optional = 'max_length' max_length: Optional = None sampling_rate: Optional = None do_normalize: Optional = None **kwargs )
```

参数

+   `raw_speech`（`np.ndarray`，`List[float]`，`List[np.ndarray]`，`List[List[float]]`）- 要填充的序列或序列批次。每个序列可以是 numpy 数组，浮点值列表，numpy 数组列表或浮点值列表的列表。必须是单声道音频，不是立体声，即每个时间步长一个浮点数。

+   `truncation`（`bool`，*可选*，默认为`True`）- 激活截断以将输入序列截断为*max_length*以上的长度为*max_length*。

+   `pad_to_multiple_of`（`int`，*可选*，默认为 None）- 如果设置，将填充序列到提供的值的倍数。

    这对于启用 NVIDIA 硬件上的 Tensor Cores 特别有用，其计算能力为`>= 7.5`（Volta），或者对于受益于序列长度为 128 的 TPUs。

+   `return_attention_mask`（`bool`，*可选*）- 是否返回注意力掩码。如果保持默认设置，将根据特定 feature_extractor 的默认设置返回注意力掩码。

    什么是注意力掩码？

    对于 Whisper 模型，批量推理时应始终传递`attention_mask`，以避免细微的错误。

+   `return_tensors`（`str`或 TensorType，*可选*）- 如果设置，将返回张量而不是 Python 整数列表。可接受的值为：

    +   `'tf'`：返回 TensorFlow `tf.constant`对象。

    +   `'pt'`：返回 PyTorch `torch.Tensor`对象。

    +   `'np'`：返回 Numpy `np.ndarray`对象。

+   `sampling_rate`（`int`，*可选*）- `raw_speech`输入采样的采样率。强烈建议在前向调用时传递`sampling_rate`，以防止静默错误并允许自动语音识别流水线。

+   `padding_value`（`float`，默认为 0.0）- 用于填充填充值/向量的值。

+   `do_normalize`（`bool`，*可选*，默认为`False`）— 是否对输入进行零均值单位方差归一化。归一化可以帮助显著提高模型的性能。

用于对一个或多个序列进行特征化和准备模型的主要方法。如果可用，实现使用 PyTorch 进行 STFT 计算，否则使用较慢的基于 NumPy 的方法。

## WhisperProcessor

### `class transformers.WhisperProcessor`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/processing_whisper.py#L23)

```py
( feature_extractor tokenizer )
```

参数

+   `feature_extractor`（`WhisperFeatureExtractor`）— WhisperFeatureExtractor 的一个实例。特征提取器是必需的输入。

+   `tokenizer`（`WhisperTokenizer`）— WhisperTokenizer 的一个实例。分词器是必需的输入。

构建一个 Whisper 处理器，将 Whisper 特征提取器和 Whisper 分词器包装成一个单一处理器。

WhisperProcessor 提供了 WhisperFeatureExtractor 和 WhisperTokenizer 的所有功能。有关更多信息，请参阅**call**()和 decode()。

#### `__call__`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/processing_whisper.py#L49)

```py
( *args **kwargs )
```

将`audio`参数转发到 WhisperFeatureExtractor 的**call**()，将`text`参数转发到**call**()。请参阅上述两种方法的文档字符串以获取更多信息。

#### `from_pretrained`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/processing_utils.py#L406)

```py
( pretrained_model_name_or_path: Union cache_dir: Union = None force_download: bool = False local_files_only: bool = False token: Union = None revision: str = 'main' **kwargs )
```

参数

+   `pretrained_model_name_or_path`（`str`或`os.PathLike`）— 这可以是：

    +   一个字符串，预训练特征提取器的*模型 ID*，托管在 huggingface.co 上的模型存储库内。有效的模型 ID 可以位于根级别，如`bert-base-uncased`，或者命名空间下的用户或组织名称，如`dbmdz/bert-base-german-cased`。

    +   一个包含使用 save_pretrained()方法保存的特征提取器文件的*目录*路径，例如，`./my_model_directory/`。

    +   保存的特征提取器 JSON *文件*的路径或 URL，例如，`./my_model_directory/preprocessor_config.json`。**kwargs — 传递给 from_pretrained()和`~tokenization_utils_base.PreTrainedTokenizer.from_pretrained`的其他关键字参数。

实例化与预训练模型相关联的处理器。

这个类方法只是调用特征提取器的 from_pretrained()、图像处理器 ImageProcessingMixin 和分词器`~tokenization_utils_base.PreTrainedTokenizer.from_pretrained`方法。有关更多信息，请参阅上述方法的文档字符串。

#### `save_pretrained`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/processing_utils.py#L167)

```py
( save_directory push_to_hub: bool = False **kwargs )
```

参数

+   `save_directory`（`str`或`os.PathLike`）—要保存特征提取器 JSON 文件和分词器文件的目录（如果目录不存在，则将创建该目录）。

+   `push_to_hub`（`bool`，*可选*，默认为`False`）—保存模型后是否将其推送到 Hugging Face 模型中心。您可以使用`repo_id`指定要推送到的存储库（将默认为您的命名空间中的`save_directory`名称）。

+   `kwargs`（`Dict[str, Any]`，*可选*）—传递给 push_to_hub()方法的额外关键字参数。

将此处理器的属性（特征提取器、分词器等）保存在指定目录中，以便可以使用 from_pretrained()方法重新加载它。

此类方法只是调用 save_pretrained()和 save_pretrained()。请参考上述方法的文档字符串以获取更多信息。

#### `batch_decode`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/processing_whisper.py#L83)

```py
( *args **kwargs )
```

此方法将其所有参数转发到 WhisperTokenizer 的 batch_decode()。请参考此方法的文档字符串以获取更多信息。

#### `decode`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/processing_whisper.py#L90)

```py
( *args **kwargs )
```

此方法将其所有参数转发到 WhisperTokenizer 的 decode()。请参考此方法的文档字符串以获取更多信息。

PytorchHide Pytorch 内容

## WhisperModel

### `class transformers.WhisperModel`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L1488)

```py
( config: WhisperConfig )
```

参数

+   `config`（WhisperConfig）—具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

裸的 Whisper 模型输出原始隐藏状态，没有特定的头部。此模型继承自 PreTrainedModel。检查超类文档以获取库为所有模型实现的通用方法（例如下载或保存、调整输入嵌入、修剪头等）。

此模型也是 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取所有与一般用法和行为相关的事项。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L1563)

```py
( input_features: Optional = None attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None past_key_values: Optional = None decoder_inputs_embeds: Optional = None decoder_position_ids: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_features`（形状为`(batch_size, feature_size, sequence_length)`的`torch.FloatTensor`）- 从原始语音波形中提取的浮点值 mel 特征。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，例如通过 soundfile 库（`pip install soundfile`）。要准备好数组为`input_features`，应使用 AutoFeatureExtractor 来提取 mel 特征，填充并转换为`torch.FloatTensor`类型的张量。请参阅`call`()

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`，*可选*）- 用于避免在填充标记索引上执行*SpecAugment*数据增强的掩码。掩码值选定在`[0, 1]`之间：

    +   1 表示标记未被`掩码`，

    +   0 表示标记被`掩码`。

    注意力掩码是什么？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）- 解码器输入序列标记在词汇表中的索引。

    可以使用 WhisperTokenizer 来获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    解码器输入 ID 是什么？

    Whisper 使用`decoder_start_token_id`作为`decoder_input_ids`生成的起始标记。如果使用`past_key_values`，则可以选择仅输入最后的`decoder_input_ids`（请参阅`past_key_values`）。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）- 默认行为：生成一个忽略`decoder_input_ids`中填充标记的张量。因果掩码也将默认使用。

    如果您想要更改填充行为，您应该阅读`modeling_whisper._prepare_decoder_attention_mask`并根据您的需求进行修改。有关默认策略的更多信息，请参阅[BART 论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `head_mask`（形状为`(encoder_layers, encoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于将编码器中注意力模块的选定头部置零的掩码。掩码值选定在`[0, 1]`之间：

    +   1 表示头部未被`掩码`，

    +   0 表示头部被`掩码`。

+   `decoder_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于将解码器中注意力模块的选定头部置零的掩码。掩码值选定在`[0, 1]`之间：

    +   1 表示头部未被`掩码`，

    +   0 表示头部被`掩码`。

+   `cross_attn_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于将交叉注意力模块的选定头部置零的掩码。掩码值选定在`[0, 1]`之间：

    +   1 表示头部未被`掩码`，

    +   0 表示头部被`掩码`。

+   `encoder_outputs`（`tuple(tuple(torch.FloatTensor)`，*可选*）- 元组包括(`last_hidden_state`，*可选*：`hidden_states`，*可选*：`attentions`) `last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*可选*）是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values` (`tuple(tuple(torch.FloatTensor))`, *可选*，当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tuple(torch.FloatTensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码。

    如果使用了`past_key_values`，用户可以选择仅输入最后一个形状为`(batch_size, 1)`的`decoder_input_ids`（那些没有将其过去的键值状态提供给此模型的输入）而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

+   `decoder_inputs_embeds` (`torch.FloatTensor`，形状为`(batch_size, target_sequence_length, hidden_size)`，*可选*) — 可选地，可以直接传递嵌入表示，而不是传递`decoder_input_ids`。如果使用了`past_key_values`，可以选择仅输入最后一个`decoder_inputs_embeds`（参见`past_key_values`）。如果您希望更多地控制如何将`decoder_input_ids`索引转换为相关向量，而不是模型的内部嵌入查找矩阵，则这很有用。

+   `use_cache` (`bool`, *可选*) — 如果设置为`True`，将返回`past_key_values`键值状态，并可用于加速解码（参见`past_key_values`）。

+   `output_attentions` (`bool`, *可选*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量中的`attentions`。

+   `output_hidden_states` (`bool`, *可选*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量中的`hidden_states`。

+   `return_dict` (`bool`, *可选*) — 是否返回一个 ModelOutput 而不是一个普通元组。

返回

transformers.modeling_outputs.Seq2SeqModelOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.Seq2SeqModelOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（WhisperConfig）和输入的不同元素。

+   `last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`) — 模型解码器最后一层的隐藏状态序列输出。

    如果使用了`past_key_values`，则输出形状为`(batch_size, 1, hidden_size)`的序列的最后一个隐藏状态。

+   `past_key_values` (`tuple(tuple(torch.FloatTensor))`, *可选*，当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tuple(torch.FloatTensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码。

+   `decoder_hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型具有嵌入层，则为嵌入的输出+每层的输出）。

    解码器在每一层输出的隐藏状态以及可选的初始嵌入输出。

+   `decoder_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`，*optional*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组。

    编码器在每一层输出的隐藏状态以及可选的初始嵌入输出。

+   `encoder_attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

WhisperModel 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的方法需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行前处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> import torch
>>> from transformers import AutoFeatureExtractor, WhisperModel
>>> from datasets import load_dataset

>>> model = WhisperModel.from_pretrained("openai/whisper-base")
>>> feature_extractor = AutoFeatureExtractor.from_pretrained("openai/whisper-base")
>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")
>>> inputs = feature_extractor(ds[0]["audio"]["array"], return_tensors="pt")
>>> input_features = inputs.input_features
>>> decoder_input_ids = torch.tensor([[1, 1]]) * model.config.decoder_start_token_id
>>> last_hidden_state = model(input_features, decoder_input_ids=decoder_input_ids).last_hidden_state
>>> list(last_hidden_state.shape)
[1, 2, 512]
```

#### `_mask_input_features`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L1520)

```py
( input_features: FloatTensor attention_mask: Optional = None )
```

根据[SpecAugment](https://arxiv.org/abs/1904.08779)沿时间轴和/或特征轴掩盖提取的特征。

## WhisperForConditionalGeneration

### `class transformers.WhisperForConditionalGeneration`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L1658)

```py
( config: WhisperConfig )
```

参数

+   `config` (WhisperConfig) — 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

带有语言建模头的 Whisper 模型。可用于自动语音识别。此模型继承自 PreTrainedModel。查看超类文档以获取库为所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头等）。

此模型还是 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L1696)

```py
( input_features: Optional = None attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None past_key_values: Optional = None decoder_inputs_embeds: Optional = None decoder_position_ids: Optional = None labels: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqLMOutput or tuple(torch.FloatTensor)
```

参数

+   `input_features`（形状为`(batch_size, feature_size, sequence_length)`的`torch.FloatTensor`）- 从原始语音波形中提取的浮点值 mel 特征。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到类型为`List[float]`或`numpy.ndarray`的数组中获得，例如通过 soundfile 库（`pip install soundfile`）。要将数组准备成`input_features`，应使用 AutoFeatureExtractor 来提取 mel 特征，填充并转换为`torch.FloatTensor`类型的张量。参见`call()`

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`，*可选*）- 用于避免在填充标记索引上执行*SpecAugment*数据增强的掩码。掩码值选定在`[0, 1]`范围内：

    +   1 表示头部`未被掩盖`,

    +   0 表示`被掩盖`的标记。

    什么是注意力掩码？

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）- 词汇表中解码器输入序列标记的索引。

    可以使用 WhisperTokenizer 获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是解码器输入 ID？

    Whisper 使用`decoder_start_token_id`作为`decoder_input_ids`生成的起始标记。如果使用`past_key_values`，则可能只需输入最后的`decoder_input_ids`（请参见`past_key_values`）。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`torch.LongTensor`，*可选*）- 默认行为：生成一个忽略`decoder_input_ids`中填充标记的张量。因果掩码也将默认使用。

    如果要更改填充行为，应阅读`modeling_whisper._prepare_decoder_attention_mask`并根据需要进行修改。有关默认策略的更多信息，请参见[BART 论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `head_mask`（形状为`(encoder_layers, encoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于在编码器中使注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`范围内：

    +   1 表示头部`未被掩盖`,

    +   0 表示头部`被掩盖`。

+   `decoder_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于在解码器中使注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`范围内：

    +   1 表示头部`未被掩盖`,

    +   0 表示头部`被掩盖`。

+   `cross_attn_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`torch.Tensor`，*可选*）- 用于使交叉注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`范围内：

    +   1 表示头部`未被掩盖`,

    +   0 表示头部`被掩盖`。

+   `encoder_outputs`（`tuple(tuple(torch.FloatTensor)`，*可选*）— 元组包含（`last_hidden_state`，*可选*：`hidden_states`，*可选*：`attentions`）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*可选*是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）— 元组由长度为`config.n_layers`的`tuple(torch.FloatTensor)`组成，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量，以及 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

    如果使用`past_key_values`，用户可以选择只输入最后一个形状为`(batch_size, 1)`的`decoder_input_ids`（那些没有将它们的过去键值状态提供给此模型的输入），而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

+   `decoder_inputs_embeds`（形状为`(batch_size, target_sequence_length, hidden_size)`的`torch.FloatTensor`，*可选*）— 可选地，可以直接传递嵌入表示，而不是传递`decoder_input_ids`。如果使用`past_key_values`，可以选择仅输入最后一个`decoder_inputs_embeds`（参见`past_key_values`）。如果您想要更多控制如何将`decoder_input_ids`索引转换为相关向量，而不是模型内部的嵌入查找矩阵，则这很有用。

+   `use_cache`（`bool`，*可选*）— 如果设置为`True`，将返回`past_key_values`键值状态，并可用于加速解码（参见`past_key_values`）。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回一个 ModelOutput 而不是一个普通元组。

+   `labels`（形状为`(batch_size, sequence_length)`的`torch.LongTensor`，*可选*）— 用于计算语言建模损失的标签。索引应该在`[0, ..., config.vocab_size]`范围内，或者为-100（参见`input_ids`文档字符串）。索引设置为`-100`的标记将被忽略（掩盖），损失仅计算具有`[0, ..., config.vocab_size]`标签的标记。

返回

transformers.modeling_outputs.Seq2SeqLMOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.Seq2SeqLMOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（WhisperConfig）和输入的不同元素。

+   `loss`（形状为`(1,)`的`torch.FloatTensor`，*可选*，在提供`labels`时返回）— 语言建模损失。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`torch.FloatTensor`）— 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values` (`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tuple(torch.FloatTensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可以用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出和每一层的输出）。

    解码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, hidden_size)`，*可选*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组（如果模型有嵌入层，则为嵌入输出和每一层的输出）。

    编码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

WhisperForConditionalGeneration 的前向方法，覆盖了`__call__`特殊方法。

虽然前向传播的步骤需要在此函数内定义，但应该在之后调用`Module`实例，而不是这个，因为前者会处理运行前后的预处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> import torch
>>> from transformers import AutoProcessor, WhisperForConditionalGeneration
>>> from datasets import load_dataset

>>> processor = AutoProcessor.from_pretrained("openai/whisper-tiny.en")
>>> model = WhisperForConditionalGeneration.from_pretrained("openai/whisper-tiny.en")

>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")

>>> inputs = processor(ds[0]["audio"]["array"], return_tensors="pt")
>>> input_features = inputs.input_features

>>> generated_ids = model.generate(inputs=input_features)

>>> transcription = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]
>>> transcription
' Mr. Quilter is the apostle of the middle classes, and we are glad to welcome his gospel.'
```

#### `generate`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/generation_whisper.py#L250)

```py
( input_features: Optional = None generation_config: Optional = None logits_processor: Optional = None stopping_criteria: Optional = None prefix_allowed_tokens_fn: Optional = None synced_gpus: bool = False return_timestamps: Optional = None task: Optional = None language: Optional = None is_multilingual: Optional = None prompt_ids: Optional = None condition_on_prev_tokens: Optional = None temperature: Union = None compression_ratio_threshold: Optional = None logprob_threshold: Optional = None no_speech_threshold: Optional = None num_segment_frames: Optional = None attention_mask: Optional = None time_precision: float = 0.02 return_token_timestamps: Optional = None return_segments: bool = False return_dict_in_generate: Optional = None **kwargs ) → export const metadata = 'undefined';ModelOutput or torch.LongTensor or Dict[str, Any]
```

参数

+   `input_features`（`torch.Tensor`，形状为`(batch_size, feature_size, sequence_length)`，*可选*）— 浮点值的对数梅尔特征，从原始语音波形中提取。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，*例如*通过 soundfile 库（`pip install soundfile`）。要将数组准备成`input_features`，应使用 AutoFeatureExtractor 来提取梅尔特征，填充并转换为`torch.FloatTensor`类型的张量。详细信息请参见`call`()。

+   `generation_config`（`~generation.GenerationConfig`，*可选*）— 用作生成调用的基本参数化的生成配置。传递给生成的`**kwargs`与`generation_config`的属性匹配将覆盖它们。如果未提供`generation_config`，将使用默认值，其加载优先级如下：1）从`generation_config.json`模型文件中，如果存在；2）从模型配置中。请注意，未指定的参数将继承 GenerationConfig 的默认值，应检查其文档以参数化生成。

+   `logits_processor`（`LogitsProcessorList`，*可选*）— 自定义对数处理器，补充由参数和生成配置构建的默认对数处理器。如果传递的对数处理器已经使用参数或生成配置创建，则会引发错误。此功能适用于高级用户。

+   `stopping_criteria`（`StoppingCriteriaList`，*可选*）— 自定义停止标准，补充由参数和生成配置构建的默认停止标准。如果传递的停止标准已经使用参数或生成配置创建，则会引发错误。此功能适用于高级用户。

+   `prefix_allowed_tokens_fn`（`Callable[[int, torch.Tensor], List[int]]`，*可选*）— 如果提供，此函数将在每个步骤将束搜索限制为仅允许的标记。如果未提供，则不应用约束。此函数接受 2 个参数：批次 ID`batch_id`和`input_ids`。它必须返回一个列表，其中包含下一代步骤的允许标记，条件是批次 ID`batch_id`和先前生成的标记`inputs_ids`。此参数对于受前缀约束的生成很有用，如[自回归实体检索](https://arxiv.org/abs/2010.00904)中所述。

+   `synced_gpus`（`bool`，*可选*，默认为`False`）— 是否继续运行 while 循环直到 max_length（对于 ZeRO 阶段 3 是必需的）

+   `return_timestamps`（`bool`，*可选*）— 是否返回文本的时间戳。这将启用`WhisperTimestampsLogitsProcessor`。

+   `task`（`str`，*可选*）— 用于生成的任务，可以是“translate”或“transcribe”。`model.config.forced_decoder_ids`将相应更新。

+   `language`（`str`，*optional*）--用于生成的语言标记，可以是`<|en|>`、`en`或`english`形式。您可以在`model.generation_config.lang_to_id`字典中找到所有可能的语言标记。

+   `is_multilingual`（`bool`，*可选*）— 模型是否是多语言的。

+   `prompt_ids`（`torch.Tensor`，*可选*）— 通过将文本传递给`get_prompt_ids()`创建的令牌 ID 的秩-1 张量，作为每个块的提示提供。这可用于为转录提供或“提示工程”上下文，例如自定义词汇或专有名词，以使其更有可能正确预测这些单词。它不能与`decoder_start_token_id`结合使用，因为它会覆盖此值。

+   `condition_on_prev_tokens`（`bool`，*可选*）— 仅适用于长篇转录。是否将每个片段的生成条件设置为前一个片段。如[Whisper 论文](https://cdn.openai.com/papers/whisper.pdf)所示，这可以帮助提高性能。

+   `temperature` (`float` 或 `float` 列表，*可选*) — 用于生成的温度。传递单个 `float` 值并且 `do_sample=True` 会激活使用采样进行生成。对于长篇转录，可以通过传递一组浮点值（例如 (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)）来激活温度回退。正如[Whisper 论文](https://cdn.openai.com/papers/whisper.pdf)所示，这可以帮助提高性能。

+   `compression_ratio_threshold` (`float`, *可选*) — 仅适用于长篇转录。如果定义了，将计算每个片段的 zlib 压缩率。如果一个片段的压缩率高于 `compression_ratio_threshold`，则激活温度回退：生成的片段被丢弃，使用更高的温度重复生成。这个特性背后的直觉是，具有非常高压缩率的片段存在大量重复。通过增加温度注入更多随机性可以减少不需要的重复。如果定义了 `compression_ratio_threshold`，请确保 `temperature` 是一个值列表。`compression_ratio_threshold` 的常见值为 1.35。正如[Whisper 论文](https://cdn.openai.com/papers/whisper.pdf)所示，这可以帮助提高性能。

+   `logprob_threshold` (`float`, *可选*) — 仅适用于长篇转录。如果定义了，将计算每个片段的平均对数概率。如果给定片段的对数概率低于 `logprob_threshold`，则激活温度回退：生成的片段被丢弃，使用更高的温度重复生成。这个特性背后的直觉是，低对数概率的片段可以通过增加温度注入更多随机性来改善。如果定义了 `logprob_threshold`，请确保 `temperature` 是一个值列表。`logprob_threshold` 的常见值为 -1.0。正如[Whisper 论文](https://cdn.openai.com/papers/whisper.pdf)所示，这可以帮助提高性能。

+   `no_speech_threshold` (`float`, *可选*) — 仅适用于长篇转录。如果定义了，“无语音”标记与 `logprob_threshold` 结合使用来确定一个片段是否只包含静音。在这种情况下，将跳过该片段的转录。正如[Whisper 论文](https://cdn.openai.com/papers/whisper.pdf)所示，这可以帮助提高性能。

+   `num_segment_frames` (`int`, *可选*) — 单个片段包含的帧数。如果未定义，`num_segment_frames` 默认为模型的步幅乘以最大输入长度。

+   `attention_mask` (`torch.Tensor`, *可选*) — 在使用批量大小 > 1 进行长篇转录时需要传递 `attention_mask`。

+   `time_precision` (`int`, *可选*, 默认为 0.02) — 输出标记的持续时间（秒）。*例如*，0.02 表示生成的标记平均占据 20 毫秒。

+   `return_token_timestamps` (`bool`, *可选*) — 是否返回文本的标记级时间戳。可以与 `return_timestamps` 选项一起使用。要获得单词级时间戳，请使用分词器将标记分组成单词。

+   `return_segments` (`bool`, *可选*, 默认为 `False`) — 是否额外返回所有片段的列表。请注意，只有在进行长篇转录时才能启用此选项。

+   `return_dict_in_generate` (`bool`, *可选*, 默认为 `False`) — 是否返回 ModelOutput 而不仅仅返回生成的标记。请注意，在进行长篇转录时，只有在设置 `return_segments` 为 True 时才能启用 `return_dict_in_generate`。在这种情况下，每个片段的生成输出将添加到每个片段中。

+   `kwargs`（`Dict[str, Any]`，*可选*）-`generate_config`的特定于特定模型的参数化和/或其他模型特定 kwargs，将转发到模型的`forward`函数。如果模型是编码器-解码器模型，则不应以前缀形式指定编码器特定 kwargs，而应以*decoder_*为前缀指定解码器特定 kwargs。

返回

ModelOutput 或`torch.LongTensor`或`Dict[str, Any]`

一个 ModelOutput（如果`return_dict_in_generate=True`或当`config.return_dict_in_generate=True`时）或一个`torch.FloatTensor`或一个段的字典，当`return_segments=True`时。

如果传入的输入> 30 秒/ > 3000 mel 输入特征，并且`return_segments=True`，则返回一个生成的序列 id 字典，称为`sequences`，以及每个生成段的列表。

否则，如果传入的输入<= 30 秒/ >= 3000 mel 输入特征，则可能的 ModelOutput 类型为：

+   GenerateEncoderDecoderOutput，

+   GenerateBeamEncoderDecoderOutput

否则，仅返回生成的输出序列 id。

将对数 mel 输入特征转录或翻译为自回归生成的令牌 id 序列。

大多数生成控制参数都在`generation_config`中设置，如果未传递，则将设置为模型的默认生成配置。您可以通过将相应的参数传递给 generate()来覆盖任何`generation_config`，例如`.generate(inputs, num_beams=4, do_sample=True)`。

有关生成策略和代码示例的概述，请查看以下指南。

示例：

+   *详细转录*：要转录或翻译超过 30 秒的音频，请处理音频文件而不截断，并一次传递所有 mel 特征以生成。

```py
>>> import torch
>>> from transformers import AutoProcessor, WhisperForConditionalGeneration
>>> from datasets import load_dataset, Audio

>>> processor = AutoProcessor.from_pretrained("openai/whisper-tiny.en")
>>> model = WhisperForConditionalGeneration.from_pretrained("openai/whisper-tiny.en")
>>> model.cuda()

>>> # load audios > 30 seconds
>>> ds = load_dataset("distil-whisper/meanwhile", "default")["test"]
>>> # resample to 16kHz
>>> ds = ds.cast_column("audio", Audio(sampling_rate=16000))
>>> # take first 8 audios and retrieve array
>>> audio = ds[:8]["audio"]
>>> audio = [x["array"] for x in audio]

>>> # make sure to NOT truncate the input audio, to return the `attention_mask` and to pad to the longest audio
>>> inputs = processor(audio, return_tensors="pt", truncation=False, padding="longest", return_attention_mask=True, sampling_rate=16_000)
>>> inputs = inputs.to("cuda", torch.float32)

>>> # transcribe audio to ids
>>> generated_ids = model.generate(**inputs)

>>> transcription = processor.batch_decode(generated_ids, skip_special_tokens=True)
>>> transcription[0]
' Folks, if you watch the show, you know, I spent a lot of time right over there. Patiently and astutely scrutinizing the boxwood and mahogany chest set of the day's biggest stories developing the central headline pawns, definitely maneuvering an oso topical night to F6, fainting a classic Sicilian, nade door variation on the news, all the while seeing eight moves deep and patiently marshalling the latest press releases into a fisher's shows in Lip Nitsky attack that culminates in the elegant lethal slow-played, all-passant checkmate that is my nightly monologue. But sometimes, sometimes, folks, I. CHEERING AND APPLAUSE Sometimes I startle away, cubside down in the monkey bars of a condemned playground on a super fun site. Get all hept up on goofballs. Rummage that were discarded tag bag of defective toys. Yank out a fist bowl of disembodied doll limbs, toss them on a stained kid's place mat from a defunct dennies. set up a table inside a rusty cargo container down by the Wharf and challenged toothless drifters to the godless bughouse blitz of tournament that is my segment. Meanwhile!'
```

+   *简化转录*：如果传入的 mel 输入特征< 30 秒，则整个音频将通过一次调用生成进行转录。

```py
>>> import torch
>>> from transformers import AutoProcessor, WhisperForConditionalGeneration
>>> from datasets import load_dataset

>>> processor = AutoProcessor.from_pretrained("openai/whisper-tiny.en")
>>> model = WhisperForConditionalGeneration.from_pretrained("openai/whisper-tiny.en")

>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")

>>> inputs = processor(ds[0]["audio"]["array"], return_tensors="pt")
>>> input_features = inputs.input_features

>>> generated_ids = model.generate(inputs=input_features)

>>> transcription = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]
>>> transcription
' Mr. Quilter is the apostle of the middle classes, and we are glad to welcome his gospel.'
```

## WhisperForCausalLM

### `class transformers.WhisperForCausalLM`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L1865)

```py
( config )
```

参数

+   `config`（WhisperConfig）-模型配置类，具有模型的所有参数。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

Whisper 解码器，顶部带有语言建模头（线性层，其权重与输入嵌入绑定）。

这个模型继承自 PreTrainedModel。检查超类文档以获取库为所有模型实现的通用方法（例如下载或保存，调整输入嵌入大小，修剪头等）。

这个模型也是一个 PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module)子类。将其用作常规 PyTorch 模块，并参考 PyTorch 文档以获取有关一般用法和行为的所有相关信息。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L1903)

```py
( input_ids: LongTensor = None attention_mask: Optional = None encoder_outputs: Optional = None head_mask: Optional = None cross_attn_head_mask: Optional = None past_key_values: Optional = None inputs_embeds: Optional = None labels: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.CausalLMOutputWithCrossAttentions or tuple(torch.FloatTensor)
```

参数

+   `input_ids` (`torch.LongTensor` of shape `(batch_size, sequence_length)`) — 词汇表中输入序列标记的索引。默认情况下将忽略填充。可以使用 AutoTokenizer 获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。什么是输入 ID？

+   `attention_mask` (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*) — 用于避免在填充标记索引上执行注意力的掩码。掩码值选在 `[0, 1]` 中：

    +   1 表示标记是 `not masked`，

    +   0 表示标记是 `masked`。什么是注意力掩码？

+   `encoder_outputs` (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*) — 编码器最后一层的隐藏状态序列。如果模型配置为解码器，则在交叉注意力中使用。

+   `head_mask` (`torch.Tensor` of shape `(decoder_layers, decoder_attention_heads)`, *optional*) — 用于使注意力模块中选择的头部失效的掩码。掩码值选在 `[0, 1]` 中：

    +   1 表示头部未被 `masked`，

    +   0 表示头部被 `masked`。

+   `cross_attn_head_mask` (`torch.Tensor` of shape `(decoder_layers, decoder_attention_heads)`, *optional*) — 用于使交叉注意力模块中选择的头部失效的掩码。掩码值选在 `[0, 1]` 中：

    +   1 表示头部未被 `masked`，

    +   0 表示头部被 `masked`。

+   `past_key_values` (`tuple(tuple(torch.FloatTensor))`, *optional*, 当传递 `use_cache=True` 或 `config.use_cache=True` 时返回) — 长度为 `config.n_layers` 的 `tuple(torch.FloatTensor)` 的元组，每个元组有 2 个形状为 `(batch_size, num_heads, sequence_length, embed_size_per_head)` 的张量和 2 个额外的形状为 `(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)` 的张量。当模型用作序列到序列模型中的解码器时，只有这两个额外的张量是必需的。包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（参见 `past_key_values` 输入）。如果使用了 `past_key_values`，用户可以选择只输入最后一个形状为 `(batch_size, 1)` 的 `decoder_input_ids`（这些没有将其过去的键值状态提供给该模型的标记）而不是所有形状为 `(batch_size, sequence_length)` 的 `decoder_input_ids`。

+   `inputs_embeds` (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*) — 可选地，可以直接传递嵌入表示，而不是传递 `input_ids`。如果您想要更多控制如何将 `input_ids` 索引转换为相关向量，这将非常有用，而不是使用模型的内部嵌入查找矩阵。

+   `labels` (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*) — 用于计算掩码语言建模损失的标签。索引应该在 `[0, ..., config.vocab_size]` 或 -100（参见 `input_ids` 文档字符串）。索引设置为 `-100` 的标记将被忽略（掩码），损失仅计算具有标签在 `[0, ..., config.vocab_size]` 中的标记。

+   `use_cache` (`bool`, *optional*) — 如果设置为 `True`，则会返回 `past_key_values` 键值状态，可用于加速解码（参见 `past_key_values`）。

    +   1 表示标记是 `not masked`，

    +   0 表示标记是 `masked`。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的 `attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的 `hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通的元组。

返回值

transformers.modeling_outputs.CausalLMOutputWithCrossAttentions 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.CausalLMOutputWithCrossAttentions 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`时）包含根据配置（WhisperConfig）和输入的各种元素。

+   `损失` (`torch.FloatTensor`，形状为`(1,)`，*可选*，当提供`labels`时返回) — 语言建模损失（用于下一个标记预测）。

+   `logits` (`torch.FloatTensor`，形状为`(batch_size, sequence_length, config.vocab_size)`) — 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `hidden_states` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回） — 形状为`(batch_size, sequence_length, hidden_size)`的`torch.FloatTensor`元组。

    模型在每个层的输出的隐藏状态加上可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    注意力 softmax 后的自注意力头中的注意力权重，用于计算加权平均值。

+   `cross_attentions` (`tuple(torch.FloatTensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回） — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`torch.FloatTensor`元组。

    注意力 softmax 后的交叉注意力权重，用于计算交叉注意力头中的加权平均值。

+   `past_key_values` (`tuple(tuple(torch.FloatTensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回） — 长度为`config.n_layers`的`torch.FloatTensor`元组的元组，每个元组包含自注意力和交叉注意力层的缓存键、值状态，如果模型用于编码器-解码器设置，则相关。仅在`config.is_decoder = True`时相关。

    包含预先计算的隐藏状态（注意力块中的键和值），可用于加速顺序解码（查看`past_key_values`输入）。

示例：

```py
>>> from transformers import WhisperForCausalLM, WhisperForConditionalGeneration, WhisperProcessor
>>> import torch
>>> from datasets import load_dataset

>>> processor = WhisperProcessor.from_pretrained("openai/whisper-large-v2")
>>> model = WhisperForConditionalGeneration.from_pretrained("openai/whisper-large-v2")

>>> assistant_model = WhisperForCausalLM.from_pretrained("distil-whisper/distil-large-v2")

>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")
>>> sample = ds[0]["audio"]
>>> input_features = processor(
...     sample["array"], sampling_rate=sample["sampling_rate"], return_tensors="pt"
... ).input_features

>>> predicted_ids = model.generate(input_features, assistant_model=assistant_model)

>>> # decode token ids to text
>>> transcription = processor.batch_decode(predicted_ids, skip_special_tokens=True)[0]
>>> transcription
' Mr. Quilter is the apostle of the middle classes and we are glad to welcome his gospel.'
```

## WhisperForAudioClassification

### `class transformers.WhisperForAudioClassification`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L2085)

```py
( config )
```

参数

+   `input_features` (`torch.FloatTensor`，形状为`(batch_size, feature_size, sequence_length)`) — 从原始语音波形中提取的浮点值 mel 特征。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，例如通过 soundfile 库（`pip install soundfile`）。要将数组准备成`input_features`，应使用 AutoFeatureExtractor 来提取 mel 特征，填充并转换为`torch.FloatTensor`类型的张量。请参见`call`()

+   `head_mask` (`torch.Tensor`，形状为`(encoder_layers, encoder_attention_heads)`，*optional*) — 用于使编码器中注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`之间：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `encoder_outputs` (`tuple(tuple(torch.FloatTensor)`, *optional*) — 元组包括(`last_hidden_state`，*optional*: `hidden_states`，*optional*: `attentions`) `last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*optional*)是编码器最后一层输出的隐藏状态序列。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

带有顶部序列分类头部（在汇聚输出上的线性层）的 Whisper 编码器模型，用于类似 SUPERB 关键词识别的任务。

#### `forward`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_whisper.py#L2119)

```py
( input_features: Optional = None head_mask: Optional = None encoder_outputs: Optional = None labels: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) → export const metadata = 'undefined';transformers.modeling_outputs.SequenceClassifierOutput or tuple(torch.FloatTensor)
```

参数

+   `input_features` (`torch.FloatTensor`，形状为`(batch_size, feature_size, sequence_length)`) — 从原始语音波形中提取的浮点值 mel 特征。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，例如通过 soundfile 库（`pip install soundfile`）。要将数组准备成`input_features`，应使用 AutoFeatureExtractor 来提取 mel 特征，填充并转换为`torch.FloatTensor`类型的张量。请参见`call`()

+   `head_mask` (`torch.Tensor`，形状为`(encoder_layers, encoder_attention_heads)`，*optional*) — 用于使编码器中注意力模块的选定头部失效的掩码。掩码值选定在`[0, 1]`之间：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `encoder_outputs` (`tuple(tuple(torch.FloatTensor)`, *optional*) — 元组包括(`last_hidden_state`，*optional*: `hidden_states`，*optional*: `attentions`) `last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*optional*)是编码器最后一层输出的隐藏状态序列。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

+   `labels` (`torch.LongTensor` of shape `(batch_size,)`, *optional*) — 用于计算序列分类/回归损失的标签。索引应在 `[0, ..., config.num_labels - 1]` 中。如果 `config.num_labels == 1`，则计算回归损失（均方损失），如果 `config.num_labels > 1`，则计算分类损失（交叉熵）。

返回

transformers.modeling_outputs.SequenceClassifierOutput 或 `tuple(torch.FloatTensor)`

一个 transformers.modeling_outputs.SequenceClassifierOutput 或一个 `torch.FloatTensor` 元组（如果传递了 `return_dict=False` 或当 `config.return_dict=False` 时）包含各种元素，取决于配置（WhisperConfig）和输入。

+   `loss` (`torch.FloatTensor` of shape `(1,)`, *optional*, 当提供 `labels` 时返回) — 分类（或回归，如果 config.num_labels==1）损失。

+   `logits` (`torch.FloatTensor` of shape `(batch_size, config.num_labels)`) — 分类（或回归，如果 config.num_labels==1）得分（SoftMax 之前）。

+   `hidden_states` (`tuple(torch.FloatTensor)`, *optional*, 当传递 `output_hidden_states=True` 或当 `config.output_hidden_states=True` 时返回) — 形状为 `(batch_size, sequence_length, hidden_size)` 的 `torch.FloatTensor` 元组。

    模型在每一层输出的隐藏状态以及可选的初始嵌入输出。

+   `attentions` (`tuple(torch.FloatTensor)`, *optional*, 当传递 `output_attentions=True` 或当 `config.output_attentions=True` 时返回) — 形状为 `(batch_size, num_heads, sequence_length, sequence_length)` 的 `torch.FloatTensor` 元组。

    注意力权重在注意力 SoftMax 之后，用于计算自注意力头中的加权平均值。

WhisperForAudioClassification 的前向方法，覆盖了 `__call__` 特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用 `Module` 实例，而不是在此处调用，因为前者会处理运行前后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> import torch
>>> from transformers import AutoFeatureExtractor, WhisperForAudioClassification
>>> from datasets import load_dataset

>>> feature_extractor = AutoFeatureExtractor.from_pretrained("sanchit-gandhi/whisper-medium-fleurs-lang-id")
>>> model = WhisperForAudioClassification.from_pretrained("sanchit-gandhi/whisper-medium-fleurs-lang-id")

>>> ds = load_dataset("google/fleurs", "all", split="validation", streaming=True)
>>> sample = next(iter(ds))

>>> inputs = feature_extractor(
...     sample["audio"]["array"], sampling_rate=sample["audio"]["sampling_rate"], return_tensors="pt"
... )
>>> input_features = inputs.input_features

>>> with torch.no_grad():
...     logits = model(input_features).logits

>>> predicted_class_ids = torch.argmax(logits).item()
>>> predicted_label = model.config.id2label[predicted_class_ids]
>>> predicted_label
'Afrikaans'
```

TensorFlowHide TensorFlow 内容

## TFWhisperModel

### `class transformers.TFWhisperModel`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_tf_whisper.py#L1230)

```py
( config: WhisperConfig **kwargs )
```

参数

+   `config` (WhisperConfig) — 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只会加载配置。查看 from_pretrained() 方法以加载模型权重。

裸的 Whisper 模型输出原始隐藏状态，没有特定的头部。此模型继承自 TFPreTrainedModel。查看超类文档以了解库为所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头等）。

此模型也是一个[tf.keras.Model](https://www.tensorflow.org/api_docs/python/tf/keras/Model)子类。将其用作常规的 TF 2.0 Keras 模型，并参考 TF 2.0 文档以获取与一般用法和行为相关的所有事项。

#### `call`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_tf_whisper.py#L1258)

```py
( input_features: TFModelInputType | None = None decoder_input_ids: np.ndarray | tf.Tensor | None = None decoder_attention_mask: np.ndarray | tf.Tensor | None = None decoder_position_ids: np.ndarray | tf.Tensor | None = None head_mask: np.ndarray | tf.Tensor | None = None decoder_head_mask: np.ndarray | tf.Tensor | None = None cross_attn_head_mask: np.ndarray | tf.Tensor | None = None encoder_outputs: Optional[Tuple[Tuple[Union[np.ndarray, tf.Tensor]]]] = None past_key_values: Optional[Tuple[Tuple[Union[np.ndarray, tf.Tensor]]]] = None decoder_inputs_embeds: Optional[Tuple[Union[np.ndarray, tf.Tensor]]] = None use_cache: Optional[bool] = None output_attentions: Optional[bool] = None output_hidden_states: Optional[bool] = None return_dict: Optional[bool] = None training: bool = False ) → export const metadata = 'undefined';transformers.modeling_tf_outputs.TFSeq2SeqModelOutput or tuple(tf.Tensor)
```

参数

+   `input_features`（形状为`(batch_size, feature_size, sequence_length)`的`tf.Tensor`）- 从原始语音波形中提取的 fbank 特征的浮点值。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，例如通过 soundfile 库（`pip install soundfile`）。要将数组准备成`input_features`，应使用 AutoFeatureExtractor 来提取 fbank 特征，填充并转换为`tf.Tensor`类型的张量。请参见`call`()

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`tf.Tensor`，*可选*）- 词汇表中解码器输入序列标记的索引。

    可以使用`SpeechToTextTokenizer`获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是 decoder input IDs？

    SpeechToText 使用`eos_token_id`作为`decoder_input_ids`生成的起始标记。如果使用`past_key_values`，可选择只输入最后的`decoder_input_ids`（参见`past_key_values`）。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`tf.Tensor`，*可选*）- 默认行为：生成一个忽略`decoder_input_ids`中填充标记的张量。因果蒙版也将默认使用。

    如果要更改填充行为，请阅读`modeling_whisper._prepare_decoder_attention_mask`并根据需要进行修改。有关默认策略的更多信息，请参见[论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `head_mask`（形状为`(encoder_layers, encoder_attention_heads)`的`tf.Tensor`，*可选*）- 用于在编码器中使选定注意力模块的头部失效的蒙版。蒙版值选定在`[0, 1]`中：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `decoder_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`tf.Tensor`，*可选*）- 用于在解码器中使选定注意力模块的头部失效的蒙版。蒙版值选定在`[0, 1]`中：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `cross_attn_head_mask`（形状为`(decoder_layers, decoder_attention_heads)`的`tf.Tensor`，*可选*）- 用于使交叉注意力模块的选定头部失效的蒙版。蒙版值选定在`[0, 1]`中：

    +   1 表示头部未被遮蔽，

    +   0 表示头部被遮蔽。

+   `encoder_outputs`（`tuple(tuple(tf.Tensor)`，*可选*）- 元组包含(`last_hidden_state`，*可选*：`hidden_states`，*可选*：`attentions`) `last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*可选*）是编码器最后一层输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values`（`tuple(tuple(tf.Tensor))`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）- 长度为`config.n_layers`的`tuple(tf.Tensor)`的元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

    如果使用`past_key_values`，用户可以选择仅输入最后的`decoder_input_ids`（那些没有将其过去的键值状态提供给此模型的）的形状为`(batch_size, 1)`的张量，而不是形状为`(batch_size, sequence_length)`的所有`decoder_input_ids`。

+   `decoder_inputs_embeds`（形状为`(batch_size, target_sequence_length, hidden_size)`的`tf.Tensor`，*可选*）— 可选地，您可以选择直接传递嵌入表示而不是传递`decoder_input_ids`。如果使用`past_key_values`，则可以选择仅输入最后的`decoder_inputs_embeds`（参见`past_key_values`）。如果您想要更多控制如何将`decoder_input_ids`索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，则这很有用。

+   `use_cache`（`bool`，*可选*）— 如果设置为`True`，则返回`past_key_values`键值状态，并可用于加速解码（参见`past_key_values`）。

+   `output_attentions`（`bool`，*可选*）— 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回的张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）— 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回的张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）— 是否返回 ModelOutput 而不是普通元组。

返回

`transformers.modeling_tf_outputs.TFSeq2SeqModelOutput`或`tuple(tf.Tensor)`

一个 transformers.modeling_tf_outputs.TFSeq2SeqModelOutput 或一个`tf.Tensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（WhisperConfig）和输入而异的各种元素。

+   `last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`）— 模型解码器最后一层的隐藏状态序列。

    如果使用`past_key_values`，则仅输出形状为`(batch_size, 1, hidden_size)`序列的最后一个隐藏状态。

+   `past_key_values`（`List[tf.Tensor]`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）— 长度为`config.n_layers`的`tf.Tensor`列表，每个张量的形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预计算隐藏状态（注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states`（`tuple(tf.Tensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）— 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入的输出，一个用于每层的输出）。

    解码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    解码器交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`，*可选*）— 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(tf.Tensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）— 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入的输出 + 一个用于每层的输出）。

    编码器在每一层的隐藏状态加上初始嵌入输出。

+   `encoder_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）— 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

TFWhisperModel 的前向方法覆盖了`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者会负责运行预处理和后处理步骤，而后者会默默地忽略它们。

示例：

```py
>>> import tensorflow as tf
>>> from transformers import TFWhisperModel, AutoFeatureExtractor
>>> from datasets import load_dataset

>>> model = TFWhisperModel.from_pretrained("openai/whisper-base")
>>> feature_extractor = AutoFeatureExtractor.from_pretrained("openai/whisper-base")
>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")
>>> inputs = feature_extractor(ds[0]["audio"]["array"], return_tensors="tf")
>>> input_features = inputs.input_features
>>> decoder_input_ids = tf.convert_to_tensor([[1, 1]]) * model.config.decoder_start_token_id
>>> last_hidden_state = model(input_features, decoder_input_ids=decoder_input_ids).last_hidden_state
>>> list(last_hidden_state.shape)
[1, 2, 512]
```

## TFWhisperForConditionalGeneration

### `class transformers.TFWhisperForConditionalGeneration`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_tf_whisper.py#L1346)

```py
( config: WhisperConfig **kwargs )
```

参数

+   `config`（WhisperConfig）— 包含模型所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

带有语言建模头的 Whisper 模型。可用于自动语音识别。该模型继承自 TFPreTrainedModel。查看超类文档以获取库为所有模型实现的通用方法（如下载或保存、调整输入嵌入、修剪头等）。

该模型也是一个[tf.keras.Model](https://www.tensorflow.org/api_docs/python/tf/keras/Model)子类。将其用作常规的 TF 2.0 Keras 模型，并参考 TF 2.0 文档以获取与一般用法和行为相关的所有内容。

#### `call`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_tf_whisper.py#L1381)

```py
( input_features: TFModelInputType | None = None decoder_input_ids: np.ndarray | tf.Tensor | None = None decoder_attention_mask: np.ndarray | tf.Tensor | None = None decoder_position_ids: np.ndarray | tf.Tensor | None = None head_mask: np.ndarray | tf.Tensor | None = None decoder_head_mask: np.ndarray | tf.Tensor | None = None cross_attn_head_mask: np.ndarray | tf.Tensor | None = None encoder_outputs: Optional[Tuple[Tuple[Union[np.ndarray, tf.Tensor]]]] = None past_key_values: Optional[Tuple[Tuple[Union[np.ndarray, tf.Tensor]]]] = None decoder_inputs_embeds: Optional[Tuple[Union[np.ndarray, tf.Tensor]]] = None labels: np.ndarray | tf.Tensor | None = None use_cache: Optional[bool] = None output_attentions: Optional[bool] = None output_hidden_states: Optional[bool] = None return_dict: Optional[bool] = None training: bool = False ) → export const metadata = 'undefined';transformers.modeling_tf_outputs.TFSeq2SeqLMOutput or tuple(tf.Tensor)
```

参数

+   `input_features`（形状为`(batch_size, feature_size, sequence_length)`的`tf.Tensor`）— 从原始语音波形中提取的 fbank 特征的浮点值。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，*例如*通过 soundfile 库（`pip install soundfile`）。要准备好数组为`input_features`，应使用 AutoFeatureExtractor 来提取 fbank 特征，填充并转换为`tf.Tensor`类型的张量。参见`call`()

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`tf.Tensor`，*可选*）— 解码器输入序列标记在词汇表中的索引。

    可以使用`SpeechToTextTokenizer`获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。

    什么是解码器输入 ID？

    SpeechToText 使用`eos_token_id`作为`decoder_input_ids`生成的起始标记。如果使用了`past_key_values`，则可能只需输入最后的`decoder_input_ids`（请参阅`past_key_values`）。

+   `decoder_attention_mask` (`tf.Tensor` of shape `(batch_size, target_sequence_length)`, *optional*) — 默认行为：生成一个忽略`decoder_input_ids`中填充标记的张量。因果掩码也将默认使用。

    如果要更改填充行为，应阅读`modeling_whisper._prepare_decoder_attention_mask`并根据需要进行修改。有关默认策略的更多信息，请参阅[论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `head_mask` (`tf.Tensor` of shape `(encoder_layers, encoder_attention_heads)`, *optional*) — 用于使编码器中注意力模块的选择头部失效的掩码。掩码值选在`[0, 1]`：

    +   1 表示头部未被屏蔽，

    +   0 表示头部被屏蔽。

+   `decoder_head_mask` (`tf.Tensor` of shape `(decoder_layers, decoder_attention_heads)`, *optional*) — 用于在解码器中使选择的注意力模块的头部失效的掩码。掩码值选在`[0, 1]`范围内：

    +   1 表示头部未被屏蔽，

    +   0 表示头部被屏蔽。

+   `cross_attn_head_mask` (`tf.Tensor` of shape `(decoder_layers, decoder_attention_heads)`, *optional*) — 用于使交叉注意力模块的选择头部失效的掩码。掩码值选在`[0, 1]`范围内：

    +   1 表示头部未被屏蔽，

    +   0 表示头部被屏蔽。

+   `encoder_outputs` (`tuple(tuple(tf.Tensor)`, *optional*) — 元组包括（`last_hidden_state`，*可选*：`hidden_states`，*可选*：`attentions`）`last_hidden_state`的形状为`(batch_size, sequence_length, hidden_size)`，*可选*）是编码器最后一层的输出的隐藏状态序列。用于解码器的交叉注意力。

+   `past_key_values` (`tuple(tuple(tf.Tensor))`, *optional*, 当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tuple(tf.Tensor)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码。

    如果使用了`past_key_values`，用户可以选择仅输入最后的`decoder_input_ids`（这些未将其过去的键值状态提供给此模型）的形状为`(batch_size, 1)`的张量，而不是所有形状为`(batch_size, sequence_length)`的`decoder_input_ids`。

+   `decoder_inputs_embeds` (`tf.Tensor` of shape `(batch_size, target_sequence_length, hidden_size)`, *optional*) — 可选地，您可以选择直接传递嵌入表示，而不是传递`decoder_input_ids`。如果使用了`past_key_values`，则可能只需输入最后的`decoder_inputs_embeds`（请参阅`past_key_values`）。如果您想要更多控制权，以便将`decoder_input_ids`索引转换为相关向量，而不是使用模型的内部嵌入查找矩阵，则这很有用。

+   `use_cache` (`bool`, *optional*) — 如果设置为`True`，则返回`past_key_values`键值状态，并可用于加速解码（请参阅`past_key_values`）。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量中的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）- 是否返回所有层的隐藏状态。有关更多详细信息，请查看返回张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）- 是否返回 ModelOutput 而不是普通元组。

+   `labels`（形状为`(batch_size, sequence_length)`的`tf.Tensor`，*可选*）- 用于计算语言建模损失的标签。索引应该在`[0, ..., config.vocab_size]`范围内，或者为-100（参见`input_ids`文档字符串）。索引设置为`-100`的标记将被忽略（掩码），损失仅计算具有`[0, ..., config.vocab_size]`标签的标记。

返回

transformers.modeling_tf_outputs.TFSeq2SeqLMOutput 或`tuple(tf.Tensor)`

一个 transformers.modeling_tf_outputs.TFSeq2SeqLMOutput 或一个`tf.Tensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含根据配置（WhisperConfig）和输入的不同元素。

+   `loss`（形状为`(n,)`的`tf.Tensor`，*可选*，当提供`labels`时返回，其中 n 是未屏蔽标签的数量）- 语言建模损失。

+   `logits`（形状为`(batch_size, sequence_length, config.vocab_size)`的`tf.Tensor`）- 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values`（`List[tf.Tensor]`，*可选*，当传递`use_cache=True`或`config.use_cache=True`时返回）- 长度为`config.n_layers`的`tf.Tensor`列表，每个张量形状为`(2, batch_size, num_heads, sequence_length, embed_size_per_head)`。

    包含解码器的预先计算隐藏状态（注意力块中的键和值），可用于加速顺序解码。

+   `decoder_hidden_states`（`tuple(tf.Tensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入的输出 + 一个用于每个层的输出）。

    解码器每层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每个层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均。

+   `cross_attentions`（`tuple(tf.Tensor)`，*可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回）- 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每个层一个）。

    解码器交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均。

+   `encoder_last_hidden_state`（形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`，*可选*）- 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states`（`tuple(tf.Tensor)`，*可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回）- 形状为`(batch_size, sequence_length, hidden_size)`的`tf.Tensor`元组（一个用于嵌入的输出 + 一个用于每个层的输出）。

    编码器每层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(tf.Tensor)`, *optional*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`tf.Tensor`元组（每层一个）。

    编码器的注意权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

TFWhisperForConditionalGeneration 的前向方法，覆盖了`__call__`特殊方法。

尽管前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是在此处调用，因为前者负责运行预处理和后处理步骤，而后者则会默默地忽略它们。

示例：

```py
>>> import tensorflow as tf
>>> from transformers import AutoProcessor, TFWhisperForConditionalGeneration
>>> from datasets import load_dataset

>>> processor = AutoProcessor.from_pretrained("openai/whisper-tiny.en")
>>> model = TFWhisperForConditionalGeneration.from_pretrained("openai/whisper-tiny.en")

>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")

>>> inputs = processor(ds[0]["audio"]["array"], return_tensors="tf")
>>> input_features = inputs.input_features

>>> generated_ids = model.generate(input_features=input_features)

>>> transcription = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]
>>> transcription
' Mr. Quilter is the apostle of the middle classes, and we are glad to welcome his gospel.'
```

JAXHide JAX content

## FlaxWhisperModel

### `class transformers.FlaxWhisperModel`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_flax_whisper.py#L1185)

```py
( config: WhisperConfig input_shape: Tuple = None seed: int = 0 dtype: dtype = <class 'jax.numpy.float32'> _do_init: bool = True gradient_checkpointing: bool = False **kwargs )
```

参数

+   `config` (WhisperConfig) — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

+   `dtype` (`jax.numpy.dtype`, *optional*, defaults to `jax.numpy.float32`) — 计算的数据类型。可以是`jax.numpy.float32`、`jax.numpy.float16`（在 GPU 上）和`jax.numpy.bfloat16`（在 TPU 上）之一。这可以用于在 GPU 或 TPU 上启用混合精度训练或半精度推断。如果指定了`dtype`，则所有计算将使用给定的`dtype`执行。**请注意，这仅指定计算的 dtype，不影响模型参数的 dtype。**如果您希望更改模型参数的 dtype，请参阅 to_fp16()和 to_bf16()。

裸 Whisper 模型变压器输出原始隐藏状态，没有特定的头部。此模型继承自 FlaxPreTrainedModel。检查超类文档以了解库为所有模型实现的通用方法（例如下载或保存、调整输入嵌入、修剪头等）。此模型还是 Flax Linen [flax.nn.Module](https://flax.readthedocs.io/en/latest/_autosummary/flax.nn.module.html)子类。将其用作常规 Flax 模块，并参考 Flax 文档以了解所有与一般用法和行为相关的事项。最后，此模型支持固有的 JAX 功能，例如：

+   [即时（JIT）编译](https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit)

+   [自动微分](https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation)

+   [矢量化](https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap)

+   [并行化](https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap)

#### `__call__`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_flax_whisper.py#L1134)

```py
( input_features: Array decoder_input_ids: Array attention_mask: Optional = None decoder_attention_mask: Optional = None position_ids: Optional = None decoder_position_ids: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxSeq2SeqModelOutput or tuple(torch.FloatTensor)
```

参数

+   `input_features`（形状为`(batch_size, feature_size, sequence_length)`的`numpy.ndarray`）- 从原始语音波形中提取的浮点值 mel 特征。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到类型为`List[float]`或`numpy.ndarray`的数组中获得，例如通过 soundfile 库（`pip install soundfile`）。要将数组准备成`input_features`，应使用 WhisperFeatureExtractor 来提取特征，填充并转换为类型为`numpy.ndarray`的张量。参见`call()`

+   `attention_mask`（形状为`(batch_size, sequence_length)`的`numpy.ndarray`，*可选*）- Whisper 不支持对`input_features`进行掩码，此参数保留以确保兼容性，但不会使用。默认情况下，输入对数 mel 频谱图中的静音将被忽略。

+   `decoder_input_ids`（形状为`(batch_size, target_sequence_length)`的`numpy.ndarray`，*可选*）- 词汇表中解码器输入序列标记的索引。可以使用 WhisperTokenizer 获取索引。有关详细信息，请参见 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call()`。什么是解码器输入 ID？ Whisper 使用`decoder_start_token_id`作为`decoder_input_ids`生成的起始标记。

+   `decoder_attention_mask`（形状为`(batch_size, target_sequence_length)`的`numpy.ndarray`，*可选*）- 默认行为：生成一个张量，忽略`decoder_input_ids`中的填充标记。因果掩码也将默认使用。如果要更改填充行为，应根据需要进行修改。有关默认策略的更多信息，请参见[论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `position_ids`（形状为`(batch_size, sequence_length)`的`numpy.ndarray`，*可选*）- Whisper 在编码器中不使用`position_ids`，因为`input_features`始终具有相同的大小且不使用掩码，但此参数保留以确保兼容性。默认情况下，输入对数 mel 频谱图中的静音将被忽略。

+   `decoder_position_ids`（形状为`(batch_size, sequence_length)`的`numpy.ndarray`，*可选*）- 每个解码器输入序列标记的位置索引。选择范围为`[0, config.max_position_embeddings - 1]`。

+   `output_attentions`（`bool`，*可选*）- 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回的张量下的`attentions`。

+   `output_hidden_states`（`bool`，*可选*）- 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回的张量下的`hidden_states`。

+   `return_dict`（`bool`，*可选*）- 是否返回一个 ModelOutput 而不是一个普通元组。

返回

transformers.modeling_flax_outputs.FlaxSeq2SeqModelOutput 或`tuple(torch.FloatTensor)`

transformers.modeling_flax_outputs.FlaxSeq2SeqModelOutput 或一个`torch.FloatTensor`元组（如果传递了`return_dict=False`或`config.return_dict=False`时）包含各种元素，取决于配置（WhisperConfig）和输入。

+   `last_hidden_state` (`形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`) — 模型解码器最后一层的隐藏状态序列。

    如果使用`past_key_values`，则只输出形状为`(batch_size, 1, hidden_size)`的序列的最后隐藏状态。

+   `past_key_values` (`tuple(tuple(jnp.ndarray))`, *可选的*, 当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tuple(jnp.ndarray)`元组，每个元组有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码（参见`past_key_values`输入）。

+   `decoder_hidden_states` (`tuple(jnp.ndarray)`, *可选的*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入输出，一个用于每一层的输出）。

    解码器在每一层输出时的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(jnp.ndarray)`, *可选的*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(jnp.ndarray)`, *可选的*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`, *可选的*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(jnp.ndarray)`, *可选的*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入输出，一个用于每一层的输出）。

    编码器在每一层输出时的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(jnp.ndarray)`, *可选的*, 当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

`FlaxWhisperPreTrainedModel`的前向方法覆盖了`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者会处理运行前后处理步骤，而后者会默默地忽略它们。

示例:

```py
>>> from transformers import AutoTokenizer, FlaxWhisperModel

>>> tokenizer = AutoTokenizer.from_pretrained("openai/whisper-tiny")
>>> model = FlaxWhisperModel.from_pretrained("openai/whisper-tiny")

>>> inputs = tokenizer("Hello, my dog is cute", return_tensors="jax")
>>> outputs = model(**inputs)

>>> last_hidden_states = outputs.last_hidden_state
```

## FlaxWhisperForConditionalGeneration

### `class transformers.FlaxWhisperForConditionalGeneration`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_flax_whisper.py#L1267)

```py
( config: WhisperConfig input_shape: Tuple = None seed: int = 0 dtype: dtype = <class 'jax.numpy.float32'> _do_init: bool = True gradient_checkpointing: bool = False **kwargs )
```

参数

+   `config` (WhisperConfig) — 模型的所有参数的模型配置类。使用配置文件初始化不会加载与模型相关的权重，只会加载配置。查看 from_pretrained()方法以加载模型权重。

+   `dtype` (`jax.numpy.dtype`, *可选*, 默认为 `jax.numpy.float32`) — 计算的数据类型。可以是`jax.numpy.float32`、`jax.numpy.float16`（在 GPU 上）和`jax.numpy.bfloat16`（在 TPU 上）之一。这可以用于在 GPU 或 TPU 上启用混合精度训练或半精度推断。如果指定了`dtype`，则所有计算将使用给定的`dtype`执行。**请注意，这仅指定计算的数据类型，不影响模型参数的数据类型。**如果要更改模型参数的数据类型，请参阅 to_fp16()和 to_bf16()。

带有语言建模头的 Whisper 模型。此模型继承自 FlaxPreTrainedModel。查看超类文档以了解库为所有模型实现的通用方法（例如下载或保存、调整输入嵌入、修剪头等）。此模型还是 Flax Linen [flax.nn.Module](https://flax.readthedocs.io/en/latest/_autosummary/flax.nn.module.html)子类。将其用作常规 Flax 模块，并参考 Flax 文档以了解与一般用法和行为相关的所有事项。最后，此模型支持内在的 JAX 功能，例如：

+   [即时（JIT）编译](https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit)

+   [自动微分](https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation)

+   [矢量化](https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap)

+   [并行化](https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap)

#### `__call__`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_flax_whisper.py#L1134)

```py
( input_features: Array decoder_input_ids: Array attention_mask: Optional = None decoder_attention_mask: Optional = None position_ids: Optional = None decoder_position_ids: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput or tuple(torch.FloatTensor)
```

参数

+   `input_features` (`numpy.ndarray`，形状为`(batch_size, feature_size, sequence_length)`) — 从原始语音波形中提取的浮点值梅尔特征。原始语音波形可以通过将`.flac`或`.wav`音频文件加载到`List[float]`类型的数组或`numpy.ndarray`中获得，例如通过 soundfile 库（`pip install soundfile`）。要准备数组为`input_features`，应使用 WhisperFeatureExtractor 来提取特征、填充和转换为`numpy.ndarray`类型的张量。参见`call()`。

+   `attention_mask` (`numpy.ndarray`，形状为`(batch_size, sequence_length)`，*可选*) — Whisper 不支持`input_features`的掩码，此参数保留以确保兼容性，但不会使用。默认情况下，输入对数梅尔频谱中的静音将被忽略。

+   `decoder_input_ids` (`numpy.ndarray` of shape `(batch_size, target_sequence_length)`, *optional*) — 词汇表中解码器输入序列标记的索引。可以使用 WhisperTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode()和 PreTrainedTokenizer.`call`()。Whisper 使用`decoder_start_token_id`作为`decoder_input_ids`生成的起始标记。

+   `decoder_attention_mask` (`numpy.ndarray` of shape `(batch_size, target_sequence_length)`, *optional*) — 默认行为：生成一个张量，忽略`decoder_input_ids`中的填充标记。因果掩码也将默认使用。如果要更改填充行为，应根据需要进行修改。有关默认策略的更多信息，请参见[论文](https://arxiv.org/abs/1910.13461)中的图表 1。

+   `position_ids` (`numpy.ndarray` of shape `(batch_size, sequence_length)`, *optional*) — Whisper 在编码器中不使用`position_ids`，因为`input_features`始终具有相同的大小并且不使用掩码，但为了兼容性保留了这个参数。默认情况下，输入对数梅尔频谱中的静音将被忽略。

+   `decoder_position_ids` (`numpy.ndarray` of shape `(batch_size, sequence_length)`, *optional*) — 解码器输入序列标记在位置嵌入中的位置索引。选择范围为`[0, config.max_position_embeddings - 1]`。

+   `output_attentions` (`bool`, *optional*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参见返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *optional*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参见返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *optional*) — 是否返回 ModelOutput 而不是普通元组。

返回

transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput 或`tuple(torch.FloatTensor)`

包含根据配置（WhisperConfig）和输入而组成的各种元素的 transformers.modeling_flax_outputs.FlaxSeq2SeqLMOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）。

+   `logits` (`jnp.ndarray` of shape `(batch_size, sequence_length, config.vocab_size)`) — 语言建模头的预测分数（SoftMax 之前每个词汇标记的分数）。

+   `past_key_values` (`tuple(tuple(jnp.ndarray))`, *optional*, 当传递`use_cache=True`或`config.use_cache=True`时返回) — 长度为`config.n_layers`的`tuple(jnp.ndarray)`元组，每个元组具有 2 个形状为`(batch_size, num_heads, sequence_length, embed_size_per_head)`的张量和 2 个额外的形状为`(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`的张量。

    包含预先计算的隐藏状态（自注意力块和交叉注意力块中的键和值），可用于加速顺序解码。

+   `decoder_hidden_states` (`tuple(jnp.ndarray)`, *optional*, 当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入的输出 + 一个用于每个层的输出）。

    解码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `decoder_attentions` (`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

+   `cross_attentions` (`tuple(jnp.ndarray)`，*可选*，当传递`output_attentions=True`或当`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    解码器的交叉注意力层的注意力权重，在注意力 softmax 之后，用于计算交叉注意力头中的加权平均值。

+   `encoder_last_hidden_state` (`jnp.ndarray`，形状为`(batch_size, sequence_length, hidden_size)`，*可选*) — 模型编码器最后一层的隐藏状态序列。

+   `encoder_hidden_states` (`tuple(jnp.ndarray)`，*可选*，当传递`output_hidden_states=True`或当`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入输出 + 一个用于每一层的输出）。

    编码器在每一层输出的隐藏状态加上初始嵌入输出。

+   `encoder_attentions` (`tuple(jnp.ndarray)`, *可选*, 当传递`output_attentions=True`或当`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    编码器的注意力权重，在注意力 softmax 之后，用于计算自注意力头中的加权平均值。

`FlaxWhisperPreTrainedModel`的前向方法，覆盖了`__call__`特殊方法。

虽然前向传递的步骤需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行前处理和后处理步骤，而后者会默默地忽略它们。

转录示例：

```py
>>> from transformers import WhisperProcessor, FlaxWhisperForConditionalGeneration
>>> from datasets import load_dataset

>>> processor = WhisperProcessor.from_pretrained("openai/whisper-tiny.en")
>>> model = FlaxWhisperForConditionalGeneration.from_pretrained("openai/whisper-tiny.en", from_pt=True)
>>> ds = load_dataset("hf-internal-testing/librispeech_asr_dummy", "clean", split="validation")
>>> inputs = processor(ds[0]["audio"]["array"], return_tensors="np")
>>> input_features = inputs.input_features
>>> generated_ids = model.generate(input_ids=input_features)
>>> transcription = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]
>>> transcription
' Mr. Quilter is the apostle of the middle classes, and we are glad to welcome his gospel.'
```

## FlaxWhisperForAudioClassification

### `class transformers.FlaxWhisperForAudioClassification`

[<来源>](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_flax_whisper.py#L1597)

```py
( config: WhisperConfig input_shape: Tuple = None seed: int = 0 dtype: dtype = <class 'jax.numpy.float32'> _do_init: bool = True gradient_checkpointing: bool = False **kwargs )
```

参数

+   `config`（WhisperConfig） — 具有模型所有参数的模型配置类。使用配置文件初始化不会加载与模型关联的权重，只加载配置。查看 from_pretrained()方法以加载模型权重。

+   `dtype` (`jax.numpy.dtype`，*可选*，默认为`jax.numpy.float32`) — 计算的数据类型。可以是`jax.numpy.float32`、`jax.numpy.float16`（在 GPU 上）和`jax.numpy.bfloat16`（在 TPU 上）中的一种。这可以用于在 GPU 或 TPU 上启用混合精度训练或半精度推断。如果指定了`dtype`，则所有计算将使用给定的`dtype`执行。**请注意，这仅指定计算的数据类型，不影响模型参数的数据类型。**如果您希望更改模型参数的数据类型，请参阅 to_fp16()和 to_bf16()。

带有顶部音频分类头的 Whisper 模型。此模型继承自 FlaxPreTrainedModel。检查超类文档以了解库为所有模型实现的通用方法（例如下载或保存、调整输入嵌入、修剪头等）。此模型还是 Flax Linen [flax.nn.Module](https://flax.readthedocs.io/en/latest/_autosummary/flax.nn.module.html) 子类。将其用作常规 Flax 模块，并参考 Flax 文档以获取有关一般用法和行为的所有相关信息。最后，此模型支持内在的 JAX 功能，例如：

+   [即时 (JIT) 编译](https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit)

+   [自动微分](https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation)

+   [矢量化](https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap)

+   [并行化](https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap)

#### `__call__`

[< source >](https://github.com/huggingface/transformers/blob/v4.37.2/src/transformers/models/whisper/modeling_flax_whisper.py#L1625)

```py
( input_features: Array attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None train: bool = False params: dict = None dropout_rng: PRNGKey = None **kwargs ) → export const metadata = 'undefined';transformers.modeling_flax_outputs.FlaxSequenceClassifierOutput or tuple(torch.FloatTensor)
```

参数

+   `input_features` (`numpy.ndarray` of shape `(batch_size, feature_size, sequence_length)`) — 从原始语音波形中提取的浮点值 mel 特征。原始语音波形可以通过将 `.flac` 或 `.wav` 音频文件加载到类型为 `List[float]` 或 `numpy.ndarray` 的数组中获得，例如通过 soundfile 库 (`pip install soundfile`)。要将数组准备成 `input_features`，应使用 WhisperFeatureExtractor 来提取特征，填充并转换为类型为 `numpy.ndarray` 的张量。参见 `call`()

+   `attention_mask` (`numpy.ndarray` of shape `(batch_size, sequence_length)`, *可选*) — Whisper 不支持对 `input_features` 进行掩码，此参数保留了兼容性，但不会使用。默认情况下，输入对数 mel 频谱图中的静音会被忽略。

+   `decoder_input_ids` (`numpy.ndarray` of shape `(batch_size, target_sequence_length)`, *可选*) — 词汇表中解码器输入序列标记的索引。可以使用 WhisperTokenizer 获取索引。有关详细信息，请参阅 PreTrainedTokenizer.encode() 和 PreTrainedTokenizer.`call`()。什么是解码器输入 ID？ Whisper 使用 `decoder_start_token_id` 作为 `decoder_input_ids` 生成的起始标记。

+   `decoder_attention_mask` (`numpy.ndarray` of shape `(batch_size, target_sequence_length)`, *可选*) — 默认行为：生成一个忽略 `decoder_input_ids` 中填充标记的张量。默认情况下还将使用因果掩码。如果要更改填充行为，应根据需要进行修改。有关默认策略的更多信息，请参见 [论文](https://arxiv.org/abs/1910.13461) 中的图表 1。

+   `position_ids` (`numpy.ndarray` of shape `(batch_size, sequence_length)`, *可选*) — Whisper 在编码器中不使用 `position_ids`，因为 `input_features` 总是相同大小且不使用掩码，但为了兼容性保留了此参数。默认情况下，输入对数 mel 频谱图中的静音会被忽略。

+   `decoder_position_ids` (`numpy.ndarray` of shape `(batch_size, sequence_length)`, *可选*) — 每个解码器输入序列标记在位置嵌入中的位置索引。选择范围为 `[0, config.max_position_embeddings - 1]`。

+   `output_attentions` (`bool`, *可选*) — 是否返回所有注意力层的注意力张量。有关更多详细信息，请参阅返回张量下的`attentions`。

+   `output_hidden_states` (`bool`, *可选*) — 是否返回所有层的隐藏状态。有关更多详细信息，请参阅返回张量下的`hidden_states`。

+   `return_dict` (`bool`, *可选*) — 是否返回一个 ModelOutput 而不是一个普通元组。

返回

transformers.modeling_flax_outputs.FlaxSequenceClassifierOutput 或`tuple(torch.FloatTensor)`

一个 transformers.modeling_flax_outputs.FlaxSequenceClassifierOutput 或一个`torch.FloatTensor`元组（如果传递`return_dict=False`或`config.return_dict=False`）包含各种元素，取决于配置（WhisperConfig）和输入。

+   `logits` (`jnp.ndarray`，形状为`(batch_size, config.num_labels)`) — 分类（如果`config.num_labels==1`则为回归）得分（SoftMax 之前）。

+   `hidden_states` (`tuple(jnp.ndarray)`, *可选*，当传递`output_hidden_states=True`或`config.output_hidden_states=True`时返回) — 形状为`(batch_size, sequence_length, hidden_size)`的`jnp.ndarray`元组（一个用于嵌入的输出 + 一个用于每层的输出）。

    模型在每一层输出的隐藏状态以及初始嵌入输出。

+   `attentions` (`tuple(jnp.ndarray)`, *可选*，当传递`output_attentions=True`或`config.output_attentions=True`时返回) — 形状为`(batch_size, num_heads, sequence_length, sequence_length)`的`jnp.ndarray`元组（每层一个）。

    注意力 softmax 后的注意力权重，用于计算自注意力头中的加权平均值。

FlaxWhisperForAudioClassification 的前向方法，覆盖了`__call__`特殊方法。

尽管前向传递的配方需要在此函数内定义，但应该在此之后调用`Module`实例，而不是这个，因为前者负责运行预处理和后处理步骤，而后者则默默地忽略它们。

转录示例：

```py
>>> import jax.numpy as jnp
>>> from transformers import AutoFeatureExtractor, FlaxWhisperForAudioClassification
>>> from datasets import load_dataset

>>> feature_extractor = AutoFeatureExtractor.from_pretrained("sanchit-gandhi/whisper-medium-fleurs-lang-id")
>>> model = FlaxWhisperForAudioClassification.from_pretrained(
...     "sanchit-gandhi/whisper-medium-fleurs-lang-id", from_pt=True
... )
>>> ds = load_dataset("google/fleurs", "all", split="validation", streaming=True)

>>> sample = next(iter(ds))

>>> inputs = feature_extractor(
...     sample["audio"]["array"], sampling_rate=sample["audio"]["sampling_rate"], return_tensors="np"
... )
>>> input_features = inputs.input_features

>>> logits = model(input_features).logits

>>> predicted_class_ids = jnp.argmax(logits).item()
>>> predicted_label = model.config.id2label[predicted_class_ids]
>>> predicted_label
'af_za'
```
