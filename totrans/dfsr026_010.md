# è®­ç»ƒæ‰©æ•£æ¨¡å‹

> åŸå§‹æ–‡æœ¬ï¼š[https://huggingface.co/docs/diffusers/tutorials/basic_training](https://huggingface.co/docs/diffusers/tutorials/basic_training)

æ— æ¡ä»¶å›¾åƒç”Ÿæˆæ˜¯æ‰©æ•£æ¨¡å‹çš„ä¸€ç§æµè¡Œåº”ç”¨ï¼Œå®ƒç”Ÿæˆçœ‹èµ·æ¥åƒè®­ç»ƒæ•°æ®é›†ä¸­çš„å›¾åƒçš„å›¾åƒã€‚é€šå¸¸ï¼Œé€šè¿‡åœ¨ç‰¹å®šæ•°æ®é›†ä¸Šå¾®è°ƒé¢„è®­ç»ƒæ¨¡å‹å¯ä»¥è·å¾—æœ€ä½³ç»“æœã€‚æ‚¨å¯ä»¥åœ¨[Hub](https://huggingface.co/search/full-text?q=unconditional-image-generation&type=model)ä¸Šæ‰¾åˆ°è®¸å¤šè¿™äº›æ£€æŸ¥ç‚¹ï¼Œä½†å¦‚æœæ‰¾ä¸åˆ°åˆé€‚çš„ï¼Œæ‚¨ä¹Ÿå¯ä»¥è‡ªå·±è®­ç»ƒï¼

æœ¬æ•™ç¨‹å°†æ•™æ‚¨å¦‚ä½•ä»å¤´å¼€å§‹åœ¨[Smithsonian Butterflies](https://huggingface.co/datasets/huggan/smithsonian_butterflies_subset)æ•°æ®é›†çš„å­é›†ä¸Šè®­ç»ƒä¸€ä¸ª[UNet2DModel](/docs/diffusers/v0.26.3/en/api/models/unet2d#diffusers.UNet2DModel)ä»¥ç”Ÿæˆæ‚¨è‡ªå·±çš„ğŸ¦‹è´è¶ğŸ¦‹ã€‚

ğŸ’¡ è¿™ä¸ªè®­ç»ƒæ•™ç¨‹åŸºäº[ä½¿ç”¨ğŸ§¨æ‰©æ•£å™¨è¿›è¡Œè®­ç»ƒ](https://colab.research.google.com/github/huggingface/notebooks/blob/main/diffusers/training_example.ipynb)ç¬”è®°æœ¬ã€‚æœ‰å…³æ‰©æ•£æ¨¡å‹çš„æ›´å¤šç»†èŠ‚å’ŒèƒŒæ™¯ï¼Œæ¯”å¦‚å®ƒä»¬çš„å·¥ä½œåŸç†ï¼Œè¯·æŸ¥çœ‹ç¬”è®°æœ¬ï¼

åœ¨å¼€å§‹ä¹‹å‰ï¼Œè¯·ç¡®ä¿å·²å®‰è£…ğŸ¤— æ•°æ®é›†ä»¥åŠ è½½å’Œé¢„å¤„ç†å›¾åƒæ•°æ®é›†ï¼Œå¹¶å®‰è£…ğŸ¤— Accelerateï¼Œä»¥ç®€åŒ–åœ¨ä»»æ„æ•°é‡çš„GPUä¸Šè¿›è¡Œè®­ç»ƒã€‚ä»¥ä¸‹å‘½ä»¤è¿˜å°†å®‰è£…[TensorBoard](https://www.tensorflow.org/tensorboard)ä»¥å¯è§†åŒ–è®­ç»ƒæŒ‡æ ‡ï¼ˆæ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨[Weights & Biases](https://docs.wandb.ai/)æ¥è·Ÿè¸ªæ‚¨çš„è®­ç»ƒï¼‰ã€‚

```py
# uncomment to install the necessary libraries in Colab
#!pip install diffusers[training]
```

æˆ‘ä»¬é¼“åŠ±æ‚¨ä¸ç¤¾åŒºåˆ†äº«æ‚¨çš„æ¨¡å‹ï¼Œä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œæ‚¨éœ€è¦ç™»å½•åˆ°æ‚¨çš„Hugging Faceå¸æˆ·ï¼ˆå¦‚æœæ‚¨è¿˜æ²¡æœ‰å¸æˆ·ï¼Œè¯·åœ¨[æ­¤å¤„](https://hf.co/join)åˆ›å»ºä¸€ä¸ªï¼ï¼‰ã€‚æ‚¨å¯ä»¥ä»ç¬”è®°æœ¬ç™»å½•ï¼Œå¹¶åœ¨æç¤ºæ—¶è¾“å…¥æ‚¨çš„ä»¤ç‰Œã€‚ç¡®ä¿æ‚¨çš„ä»¤ç‰Œå…·æœ‰å†™å…¥æƒé™ã€‚

```py
>>> from huggingface_hub import notebook_login

>>> notebook_login()
```

æˆ–è€…ä»ç»ˆç«¯ç™»å½•ï¼š

```py
huggingface-cli login
```

ç”±äºæ¨¡å‹æ£€æŸ¥ç‚¹éå¸¸å¤§ï¼Œå®‰è£…[Git-LFS](https://git-lfs.com/)æ¥å¯¹è¿™äº›å¤§æ–‡ä»¶è¿›è¡Œç‰ˆæœ¬æ§åˆ¶ï¼š

```py
!sudo apt -qq install git-lfs
!git config --global credential.helper store
```

## è®­ç»ƒé…ç½®

ä¸ºæ–¹ä¾¿èµ·è§ï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å«è®­ç»ƒè¶…å‚æ•°çš„`TrainingConfig`ç±»ï¼ˆéšæ—¶è°ƒæ•´ï¼‰ï¼š

```py
>>> from dataclasses import dataclass

>>> @dataclass
... class TrainingConfig:
...     image_size = 128  # the generated image resolution
...     train_batch_size = 16
...     eval_batch_size = 16  # how many images to sample during evaluation
...     num_epochs = 50
...     gradient_accumulation_steps = 1
...     learning_rate = 1e-4
...     lr_warmup_steps = 500
...     save_image_epochs = 10
...     save_model_epochs = 30
...     mixed_precision = "fp16"  # `no` for float32, `fp16` for automatic mixed precision
...     output_dir = "ddpm-butterflies-128"  # the model name locally and on the HF Hub

...     push_to_hub = True  # whether to upload the saved model to the HF Hub
...     hub_model_id = "<your-username>/<my-awesome-model>"  # the name of the repository to create on the HF Hub
...     hub_private_repo = False
...     overwrite_output_dir = True  # overwrite the old model when re-running the notebook
...     seed = 0

>>> config = TrainingConfig()
```

## åŠ è½½æ•°æ®é›†

æ‚¨å¯ä»¥ä½¿ç”¨ğŸ¤— æ•°æ®é›†åº“è½»æ¾åŠ è½½[Smithsonian Butterflies](https://huggingface.co/datasets/huggan/smithsonian_butterflies_subset)æ•°æ®é›†ï¼š

```py
>>> from datasets import load_dataset

>>> config.dataset_name = "huggan/smithsonian_butterflies_subset"
>>> dataset = load_dataset(config.dataset_name, split="train")
```

ğŸ’¡ æ‚¨å¯ä»¥ä»[HugGanç¤¾åŒºæ´»åŠ¨](https://huggingface.co/huggan)ä¸­æ‰¾åˆ°å…¶ä»–æ•°æ®é›†ï¼Œæˆ–è€…é€šè¿‡åˆ›å»ºæœ¬åœ°[`ImageFolder`](https://huggingface.co/docs/datasets/image_dataset#imagefolder)æ¥ä½¿ç”¨æ‚¨è‡ªå·±çš„æ•°æ®é›†ã€‚å¦‚æœæ•°æ®é›†æ¥è‡ªHugGanç¤¾åŒºæ´»åŠ¨ï¼Œè¯·å°†`config.dataset_name`è®¾ç½®ä¸ºæ•°æ®é›†çš„å­˜å‚¨åº“IDï¼Œå¦‚æœæ‚¨ä½¿ç”¨è‡ªå·±çš„å›¾åƒï¼Œåˆ™è®¾ç½®ä¸º`imagefolder`ã€‚

ğŸ¤— æ•°æ®é›†ä½¿ç”¨[Image](https://huggingface.co/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Image)åŠŸèƒ½è‡ªåŠ¨è§£ç å›¾åƒæ•°æ®å¹¶å°†å…¶åŠ è½½ä¸º[`PIL.Image`](https://pillow.readthedocs.io/en/stable/reference/Image.html)ï¼Œæˆ‘ä»¬å¯ä»¥å¯è§†åŒ–ï¼š

```py
>>> import matplotlib.pyplot as plt

>>> fig, axs = plt.subplots(1, 4, figsize=(16, 4))
>>> for i, image in enumerate(dataset[:4]["image"]):
...     axs[i].imshow(image)
...     axs[i].set_axis_off()
>>> fig.show()
```

![](../Images/a492ec80a6f208c57e9bd240df33193d.png)

å°½ç®¡å›¾åƒå¤§å°å„ä¸ç›¸åŒï¼Œä½†æ‚¨éœ€è¦é¦–å…ˆå¯¹å…¶è¿›è¡Œé¢„å¤„ç†ï¼š

+   `Resize`å°†å›¾åƒå¤§å°æ›´æ”¹ä¸º`config.image_size`ä¸­å®šä¹‰çš„å¤§å°ã€‚

+   `RandomHorizontalFlip`é€šè¿‡éšæœºé•œåƒå›¾åƒæ¥å¢å¼ºæ•°æ®é›†ã€‚

+   `Normalize`å¯¹äºå°†åƒç´ å€¼é‡æ–°ç¼©æ”¾ä¸º[-1, 1]èŒƒå›´éå¸¸é‡è¦ï¼Œè¿™æ˜¯æ¨¡å‹æ‰€æœŸæœ›çš„ã€‚

```py
>>> from torchvision import transforms

>>> preprocess = transforms.Compose(
...     [
...         transforms.Resize((config.image_size, config.image_size)),
...         transforms.RandomHorizontalFlip(),
...         transforms.ToTensor(),
...         transforms.Normalize([0.5], [0.5]),
...     ]
... )
```

ä½¿ç”¨ğŸ¤— æ•°æ®é›†çš„[set_transform](https://huggingface.co/docs/datasets/v2.17.0/en/package_reference/main_classes#datasets.Dataset.set_transform)æ–¹æ³•åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­åŠ¨æ€åº”ç”¨`preprocess`å‡½æ•°ï¼š

```py
>>> def transform(examples):
...     images = [preprocess(image.convert("RGB")) for image in examples["image"]]
...     return {"images": images}

>>> dataset.set_transform(transform)
```

éšæ—¶å†æ¬¡å¯è§†åŒ–å›¾åƒä»¥ç¡®è®¤å®ƒä»¬å·²è¢«è°ƒæ•´å¤§å°ã€‚ç°åœ¨æ‚¨å·²å‡†å¤‡å¥½å°†æ•°æ®é›†åŒ…è£…åœ¨[DataLoader](https://pytorch.org/docs/stable/data#torch.utils.data.DataLoader)ä¸­è¿›è¡Œè®­ç»ƒï¼

```py
>>> import torch

>>> train_dataloader = torch.utils.data.DataLoader(dataset, batch_size=config.train_batch_size, shuffle=True)
```

## åˆ›å»ºä¸€ä¸ªUNet2DModel

ğŸ§¨ Diffusersä¸­çš„é¢„è®­ç»ƒæ¨¡å‹å¯ä»¥æ ¹æ®æ‚¨æƒ³è¦çš„å‚æ•°è½»æ¾åˆ›å»ºã€‚ä¾‹å¦‚ï¼Œè¦åˆ›å»ºä¸€ä¸ª[UNet2DModel](/docs/diffusers/v0.26.3/en/api/models/unet2d#diffusers.UNet2DModel)ï¼š

```py
>>> from diffusers import UNet2DModel

>>> model = UNet2DModel(
...     sample_size=config.image_size,  # the target image resolution
...     in_channels=3,  # the number of input channels, 3 for RGB images
...     out_channels=3,  # the number of output channels
...     layers_per_block=2,  # how many ResNet layers to use per UNet block
...     block_out_channels=(128, 128, 256, 256, 512, 512),  # the number of output channels for each UNet block
...     down_block_types=(
...         "DownBlock2D",  # a regular ResNet downsampling block
...         "DownBlock2D",
...         "DownBlock2D",
...         "DownBlock2D",
...         "AttnDownBlock2D",  # a ResNet downsampling block with spatial self-attention
...         "DownBlock2D",
...     ),
...     up_block_types=(
...         "UpBlock2D",  # a regular ResNet upsampling block
...         "AttnUpBlock2D",  # a ResNet upsampling block with spatial self-attention
...         "UpBlock2D",
...         "UpBlock2D",
...         "UpBlock2D",
...         "UpBlock2D",
...     ),
... )
```

å¿«é€Ÿæ£€æŸ¥æ ·æœ¬å›¾åƒå½¢çŠ¶æ˜¯å¦ä¸æ¨¡å‹è¾“å‡ºå½¢çŠ¶åŒ¹é…é€šå¸¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ï¼š

```py
>>> sample_image = dataset[0]["images"].unsqueeze(0)
>>> print("Input shape:", sample_image.shape)
Input shape: torch.Size([1, 3, 128, 128])

>>> print("Output shape:", model(sample_image, timestep=0).sample.shape)
Output shape: torch.Size([1, 3, 128, 128])
```

å¤ªæ£’äº†ï¼æ¥ä¸‹æ¥ï¼Œæ‚¨éœ€è¦ä¸€ä¸ªè°ƒåº¦å™¨æ¥å‘å›¾åƒæ·»åŠ ä¸€äº›å™ªå£°ã€‚

## åˆ›å»ºä¸€ä¸ªè°ƒåº¦å™¨

è°ƒåº¦å™¨çš„è¡Œä¸ºå–å†³äºæ‚¨æ˜¯å°†æ¨¡å‹ç”¨äºè®­ç»ƒè¿˜æ˜¯æ¨æ–­ã€‚åœ¨æ¨æ–­æœŸé—´ï¼Œè°ƒåº¦å™¨ä»å™ªå£°ä¸­ç”Ÿæˆå›¾åƒã€‚åœ¨è®­ç»ƒæœŸé—´ï¼Œè°ƒåº¦å™¨æ¥å—æ¨¡å‹è¾“å‡º - æˆ–æ ·æœ¬ - ä»æ‰©æ•£è¿‡ç¨‹ä¸­çš„ç‰¹å®šç‚¹ï¼Œå¹¶æ ¹æ®*å™ªå£°è®¡åˆ’*å’Œ*æ›´æ–°è§„åˆ™*å‘å›¾åƒåº”ç”¨å™ªå£°ã€‚

è®©æˆ‘ä»¬çœ‹çœ‹[DDPMScheduler](/docs/diffusers/v0.26.3/en/api/schedulers/ddpm#diffusers.DDPMScheduler)ï¼Œå¹¶ä½¿ç”¨`add_noise`æ–¹æ³•å‘ä¹‹å‰çš„`sample_image`æ·»åŠ ä¸€äº›éšæœºå™ªå£°ï¼š

```py
>>> import torch
>>> from PIL import Image
>>> from diffusers import DDPMScheduler

>>> noise_scheduler = DDPMScheduler(num_train_timesteps=1000)
>>> noise = torch.randn(sample_image.shape)
>>> timesteps = torch.LongTensor([50])
>>> noisy_image = noise_scheduler.add_noise(sample_image, noise, timesteps)

>>> Image.fromarray(((noisy_image.permute(0, 2, 3, 1) + 1.0) * 127.5).type(torch.uint8).numpy()[0])
```

![](../Images/9c3cadba02429fff4abe5f63e4e8c1d9.png)

æ¨¡å‹çš„è®­ç»ƒç›®æ ‡æ˜¯é¢„æµ‹æ·»åŠ åˆ°å›¾åƒä¸­çš„å™ªå£°ã€‚åœ¨è¿™ä¸€æ­¥çš„æŸå¤±å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼è®¡ç®—ï¼š

```py
>>> import torch.nn.functional as F

>>> noise_pred = model(noisy_image, timesteps).sample
>>> loss = F.mse_loss(noise_pred, noise)
```

## è®­ç»ƒæ¨¡å‹

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‚¨å·²ç»æœ‰äº†å¼€å§‹è®­ç»ƒæ¨¡å‹çš„å¤§éƒ¨åˆ†ç»„ä»¶ï¼Œç°åœ¨å‰©ä¸‹çš„å°±æ˜¯å°†æ‰€æœ‰å†…å®¹æ•´åˆåœ¨ä¸€èµ·ã€‚

é¦–å…ˆï¼Œæ‚¨éœ€è¦ä¸€ä¸ªä¼˜åŒ–å™¨å’Œä¸€ä¸ªå­¦ä¹ ç‡è°ƒåº¦å™¨ï¼š

```py
>>> from diffusers.optimization import get_cosine_schedule_with_warmup

>>> optimizer = torch.optim.AdamW(model.parameters(), lr=config.learning_rate)
>>> lr_scheduler = get_cosine_schedule_with_warmup(
...     optimizer=optimizer,
...     num_warmup_steps=config.lr_warmup_steps,
...     num_training_steps=(len(train_dataloader) * config.num_epochs),
... )
```

ç„¶åï¼Œæ‚¨éœ€è¦ä¸€ç§è¯„ä¼°æ¨¡å‹çš„æ–¹æ³•ã€‚å¯¹äºè¯„ä¼°ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨[DDPMPipeline](/docs/diffusers/v0.26.3/en/api/pipelines/ddpm#diffusers.DDPMPipeline)ç”Ÿæˆä¸€æ‰¹æ ·æœ¬å›¾åƒå¹¶å°†å…¶ä¿å­˜ä¸ºç½‘æ ¼ï¼š

```py
>>> from diffusers import DDPMPipeline
>>> from diffusers.utils import make_image_grid
>>> import os

>>> def evaluate(config, epoch, pipeline):
...     # Sample some images from random noise (this is the backward diffusion process).
...     # The default pipeline output type is `List[PIL.Image]`
...     images = pipeline(
...         batch_size=config.eval_batch_size,
...         generator=torch.manual_seed(config.seed),
...     ).images

...     # Make a grid out of the images
...     image_grid = make_image_grid(images, rows=4, cols=4)

...     # Save the images
...     test_dir = os.path.join(config.output_dir, "samples")
...     os.makedirs(test_dir, exist_ok=True)
...     image_grid.save(f"{test_dir}/{epoch:04d}.png")
```

ç°åœ¨ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ğŸ¤— Accelerateå°†æ‰€æœ‰è¿™äº›ç»„ä»¶åŒ…è£…åœ¨ä¸€ä¸ªè®­ç»ƒå¾ªç¯ä¸­ï¼Œä»¥ä¾¿è¿›è¡Œç®€å•çš„TensorBoardæ—¥å¿—è®°å½•ã€æ¢¯åº¦ç´¯ç§¯å’Œæ··åˆç²¾åº¦è®­ç»ƒã€‚è¦å°†æ¨¡å‹ä¸Šä¼ åˆ°Hubï¼Œè¯·ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è·å–æ‚¨çš„å­˜å‚¨åº“åç§°å’Œä¿¡æ¯ï¼Œç„¶åå°†å…¶æ¨é€åˆ°Hubã€‚

ğŸ’¡ ä¸‹é¢çš„è®­ç»ƒå¾ªç¯å¯èƒ½çœ‹èµ·æ¥ä»¤äººç”Ÿç•ä¸”å†—é•¿ï¼Œä½†å½“æ‚¨åªéœ€ä¸€è¡Œä»£ç å¯åŠ¨è®­ç»ƒæ—¶ï¼Œè¿™å°†æ˜¯å€¼å¾—çš„ï¼å¦‚æœæ‚¨ç­‰ä¸åŠæƒ³è¦å¼€å§‹ç”Ÿæˆå›¾åƒï¼Œè¯·éšæ—¶å¤åˆ¶å¹¶è¿è¡Œä¸‹é¢çš„ä»£ç ã€‚æ‚¨éšæ—¶å¯ä»¥å›æ¥æ›´ä»”ç»†åœ°æ£€æŸ¥è®­ç»ƒå¾ªç¯ï¼Œæ¯”å¦‚å½“æ‚¨åœ¨ç­‰å¾…æ¨¡å‹å®Œæˆè®­ç»ƒæ—¶ã€‚ğŸ¤—

```py
>>> from accelerate import Accelerator
>>> from huggingface_hub import create_repo, upload_folder
>>> from tqdm.auto import tqdm
>>> from pathlib import Path
>>> import os

>>> def train_loop(config, model, noise_scheduler, optimizer, train_dataloader, lr_scheduler):
...     # Initialize accelerator and tensorboard logging
...     accelerator = Accelerator(
...         mixed_precision=config.mixed_precision,
...         gradient_accumulation_steps=config.gradient_accumulation_steps,
...         log_with="tensorboard",
...         project_dir=os.path.join(config.output_dir, "logs"),
...     )
...     if accelerator.is_main_process:
...         if config.output_dir is not None:
...             os.makedirs(config.output_dir, exist_ok=True)
...         if config.push_to_hub:
...             repo_id = create_repo(
...                 repo_id=config.hub_model_id or Path(config.output_dir).name, exist_ok=True
...             ).repo_id
...         accelerator.init_trackers("train_example")

...     # Prepare everything
...     # There is no specific order to remember, you just need to unpack the
...     # objects in the same order you gave them to the prepare method.
...     model, optimizer, train_dataloader, lr_scheduler = accelerator.prepare(
...         model, optimizer, train_dataloader, lr_scheduler
...     )

...     global_step = 0

...     # Now you train the model
...     for epoch in range(config.num_epochs):
...         progress_bar = tqdm(total=len(train_dataloader), disable=not accelerator.is_local_main_process)
...         progress_bar.set_description(f"Epoch {epoch}")

...         for step, batch in enumerate(train_dataloader):
...             clean_images = batch["images"]
...             # Sample noise to add to the images
...             noise = torch.randn(clean_images.shape, device=clean_images.device)
...             bs = clean_images.shape[0]

...             # Sample a random timestep for each image
...             timesteps = torch.randint(
...                 0, noise_scheduler.config.num_train_timesteps, (bs,), device=clean_images.device,
...                 dtype=torch.int64
...             )

...             # Add noise to the clean images according to the noise magnitude at each timestep
...             # (this is the forward diffusion process)
...             noisy_images = noise_scheduler.add_noise(clean_images, noise, timesteps)

...             with accelerator.accumulate(model):
...                 # Predict the noise residual
...                 noise_pred = model(noisy_images, timesteps, return_dict=False)[0]
...                 loss = F.mse_loss(noise_pred, noise)
...                 accelerator.backward(loss)

...                 accelerator.clip_grad_norm_(model.parameters(), 1.0)
...                 optimizer.step()
...                 lr_scheduler.step()
...                 optimizer.zero_grad()

...             progress_bar.update(1)
...             logs = {"loss": loss.detach().item(), "lr": lr_scheduler.get_last_lr()[0], "step": global_step}
...             progress_bar.set_postfix(**logs)
...             accelerator.log(logs, step=global_step)
...             global_step += 1

...         # After each epoch you optionally sample some demo images with evaluate() and save the model
...         if accelerator.is_main_process:
...             pipeline = DDPMPipeline(unet=accelerator.unwrap_model(model), scheduler=noise_scheduler)

...             if (epoch + 1) % config.save_image_epochs == 0 or epoch == config.num_epochs - 1:
...                 evaluate(config, epoch, pipeline)

...             if (epoch + 1) % config.save_model_epochs == 0 or epoch == config.num_epochs - 1:
...                 if config.push_to_hub:
...                     upload_folder(
...                         repo_id=repo_id,
...                         folder_path=config.output_dir,
...                         commit_message=f"Epoch {epoch}",
...                         ignore_patterns=["step_*", "epoch_*"],
...                     )
...                 else:
...                     pipeline.save_pretrained(config.output_dir)
```

å“‡ï¼Œé‚£æ˜¯ç›¸å½“å¤šçš„ä»£ç ï¼ä½†æ˜¯æ‚¨ç»ˆäºå‡†å¤‡å¥½ä½¿ç”¨ğŸ¤— Accelerateçš„[notebook_launcher](https://huggingface.co/docs/accelerate/v0.27.0/en/package_reference/launchers#accelerate.notebook_launcher)å‡½æ•°å¯åŠ¨è®­ç»ƒäº†ã€‚å°†è®­ç»ƒå¾ªç¯ã€æ‰€æœ‰è®­ç»ƒå‚æ•°ä»¥åŠè¦ç”¨äºè®­ç»ƒçš„è¿›ç¨‹æ•°ï¼ˆæ‚¨å¯ä»¥å°†æ­¤å€¼æ›´æ”¹ä¸ºæ‚¨å¯ç”¨çš„GPUæ•°é‡ï¼‰ä¼ é€’ç»™è¯¥å‡½æ•°ï¼š

```py
>>> from accelerate import notebook_launcher

>>> args = (config, model, noise_scheduler, optimizer, train_dataloader, lr_scheduler)

>>> notebook_launcher(train_loop, args, num_processes=1)
```

è®­ç»ƒå®Œæˆåï¼ŒæŸ¥çœ‹æ‚¨çš„æ‰©æ•£æ¨¡å‹ç”Ÿæˆçš„æœ€ç»ˆğŸ¦‹å›¾åƒğŸ¦‹ï¼

```py
>>> import glob

>>> sample_images = sorted(glob.glob(f"{config.output_dir}/samples/*.png"))
>>> Image.open(sample_images[-1])
```

![](../Images/3c1b49414fd4ace41217daf06b50b326.png)

## ä¸‹ä¸€æ­¥

æ— æ¡ä»¶å›¾åƒç”Ÿæˆæ˜¯ä¸€ä¸ªå¯ä»¥è®­ç»ƒçš„ä»»åŠ¡ç¤ºä¾‹ã€‚æ‚¨å¯ä»¥é€šè¿‡è®¿é—®[ğŸ§¨ Diffusers Training Examples](../training/overview)é¡µé¢æ¥æ¢ç´¢å…¶ä»–ä»»åŠ¡å’Œè®­ç»ƒæŠ€æœ¯ã€‚ä»¥ä¸‹æ˜¯æ‚¨å¯ä»¥å­¦åˆ°çš„ä¸€äº›ç¤ºä¾‹ï¼š

+   [æ–‡æœ¬åè½¬](../training/text_inversion)ï¼Œä¸€ç§æ•™å¯¼æ¨¡å‹ç‰¹å®šè§†è§‰æ¦‚å¿µå¹¶å°†å…¶æ•´åˆåˆ°ç”Ÿæˆçš„å›¾åƒä¸­çš„ç®—æ³•ã€‚

+   [DreamBooth](../training/dreambooth)ï¼Œä¸€ç§æ ¹æ®ä¸»é¢˜çš„å‡ å¼ è¾“å…¥å›¾åƒç”Ÿæˆä¸ªæ€§åŒ–å›¾åƒçš„æŠ€æœ¯ã€‚

+   [æŒ‡å—](../training/text2image)æ¥åœ¨è‡ªå·±çš„æ•°æ®é›†ä¸Šå¾®è°ƒç¨³å®šæ‰©æ•£æ¨¡å‹ã€‚

+   [æŒ‡å—](../training/lora)æ¥ä½¿ç”¨LoRAï¼Œä¸€ç§ç”¨äºæ›´å¿«å¾®è°ƒéå¸¸å¤§æ¨¡å‹çš„å†…å­˜é«˜æ•ˆæŠ€æœ¯ã€‚
