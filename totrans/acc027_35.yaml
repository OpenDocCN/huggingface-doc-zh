- en: Low Precision Training Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://huggingface.co/docs/accelerate/concept_guides/low_precision_training](https://huggingface.co/docs/accelerate/concept_guides/low_precision_training)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link href="/docs/accelerate/v0.27.2/en/_app/immutable/assets/0.e3b0c442.css"
    rel="modulepreload"> <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/entry/start.6e0fb178.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/chunks/scheduler.69131cc3.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/chunks/singletons.ac467c20.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/chunks/paths.b2f3aeca.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/entry/app.67e11fc0.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/chunks/index.e1f30d73.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/nodes/0.bfeed9f0.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/chunks/each.e59479a4.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/nodes/12.9381e437.js">
    <link rel="modulepreload" href="/docs/accelerate/v0.27.2/en/_app/immutable/chunks/Heading.0aab6758.js">
  prefs: []
  type: TYPE_NORMAL
- en: The release of new kinds of hardware led to the emergence of new training paradigms
    that better utilize them. Currently, this is in the form of training in 8-bit
    precision using packages such as [TransformersEngine](https://github.com/NVIDIA/TransformerEngine)
    (TE) or [MS-AMP](https://github.com/Azure/MS-AMP/tree/main).
  prefs: []
  type: TYPE_NORMAL
- en: For an introduction to the topics discussed today, we recommend reviewing the
    [low-precision usage guide](../usage_guides/low_precision_training.md) as this
    documentation will reference it regularly.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Below is a quick chart from the MS-AMP documentation showing the different
    bit-precisions for each solution during training:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Optimization Level | Computation(GEMM) | Comm | Weight | Master Weight |
    Weight Gradient | Optimizer States |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| FP16 AMP | FP16 | FP32 | FP32 | N/A | FP32 | FP32+FP32 |'
  prefs: []
  type: TYPE_TB
- en: '| Nvidia TE | FP8 | FP32 | FP32 | N/A | FP32 | FP32+FP32 |'
  prefs: []
  type: TYPE_TB
- en: '| MS-AMP O1 | FP8 | FP8 | FP16 | N/A | FP8 | FP32+FP32 |'
  prefs: []
  type: TYPE_TB
- en: '| MS-AMP O2 | FP8 | FP8 | FP16 | N/A | FP8 | FP8+FP16 |'
  prefs: []
  type: TYPE_TB
- en: '| MS-AMP O3 | FP8 | FP8 | FP8 | FP16 | FP8 | FP8+FP16 |'
  prefs: []
  type: TYPE_TB
- en: TransformersEngine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TransformersEngine` is the first solution to trying to train in 8-bit floating
    point. It works by using drop-in replacement layers for certain ones in a model
    that utilize their FP8-engine to reduce the number of bits (such as 32 to 8) without
    degrading the final accuracy of the model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, ðŸ¤— Accelerate will find and replace the following layers with
    `TransformersEngine` versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nn.LayerNorm` for `te.LayerNorm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nn.Linear` for `te.Linear`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result we wind up with a model that has most of its layers in BF16, while
    some layers are in FP8 reducing some of the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Anecdotally, we have noticed that performance gains donâ€™t really start showing
    when using `TransformerEngine` until a large majority of the layers in the model
    are made up of those two layers to replace. As a result, only larger models have
    shown performance improvements when the number of parameters is around and upwards
    of a few billion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TransformerEngine` can receive many different arguments that customize
    how it performs FP8 calculations and what they do. A full list of the arguments
    is available below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`margin`: The margin to use for the gradient scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interval`: The interval to use for how often the scaling factor is recomputed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fp8_format``: The format to use for the FP8 recipe. Must be one of` E4M3`or`HYBRID`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amax_history_len`: The length of the history to use for the scaling factor
    computation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amax_compute_algo`: The algorithm to use for the scaling factor computation.
    Must be one of `max` or `most_recent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override_linear_precision`: Whether or not to execute `fprop`, `dgrad`, and
    `wgrad` GEMMS in higher precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can customize each of these as part of [utils.FP8RecipeKwargs](/docs/accelerate/v0.27.2/en/package_reference/utilities#accelerate.utils.FP8RecipeKwargs)
    to help optimize performance of your models.
  prefs: []
  type: TYPE_NORMAL
- en: If we notice in the chart mentioned earlier, TE simply casts the computation
    layers into FP8, while everything else is in FP32\. As a result this winds up
    utilizing the most memory but does so with the benefit of guaranteeing the least
    amount of loss in end accuracy during training.
  prefs: []
  type: TYPE_NORMAL
- en: MS-AMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MS-AMP takes a different approach to `TransformersEngine` by providing three
    different optimization levels to convert more operations in FP8 or FP16.
  prefs: []
  type: TYPE_NORMAL
- en: The base optimization level (`O1`), passes communications of the weights (such
    as in DDP) in FP8, stores the weights of the model in FP16, and leaves the optimizer
    states in FP32\. The main benefit of this optimization level is that we can reduce
    the communication bandwidth by essentially half. Additionally, more GPU memory
    is saved due to 1/2 of everything being cast in FP8, and the weights being cast
    to FP16\. Notably, both the optimizer states remain in FP32.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second optimization level (`O2`) improves upon this by also reducing the
    precision of the optimizer states. One is in FP8 while the other is in FP16\.
    Generally itâ€™s been shown that this will only provide a net-gain of no degraded
    end accuracy, increased training speed, and reduced memory as now every state
    is either in FP16 or FP8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, MS-AMP has a third optimization level (`O3`) which helps during DDP
    scenarios such as DeepSpeed. The weights of the model in memory are fully cast
    to FP8, and the master weights are now stored in FP16\. This fully reduces memory
    by the highest factor as now not only is almost everything in FP8, only two states
    are left in FP16\. Currently, only DeepSpeed versions up through 0.9.2 are supported,
    so this capability is not included in the ðŸ¤— Accelerate integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining the two
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More experiments need to be performed but itâ€™s been noted that combining both
    MS-AMP and TransformersEngine can lead to the highest throughput by relying on
    NVIDIAâ€™s optimized FP8 operators and utilizing how MS-AMP reduces the memory overhead.
  prefs: []
  type: TYPE_NORMAL
