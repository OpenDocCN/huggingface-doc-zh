["```py\n( vocab_size = None hidden_size = 1024 num_hidden_layers = 24 num_attention_heads = 16 intermediate_size = 4096 feature_projection_input_dim = 160 hidden_act = 'swish' hidden_dropout = 0.0 activation_dropout = 0.0 attention_dropout = 0.0 feat_proj_dropout = 0.0 final_dropout = 0.1 layerdrop = 0.1 initializer_range = 0.02 layer_norm_eps = 1e-05 apply_spec_augment = True mask_time_prob = 0.05 mask_time_length = 10 mask_time_min_masks = 2 mask_feature_prob = 0.0 mask_feature_length = 10 mask_feature_min_masks = 0 ctc_loss_reduction = 'sum' ctc_zero_infinity = False use_weighted_layer_sum = False classifier_proj_size = 768 tdnn_dim = (512, 512, 512, 512, 1500) tdnn_kernel = (5, 3, 3, 1, 1) tdnn_dilation = (1, 2, 3, 1, 1) xvector_output_dim = 512 pad_token_id = 0 bos_token_id = 1 eos_token_id = 2 add_adapter = False adapter_kernel_size = 3 adapter_stride = 2 num_adapter_layers = 1 adapter_act = 'relu' use_intermediate_ffn_before_adapter = False output_hidden_size = None position_embeddings_type = 'relative_key' rotary_embedding_base = 10000 max_source_positions = 5000 left_max_position_embeddings = 64 right_max_position_embeddings = 8 conv_depthwise_kernel_size = 31 conformer_conv_dropout = 0.1 **kwargs )\n```", "```py\n>>> from transformers import Wav2Vec2BertConfig, Wav2Vec2BertModel\n\n>>> # Initializing a Wav2Vec2Bert facebook/wav2vec2-bert-rel-pos-large style configuration\n>>> configuration = Wav2Vec2BertConfig()\n\n>>> # Initializing a model (with random weights) from the facebook/wav2vec2-bert-rel-pos-large style configuration\n>>> model = Wav2Vec2BertModel(configuration)\n\n>>> # Accessing the model configuration\n>>> configuration = model.config\n```", "```py\n( feature_extractor tokenizer )\n```", "```py\n( audio = None text = None **kwargs ) \u2192 export const metadata = 'undefined';BatchEncoding\n```", "```py\n( input_features = None labels = None **kwargs )\n```", "```py\n( pretrained_model_name_or_path **kwargs )\n```", "```py\n( save_directory push_to_hub: bool = False **kwargs )\n```", "```py\n( *args **kwargs )\n```", "```py\n( *args **kwargs )\n```", "```py\n( config: Wav2Vec2BertConfig )\n```", "```py\n( input_features: Optional attention_mask: Optional = None mask_time_indices: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) \u2192 export const metadata = 'undefined';transformers.modeling_outputs.Wav2Vec2BaseModelOutput or tuple(torch.FloatTensor)\n```", "```py\n>>> from transformers import AutoProcessor, Wav2Vec2BertModel\n>>> import torch\n>>> from datasets import load_dataset\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> processor = AutoProcessor.from_pretrained(\"hf-audio/wav2vec2-bert-CV16-en\")\n>>> model = Wav2Vec2BertModel.from_pretrained(\"hf-audio/wav2vec2-bert-CV16-en\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = processor(dataset[0][\"audio\"][\"array\"], sampling_rate=sampling_rate, return_tensors=\"pt\")\n>>> with torch.no_grad():\n...     outputs = model(**inputs)\n\n>>> last_hidden_states = outputs.last_hidden_state\n>>> list(last_hidden_states.shape)\n[1, 146, 1024]\n```", "```py\n( config target_lang: Optional = None )\n```", "```py\n( input_features: Optional attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None labels: Optional = None ) \u2192 export const metadata = 'undefined';transformers.modeling_outputs.CausalLMOutput or tuple(torch.FloatTensor)\n```", "```py\n>>> from transformers import AutoProcessor, Wav2Vec2BertForCTC\n>>> from datasets import load_dataset\n>>> import torch\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> processor = AutoProcessor.from_pretrained(\"hf-audio/wav2vec2-bert-CV16-en\")\n>>> model = Wav2Vec2BertForCTC.from_pretrained(\"hf-audio/wav2vec2-bert-CV16-en\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = processor(dataset[0][\"audio\"][\"array\"], sampling_rate=sampling_rate, return_tensors=\"pt\")\n>>> with torch.no_grad():\n...     logits = model(**inputs).logits\n>>> predicted_ids = torch.argmax(logits, dim=-1)\n\n>>> # transcribe speech\n>>> transcription = processor.batch_decode(predicted_ids)\n>>> transcription[0]\n'mr quilter is the apostle of the middle classes and we are glad to welcome his gospel'\n\n>>> inputs[\"labels\"] = processor(text=dataset[0][\"text\"], return_tensors=\"pt\").input_ids\n\n>>> # compute loss\n>>> loss = model(**inputs).loss\n>>> round(loss.item(), 2)\n17.04\n```", "```py\n( config )\n```", "```py\n( input_features: Optional attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None labels: Optional = None ) \u2192 export const metadata = 'undefined';transformers.modeling_outputs.SequenceClassifierOutput or tuple(torch.FloatTensor)\n```", "```py\n>>> from transformers import AutoFeatureExtractor, Wav2Vec2BertForSequenceClassification\n>>> from datasets import load_dataset\n>>> import torch\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> feature_extractor = AutoFeatureExtractor.from_pretrained(\"facebook/w2v-bert-2.0\")\n>>> model = Wav2Vec2BertForSequenceClassification.from_pretrained(\"facebook/w2v-bert-2.0\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = feature_extractor(dataset[0][\"audio\"][\"array\"], sampling_rate=sampling_rate, return_tensors=\"pt\")\n\n>>> with torch.no_grad():\n...     logits = model(**inputs).logits\n\n>>> predicted_class_ids = torch.argmax(logits, dim=-1).item()\n>>> predicted_label = model.config.id2label[predicted_class_ids]\n\n>>> # compute loss - target_label is e.g. \"down\"\n>>> target_label = model.config.id2label[0]\n>>> inputs[\"labels\"] = torch.tensor([model.config.label2id[target_label]])\n>>> loss = model(**inputs).loss\n```", "```py\n( config )\n```", "```py\n( input_features: Optional attention_mask: Optional = None labels: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) \u2192 export const metadata = 'undefined';transformers.modeling_outputs.TokenClassifierOutput or tuple(torch.FloatTensor)\n```", "```py\n>>> from transformers import AutoFeatureExtractor, Wav2Vec2BertForAudioFrameClassification\n>>> from datasets import load_dataset\n>>> import torch\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> feature_extractor = AutoFeatureExtractor.from_pretrained(\"facebook/w2v-bert-2.0\")\n>>> model = Wav2Vec2BertForAudioFrameClassification.from_pretrained(\"facebook/w2v-bert-2.0\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = feature_extractor(dataset[0][\"audio\"][\"array\"], return_tensors=\"pt\", sampling_rate=sampling_rate)\n>>> with torch.no_grad():\n...     logits = model(**inputs).logits\n\n>>> probabilities = torch.sigmoid(logits[0])\n>>> # labels is a one-hot array of shape (num_frames, num_speakers)\n>>> labels = (probabilities > 0.5).long()\n```", "```py\n( config )\n```", "```py\n( input_features: Optional attention_mask: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None labels: Optional = None ) \u2192 export const metadata = 'undefined';transformers.modeling_outputs.XVectorOutput or tuple(torch.FloatTensor)\n```", "```py\n>>> from transformers import AutoFeatureExtractor, Wav2Vec2BertForXVector\n>>> from datasets import load_dataset\n>>> import torch\n\n>>> dataset = load_dataset(\"hf-internal-testing/librispeech_asr_demo\", \"clean\", split=\"validation\")\n>>> dataset = dataset.sort(\"id\")\n>>> sampling_rate = dataset.features[\"audio\"].sampling_rate\n\n>>> feature_extractor = AutoFeatureExtractor.from_pretrained(\"facebook/w2v-bert-2.0\")\n>>> model = Wav2Vec2BertForXVector.from_pretrained(\"facebook/w2v-bert-2.0\")\n\n>>> # audio file is decoded on the fly\n>>> inputs = feature_extractor(\n...     [d[\"array\"] for d in dataset[:2][\"audio\"]], sampling_rate=sampling_rate, return_tensors=\"pt\", padding=True\n... )\n>>> with torch.no_grad():\n...     embeddings = model(**inputs).embeddings\n\n>>> embeddings = torch.nn.functional.normalize(embeddings, dim=-1).cpu()\n\n>>> # the resulting embeddings can be used for cosine similarity-based retrieval\n>>> cosine_sim = torch.nn.CosineSimilarity(dim=-1)\n>>> similarity = cosine_sim(embeddings[0], embeddings[1])\n>>> threshold = 0.7  # the optimal threshold is dataset-dependent\n>>> if similarity < threshold:\n...     print(\"Speakers are not the same!\")\n```"]