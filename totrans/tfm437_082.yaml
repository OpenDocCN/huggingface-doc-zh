- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Original text: [https://huggingface.co/docs/transformers/v4.37.2/en/debugging](https://huggingface.co/docs/transformers/v4.37.2/en/debugging)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en:  
    
    
    
    
    
    
    
    
    
    
    
    
  prefs: []
  type: TYPE_NORMAL
- en: Training on multiple GPUs can be a tricky endeavor whether you’re running into
    installation issues or communication problems between your GPUs. This debugging
    guide covers some issues you may run into and how to resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: DeepSpeed CUDA installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re using DeepSpeed, you’ve probably already installed it with the following
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: DeepSpeed compiles CUDA C++ code and it can be a potential source of errors
    when building PyTorch extensions that require CUDA. These errors depend on how
    CUDA is installed on your system, and this section focuses on PyTorch built with
    *CUDA 10.2*.
  prefs: []
  type: TYPE_NORMAL
- en: For any other installation issues, please [open an issue](https://github.com/microsoft/DeepSpeed/issues)
    with the DeepSpeed team.
  prefs: []
  type: TYPE_NORMAL
- en: Non-identical CUDA toolkits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyTorch comes with its own CUDA toolkit, but to use DeepSpeed with PyTorch,
    you need to have an identical version of CUDA installed system-wide. For example,
    if you installed PyTorch with `cudatoolkit==10.2` in your Python environment,
    then you’ll also need to have CUDA 10.2 installed system-wide. If you don’t have
    CUDA installed system-wide, you should install it first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact location may vary from system to system, but `usr/local/cuda-10.2`
    is the most common location on many Unix systems. When CUDA is correctly setup
    and added to your `PATH` environment variable, you can find the installation location
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Multiple CUDA toolkits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may also have more than one CUDA toolkit installed system-wide.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Typically, package installers set the paths to whatever the last version was
    installed. If the package build fails because it can’t find the right CUDA version
    (despite it being installed system-wide already), then you need to configure the
    `PATH` and `LD_LIBRARY_PATH` environment variables to point to the correct path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the contents of these environment variables first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`PATH` lists the locations of the executables and `LD_LIBRARY_PATH` lists where
    to look for shared libraries. Earlier entries are prioritized over later ones,
    and `:` is used to separate multiple entries. To tell the build program where
    to find the specific CUDA toolkit you want, insert the correct path to list first.
    This command prepends rather than overwrites the existing values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In addition, you should also check the directories you assign actually exist.
    The `lib64` sub-directory contains various CUDA `.so` objects (like `libcudart.so`)
    and while it is unlikely your system names them differently, you should check
    the actual names and change them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Older CUDA versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, older CUDA versions may refuse to build with newer compilers. For
    example, if you have `gcc-9` but CUDA wants `gcc-7`. Usually, installing the latest
    CUDA toolkit enables support for the newer compiler.
  prefs: []
  type: TYPE_NORMAL
- en: You could also install an older version of the compiler in addition to the one
    you’re currently using (or it may already be installed but it’s not used by default
    and the build system can’t see it). To resolve this, you can create a symlink
    to give the build system visibility to the older compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Multi-GPU Network Issues Debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When training or inferencing with `DistributedDataParallel` and multiple GPU,
    if you run into issue of inter-communication between processes and/or nodes, you
    can use the following script to diagnose network issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For example to test how 2 GPUs interact do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If both processes can talk to each and allocate GPU memory each will print an
    OK status.
  prefs: []
  type: TYPE_NORMAL
- en: For more GPUs or nodes adjust the arguments in the script.
  prefs: []
  type: TYPE_NORMAL
- en: You will find a lot more details inside the diagnostics script and even a recipe
    to how you could run it in a SLURM environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional level of debug is to add `NCCL_DEBUG=INFO` environment variable
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will dump a lot of NCCL-related debug information, which you can then search
    online if you find that some problems are reported. Or if you’re not sure how
    to interpret the output you can share the log file in an Issue.
  prefs: []
  type: TYPE_NORMAL
- en: Underflow and Overflow Detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This feature is currently available for PyTorch-only.
  prefs: []
  type: TYPE_NORMAL
- en: For multi-GPU training it requires DDP (`torch.distributed.launch`).
  prefs: []
  type: TYPE_NORMAL
- en: This feature can be used with any `nn.Module`-based model.
  prefs: []
  type: TYPE_NORMAL
- en: If you start getting `loss=NaN` or the model inhibits some other abnormal behavior
    due to `inf` or `nan` in activations or weights one needs to discover where the
    first underflow or overflow happens and what led to it. Luckily you can accomplish
    that easily by activating a special module that will do the detection automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using [Trainer](/docs/transformers/v4.37.2/en/main_classes/trainer#transformers.Trainer),
    you just need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: to the normal command line arguments, or pass `debug="underflow_overflow"` when
    creating the [TrainingArguments](/docs/transformers/v4.37.2/en/main_classes/trainer#transformers.TrainingArguments)
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using your own training loop or another Trainer you can accomplish
    the same with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[DebugUnderflowOverflow](/docs/transformers/v4.37.2/en/internal/trainer_utils#transformers.debug_utils.DebugUnderflowOverflow)
    inserts hooks into the model that immediately after each forward call will test
    input and output variables and also the corresponding module’s weights. As soon
    as `inf` or `nan` is detected in at least one element of the activations or weights,
    the program will assert and print a report like this (this was caught with `google/mt5-small`
    under fp16 mixed precision):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The example output has been trimmed in the middle for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: The second column shows the value of the absolute largest element, so if you
    have a closer look at the last few frames, the inputs and outputs were in the
    range of `1e4`. So when this training was done under fp16 mixed precision the
    very last step overflowed (since under `fp16` the largest number before `inf`
    is `64e3`). To avoid overflows under `fp16` the activations must remain way below
    `1e4`, because `1e4 * 1e4 = 1e8` so any matrix multiplication with large activations
    is going to lead to a numerical overflow condition.
  prefs: []
  type: TYPE_NORMAL
- en: At the very start of the trace you can discover at which batch number the problem
    occurred (here `Detected inf/nan during batch_number=0` means the problem occurred
    on the first batch).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each reported frame starts by declaring the fully qualified entry for the corresponding
    module this frame is reporting for. If we look just at this frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `encoder.block.2.layer.1.layer_norm` indicates that it was a layer norm
    for the first layer, of the second block of the encoder. And the specific calls
    of the `forward` is `T5LayerNorm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the last few frames of that report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The last frame reports for `Dropout.forward` function with the first entry for
    the only input and the second for the only output. You can see that it was called
    from an attribute `dropout` inside `DenseReluDense` class. We can see that it
    happened during the first layer, of the 2nd block, during the very first batch.
    Finally, the absolute largest input elements was `6.27e+04` and same for the output
    was `inf`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see here, that `T5DenseGatedGeluDense.forward` resulted in output activations,
    whose absolute max value was around 62.7K, which is very close to fp16’s top limit
    of 64K. In the next frame we have `Dropout` which renormalizes the weights, after
    it zeroed some of the elements, which pushes the absolute max value to more than
    64K, and we get an overflow (`inf`).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see it’s the previous frames that we need to look into when the numbers
    start going into very large for fp16 numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s match the report to the code from `models/t5/modeling_t5.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now it’s easy to see the `dropout` call, and all the previous calls as well.
  prefs: []
  type: TYPE_NORMAL
- en: Since the detection is happening in a forward hook, these reports are printed
    immediately after each `forward` returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the full report, to act on it and to fix the problem, we need
    to go a few frames up where the numbers started to go up and most likely switch
    to the `fp32` mode here, so that the numbers don’t overflow when multiplied or
    summed up. Of course, there might be other solutions. For example, we could turn
    off `amp` temporarily if it’s enabled, after moving the original `forward` into
    a helper wrapper, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the automatic detector only reports on inputs and outputs of full frames,
    once you know where to look, you may want to analyse the intermediary stages of
    any specific `forward` function as well. In such a case you can use the `detect_overflow`
    helper function to inject the detector where you want it, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we added 2 of these and now we track if `inf` or `nan` for
    `forwarded_states` was detected somewhere in between.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the detector already reports these because each of the calls in the
    example above is a `nn.Module`, but let’s say if you had some local direct calculations
    this is how you’d do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you’re instantiating the debugger in your own code, you can
    adjust the number of frames printed from its default, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Specific batch absolute min and max value tracing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same debugging class can be used for per-batch tracing with the underflow/overflow
    detection feature turned off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to watch the absolute min and max values for all the ingredients
    of each `forward` call of a given batch, and only do that for batches 1 and 3\.
    Then you instantiate this class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And now full batches 1 and 3 will be traced using the same format as the underflow/overflow
    detector does.
  prefs: []
  type: TYPE_NORMAL
- en: Batches are 0-indexed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is helpful if you know that the program starts misbehaving after a certain
    batch number, so you can fast-forward right to that area. Here is a sample truncated
    output for such configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here you will get a huge number of frames dumped - as many as there were forward
    calls in your model, so it may or may not what you want, but sometimes it can
    be easier to use for debugging purposes than a normal debugger. For example, if
    a problem starts happening at batch number 150\. So you can dump traces for batches
    149 and 150 and compare where numbers started to diverge.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify the batch number after which to stop the training, with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
