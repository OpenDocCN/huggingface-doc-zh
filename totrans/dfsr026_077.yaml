- en: Speed up inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://huggingface.co/docs/diffusers/optimization/fp16](https://huggingface.co/docs/diffusers/optimization/fp16)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link href="/docs/diffusers/v0.26.3/en/_app/immutable/assets/0.e3b0c442.css"
    rel="modulepreload"> <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/entry/start.99629b4a.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/scheduler.182ea377.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/singletons.fade7992.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/index.1f6d62f6.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/paths.108a236d.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/entry/app.2b3eaeb0.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/index.abf12888.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/nodes/0.3862a335.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/each.e59479a4.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/nodes/122.aa5c911a.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/Tip.230e2334.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/CodeBlock.57fe6e13.js">
    <link rel="modulepreload" href="/docs/diffusers/v0.26.3/en/_app/immutable/chunks/Heading.16916d63.js">
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to optimize ðŸ¤— Diffusers for inference speed. As a general
    rule of thumb, we recommend using either [xFormers](xformers) or `torch.nn.functional.scaled_dot_product_attention`
    in PyTorch 2.0 for their memory-efficient attention.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, optimizing for speed or memory leads to improved performance
    in the other, so you should try to optimize for both whenever you can. This guide
    focuses on inference speed, but you can learn more about preserving memory in
    the [Reduce memory usage](memory) guide.
  prefs: []
  type: TYPE_NORMAL
- en: The results below are obtained from generating a single 512x512 image from the
    prompt `a photo of an astronaut riding a horse on mars` with 50 DDIM steps on
    a Nvidia Titan RTX, demonstrating the speed-up you can expect.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | latency | speed-up |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| original | 9.50s | x1 |'
  prefs: []
  type: TYPE_TB
- en: '| fp16 | 3.61s | x2.63 |'
  prefs: []
  type: TYPE_TB
- en: '| channels last | 3.30s | x2.88 |'
  prefs: []
  type: TYPE_TB
- en: '| traced UNet | 3.21s | x2.96 |'
  prefs: []
  type: TYPE_TB
- en: '| memory efficient attention | 2.63s | x3.61 |'
  prefs: []
  type: TYPE_TB
- en: Use TensorFloat-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Ampere and later CUDA devices, matrix multiplications and convolutions can
    use the [TensorFloat-32 (TF32)](https://blogs.nvidia.com/blog/2020/05/14/tensorfloat-32-precision-format/)
    mode for faster, but slightly less accurate computations. By default, PyTorch
    enables TF32 mode for convolutions but not matrix multiplications. Unless your
    network requires full float32 precision, we recommend enabling TF32 for matrix
    multiplications. It can significantly speeds up computations with typically negligible
    loss in numerical accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about TF32 in the [Mixed precision training](https://huggingface.co/docs/transformers/en/perf_train_gpu_one#tf32)
    guide.
  prefs: []
  type: TYPE_NORMAL
- en: Half-precision weights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To save GPU memory and get more speed, try loading and running the model weights
    directly in half-precision or float16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Donâ€™t use [`torch.autocast`](https://pytorch.org/docs/stable/amp.html#torch.autocast)
    in any of the pipelines as it can lead to black images and is always slower than
    pure float16 precision.
  prefs: []
  type: TYPE_NORMAL
