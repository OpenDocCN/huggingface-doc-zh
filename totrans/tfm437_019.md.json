["```py\npip install transformers datasets evaluate seqeval\n```", "```py\n>>> from huggingface_hub import notebook_login\n\n>>> notebook_login()\n```", "```py\n>>> from datasets import load_dataset\n\n>>> wnut = load_dataset(\"wnut_17\")\n```", "```py\n>>> wnut[\"train\"][0]\n{'id': '0',\n 'ner_tags': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],\n 'tokens': ['@paulwalk', 'It', \"'s\", 'the', 'view', 'from', 'where', 'I', \"'m\", 'living', 'for', 'two', 'weeks', '.', 'Empire', 'State', 'Building', '=', 'ESB', '.', 'Pretty', 'bad', 'storm', 'here', 'last', 'evening', '.']\n}\n```", "```py\n>>> label_list = wnut[\"train\"].features[f\"ner_tags\"].feature.names\n>>> label_list\n[\n    \"O\",\n    \"B-corporation\",\n    \"I-corporation\",\n    \"B-creative-work\",\n    \"I-creative-work\",\n    \"B-group\",\n    \"I-group\",\n    \"B-location\",\n    \"I-location\",\n    \"B-person\",\n    \"I-person\",\n    \"B-product\",\n    \"I-product\",\n]\n```", "```py\n>>> from transformers import AutoTokenizer\n\n>>> tokenizer = AutoTokenizer.from_pretrained(\"distilbert-base-uncased\")\n```", "```py\n>>> example = wnut[\"train\"][0]\n>>> tokenized_input = tokenizer(example[\"tokens\"], is_split_into_words=True)\n>>> tokens = tokenizer.convert_ids_to_tokens(tokenized_input[\"input_ids\"])\n>>> tokens\n['[CLS]', '@', 'paul', '##walk', 'it', \"'\", 's', 'the', 'view', 'from', 'where', 'i', \"'\", 'm', 'living', 'for', 'two', 'weeks', '.', 'empire', 'state', 'building', '=', 'es', '##b', '.', 'pretty', 'bad', 'storm', 'here', 'last', 'evening', '.', '[SEP]']\n```", "```py\n>>> def tokenize_and_align_labels(examples):\n...     tokenized_inputs = tokenizer(examples[\"tokens\"], truncation=True, is_split_into_words=True)\n\n...     labels = []\n...     for i, label in enumerate(examples[f\"ner_tags\"]):\n...         word_ids = tokenized_inputs.word_ids(batch_index=i)  # Map tokens to their respective word.\n...         previous_word_idx = None\n...         label_ids = []\n...         for word_idx in word_ids:  # Set the special tokens to -100.\n...             if word_idx is None:\n...                 label_ids.append(-100)\n...             elif word_idx != previous_word_idx:  # Only label the first token of a given word.\n...                 label_ids.append(label[word_idx])\n...             else:\n...                 label_ids.append(-100)\n...             previous_word_idx = word_idx\n...         labels.append(label_ids)\n\n...     tokenized_inputs[\"labels\"] = labels\n...     return tokenized_inputs\n```", "```py\n>>> tokenized_wnut = wnut.map(tokenize_and_align_labels, batched=True)\n```", "```py\n>>> from transformers import DataCollatorForTokenClassification\n\n>>> data_collator = DataCollatorForTokenClassification(tokenizer=tokenizer)\n```", "```py\n>>> from transformers import DataCollatorForTokenClassification\n\n>>> data_collator = DataCollatorForTokenClassification(tokenizer=tokenizer, return_tensors=\"tf\")\n```", "```py\n>>> import evaluate\n\n>>> seqeval = evaluate.load(\"seqeval\")\n```", "```py\n>>> import numpy as np\n\n>>> labels = [label_list[i] for i in example[f\"ner_tags\"]]\n\n>>> def compute_metrics(p):\n...     predictions, labels = p\n...     predictions = np.argmax(predictions, axis=2)\n\n...     true_predictions = [\n...         [label_list[p] for (p, l) in zip(prediction, label) if l != -100]\n...         for prediction, label in zip(predictions, labels)\n...     ]\n...     true_labels = [\n...         [label_list[l] for (p, l) in zip(prediction, label) if l != -100]\n...         for prediction, label in zip(predictions, labels)\n...     ]\n\n...     results = seqeval.compute(predictions=true_predictions, references=true_labels)\n...     return {\n...         \"precision\": results[\"overall_precision\"],\n...         \"recall\": results[\"overall_recall\"],\n...         \"f1\": results[\"overall_f1\"],\n...         \"accuracy\": results[\"overall_accuracy\"],\n...     }\n```", "```py\n>>> id2label = {\n...     0: \"O\",\n...     1: \"B-corporation\",\n...     2: \"I-corporation\",\n...     3: \"B-creative-work\",\n...     4: \"I-creative-work\",\n...     5: \"B-group\",\n...     6: \"I-group\",\n...     7: \"B-location\",\n...     8: \"I-location\",\n...     9: \"B-person\",\n...     10: \"I-person\",\n...     11: \"B-product\",\n...     12: \"I-product\",\n... }\n>>> label2id = {\n...     \"O\": 0,\n...     \"B-corporation\": 1,\n...     \"I-corporation\": 2,\n...     \"B-creative-work\": 3,\n...     \"I-creative-work\": 4,\n...     \"B-group\": 5,\n...     \"I-group\": 6,\n...     \"B-location\": 7,\n...     \"I-location\": 8,\n...     \"B-person\": 9,\n...     \"I-person\": 10,\n...     \"B-product\": 11,\n...     \"I-product\": 12,\n... }\n```", "```py\n>>> from transformers import AutoModelForTokenClassification, TrainingArguments, Trainer\n\n>>> model = AutoModelForTokenClassification.from_pretrained(\n...     \"distilbert-base-uncased\", num_labels=13, id2label=id2label, label2id=label2id\n... )\n```", "```py\n>>> training_args = TrainingArguments(\n...     output_dir=\"my_awesome_wnut_model\",\n...     learning_rate=2e-5,\n...     per_device_train_batch_size=16,\n...     per_device_eval_batch_size=16,\n...     num_train_epochs=2,\n...     weight_decay=0.01,\n...     evaluation_strategy=\"epoch\",\n...     save_strategy=\"epoch\",\n...     load_best_model_at_end=True,\n...     push_to_hub=True,\n... )\n\n>>> trainer = Trainer(\n...     model=model,\n...     args=training_args,\n...     train_dataset=tokenized_wnut[\"train\"],\n...     eval_dataset=tokenized_wnut[\"test\"],\n...     tokenizer=tokenizer,\n...     data_collator=data_collator,\n...     compute_metrics=compute_metrics,\n... )\n\n>>> trainer.train()\n```", "```py\n>>> trainer.push_to_hub()\n```", "```py\n>>> from transformers import create_optimizer\n\n>>> batch_size = 16\n>>> num_train_epochs = 3\n>>> num_train_steps = (len(tokenized_wnut[\"train\"]) // batch_size) * num_train_epochs\n>>> optimizer, lr_schedule = create_optimizer(\n...     init_lr=2e-5,\n...     num_train_steps=num_train_steps,\n...     weight_decay_rate=0.01,\n...     num_warmup_steps=0,\n... )\n```", "```py\n>>> from transformers import TFAutoModelForTokenClassification\n\n>>> model = TFAutoModelForTokenClassification.from_pretrained(\n...     \"distilbert-base-uncased\", num_labels=13, id2label=id2label, label2id=label2id\n... )\n```", "```py\n>>> tf_train_set = model.prepare_tf_dataset(\n...     tokenized_wnut[\"train\"],\n...     shuffle=True,\n...     batch_size=16,\n...     collate_fn=data_collator,\n... )\n\n>>> tf_validation_set = model.prepare_tf_dataset(\n...     tokenized_wnut[\"validation\"],\n...     shuffle=False,\n...     batch_size=16,\n...     collate_fn=data_collator,\n... )\n```", "```py\n>>> import tensorflow as tf\n\n>>> model.compile(optimizer=optimizer)  # No loss argument!\n```", "```py\n>>> from transformers.keras_callbacks import KerasMetricCallback\n\n>>> metric_callback = KerasMetricCallback(metric_fn=compute_metrics, eval_dataset=tf_validation_set)\n```", "```py\n>>> from transformers.keras_callbacks import PushToHubCallback\n\n>>> push_to_hub_callback = PushToHubCallback(\n...     output_dir=\"my_awesome_wnut_model\",\n...     tokenizer=tokenizer,\n... )\n```", "```py\n>>> callbacks = [metric_callback, push_to_hub_callback]\n```", "```py\n>>> model.fit(x=tf_train_set, validation_data=tf_validation_set, epochs=3, callbacks=callbacks)\n```", "```py\n>>> text = \"The Golden State Warriors are an American professional basketball team based in San Francisco.\"\n```", "```py\n>>> from transformers import pipeline\n\n>>> classifier = pipeline(\"ner\", model=\"stevhliu/my_awesome_wnut_model\")\n>>> classifier(text)\n[{'entity': 'B-location',\n  'score': 0.42658573,\n  'index': 2,\n  'word': 'golden',\n  'start': 4,\n  'end': 10},\n {'entity': 'I-location',\n  'score': 0.35856336,\n  'index': 3,\n  'word': 'state',\n  'start': 11,\n  'end': 16},\n {'entity': 'B-group',\n  'score': 0.3064001,\n  'index': 4,\n  'word': 'warriors',\n  'start': 17,\n  'end': 25},\n {'entity': 'B-location',\n  'score': 0.65523505,\n  'index': 13,\n  'word': 'san',\n  'start': 80,\n  'end': 83},\n {'entity': 'B-location',\n  'score': 0.4668663,\n  'index': 14,\n  'word': 'francisco',\n  'start': 84,\n  'end': 93}]\n```", "```py\n>>> from transformers import AutoTokenizer\n\n>>> tokenizer = AutoTokenizer.from_pretrained(\"stevhliu/my_awesome_wnut_model\")\n>>> inputs = tokenizer(text, return_tensors=\"pt\")\n```", "```py\n>>> from transformers import AutoModelForTokenClassification\n\n>>> model = AutoModelForTokenClassification.from_pretrained(\"stevhliu/my_awesome_wnut_model\")\n>>> with torch.no_grad():\n...     logits = model(**inputs).logits\n```", "```py\n>>> predictions = torch.argmax(logits, dim=2)\n>>> predicted_token_class = [model.config.id2label[t.item()] for t in predictions[0]]\n>>> predicted_token_class\n['O',\n 'O',\n 'B-location',\n 'I-location',\n 'B-group',\n 'O',\n 'O',\n 'O',\n 'O',\n 'O',\n 'O',\n 'O',\n 'O',\n 'B-location',\n 'B-location',\n 'O',\n 'O']\n```", "```py\n>>> from transformers import AutoTokenizer\n\n>>> tokenizer = AutoTokenizer.from_pretrained(\"stevhliu/my_awesome_wnut_model\")\n>>> inputs = tokenizer(text, return_tensors=\"tf\")\n```", "```py\n>>> from transformers import TFAutoModelForTokenClassification\n\n>>> model = TFAutoModelForTokenClassification.from_pretrained(\"stevhliu/my_awesome_wnut_model\")\n>>> logits = model(**inputs).logits\n```", "```py\n>>> predicted_token_class_ids = tf.math.argmax(logits, axis=-1)\n>>> predicted_token_class = [model.config.id2label[t] for t in predicted_token_class_ids[0].numpy().tolist()]\n>>> predicted_token_class\n['O',\n 'O',\n 'B-location',\n 'I-location',\n 'B-group',\n 'O',\n 'O',\n 'O',\n 'O',\n 'O',\n 'O',\n 'O',\n 'O',\n 'B-location',\n 'B-location',\n 'O',\n 'O']\n```"]