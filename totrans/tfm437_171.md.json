["```py\n( langs = ['en', 'de'] src_vocab_size = 42024 tgt_vocab_size = 42024 activation_function = 'relu' d_model = 1024 max_length = 200 max_position_embeddings = 1024 encoder_ffn_dim = 4096 encoder_layers = 12 encoder_attention_heads = 16 encoder_layerdrop = 0.0 decoder_ffn_dim = 4096 decoder_layers = 12 decoder_attention_heads = 16 decoder_layerdrop = 0.0 attention_dropout = 0.0 dropout = 0.1 activation_dropout = 0.0 init_std = 0.02 decoder_start_token_id = 2 is_encoder_decoder = True scale_embedding = True tie_word_embeddings = False num_beams = 5 length_penalty = 1.0 early_stopping = False use_cache = True pad_token_id = 1 bos_token_id = 0 eos_token_id = 2 forced_eos_token_id = 2 **common_kwargs )\n```", "```py\n>>> from transformers import FSMTConfig, FSMTModel\n\n>>> # Initializing a FSMT facebook/wmt19-en-ru style configuration\n>>> config = FSMTConfig()\n\n>>> # Initializing a model (with random weights) from the configuration\n>>> model = FSMTModel(config)\n\n>>> # Accessing the model configuration\n>>> configuration = model.config\n```", "```py\n( langs = None src_vocab_file = None tgt_vocab_file = None merges_file = None do_lower_case = False unk_token = '<unk>' bos_token = '<s>' sep_token = '</s>' pad_token = '<pad>' **kwargs )\n```", "```py\n( token_ids_0: List token_ids_1: Optional = None ) \u2192 export const metadata = 'undefined';List[int]\n```", "```py\n( token_ids_0: List token_ids_1: Optional = None already_has_special_tokens: bool = False ) \u2192 export const metadata = 'undefined';List[int]\n```", "```py\n( token_ids_0: List token_ids_1: Optional = None ) \u2192 export const metadata = 'undefined';List[int]\n```", "```py\n0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1\n| first sequence    | second sequence |\n```", "```py\n( save_directory: str filename_prefix: Optional = None )\n```", "```py\n( config: FSMTConfig )\n```", "```py\n( input_ids: LongTensor attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None past_key_values: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None inputs_embeds: Optional = None decoder_inputs_embeds: Optional = None return_dict: Optional = None ) \u2192 export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqModelOutput or tuple(torch.FloatTensor)\n```", "```py\n>>> from transformers import AutoTokenizer, FSMTModel\n>>> import torch\n\n>>> tokenizer = AutoTokenizer.from_pretrained(\"facebook/wmt19-ru-en\")\n>>> model = FSMTModel.from_pretrained(\"facebook/wmt19-ru-en\")\n\n>>> inputs = tokenizer(\"Hello, my dog is cute\", return_tensors=\"pt\")\n>>> outputs = model(**inputs)\n\n>>> last_hidden_states = outputs.last_hidden_state\n```", "```py\n( config: FSMTConfig )\n```", "```py\n( input_ids: LongTensor attention_mask: Optional = None decoder_input_ids: Optional = None decoder_attention_mask: Optional = None head_mask: Optional = None decoder_head_mask: Optional = None cross_attn_head_mask: Optional = None encoder_outputs: Optional = None past_key_values: Optional = None inputs_embeds: Optional = None decoder_inputs_embeds: Optional = None labels: Optional = None use_cache: Optional = None output_attentions: Optional = None output_hidden_states: Optional = None return_dict: Optional = None ) \u2192 export const metadata = 'undefined';transformers.modeling_outputs.Seq2SeqLMOutput or tuple(torch.FloatTensor)\n```", "```py\n>>> from transformers import AutoTokenizer, FSMTForConditionalGeneration\n\n>>> mname = \"facebook/wmt19-ru-en\"\n>>> model = FSMTForConditionalGeneration.from_pretrained(mname)\n>>> tokenizer = AutoTokenizer.from_pretrained(mname)\n\n>>> src_text = \"\u041c\u0430\u0448\u0438\u043d\u043d\u043e\u0435 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u0435 - \u044d\u0442\u043e \u0437\u0434\u043e\u0440\u043e\u0432\u043e, \u043d\u0435 \u0442\u0430\u043a \u043b\u0438?\"\n>>> input_ids = tokenizer(src_text, return_tensors=\"pt\").input_ids\n>>> outputs = model.generate(input_ids, num_beams=5, num_return_sequences=3)\n>>> tokenizer.decode(outputs[0], skip_special_tokens=True)\n\"Machine learning is great, isn't it?\"\n```"]