- en: Introducing Q-Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Original text: [https://huggingface.co/learn/deep-rl-course/unit2/q-learning](https://huggingface.co/learn/deep-rl-course/unit2/q-learning)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en:  
    
    
    
    
    
    
    
    
    
    
  prefs: []
  type: TYPE_NORMAL
- en: What is Q-Learning?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q-Learning is an **off-policy value-based method that uses a TD approach to
    train its action-value function:**
  prefs: []
  type: TYPE_NORMAL
- en: '*Off-policy*: we’ll talk about that at the end of this unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Value-based method*: finds the optimal policy indirectly by training a value
    or action-value function that will tell us **the value of each state or each state-action
    pair.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TD approach:* **updates its action-value function at each step instead of
    at the end of the episode.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q-Learning is the algorithm we use to train our Q-function**, an **action-value
    function** that determines the value of being at a particular state and taking
    a specific action at that state.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Q-function](../Images/d98598351e812f60049067f862f79c69.png)'
  prefs: []
  type: TYPE_IMG
- en: Given a state and action, our Q Function outputs a state-action value (also
    called Q-value)
  prefs: []
  type: TYPE_NORMAL
- en: The **Q comes from “the Quality” (the value) of that action at that state.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s recap the difference between value and reward:'
  prefs: []
  type: TYPE_NORMAL
- en: The *value of a state*, or a *state-action pair* is the expected cumulative
    reward our agent gets if it starts at this state (or state-action pair) and then
    acts accordingly to its policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *reward* is the **feedback I get from the environment** after performing
    an action at a state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, our Q-function is encoded by **a Q-table, a table where each cell
    corresponds to a state-action pair value.** Think of this Q-table as **the memory
    or cheat sheet of our Q-function.**
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through an example of a maze.
  prefs: []
  type: TYPE_NORMAL
- en: '![Maze example](../Images/444a72a9a003265b612877410c530a95.png)'
  prefs: []
  type: TYPE_IMG
- en: The Q-table is initialized. That’s why all values are = 0\. This table **contains,
    for each state and action, the corresponding state-action values.** For this simple
    example, the state is only defined by the position of the mouse. Therefore, we
    have 2*3 rows in our Q-table, one row for each possible position of the mouse.
    In more complex scenarios, the state could contain more information than the position
    of the actor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Maze example](../Images/cd71daf8ad310d839422ce684bcb5c10.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we see that the **state-action value of the initial state and going up
    is 0:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Maze example](../Images/6b2018a29d1825bf6cbb14397a596eae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So: the Q-function uses a Q-table **that has the value of each state-action
    pair.** Given a state and action, **our Q-function will search inside its Q-table
    to output the value.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Q-function](../Images/c6f51357ba01781edc9f3041b33e5be4.png)'
  prefs: []
  type: TYPE_IMG
- en: If we recap, *Q-Learning* **is the RL algorithm that:**
  prefs: []
  type: TYPE_NORMAL
- en: Trains a *Q-function* (an **action-value function**), which internally is a **Q-table
    that contains all the state-action pair values.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a state and action, our Q-function **will search its Q-table for the corresponding
    value.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the training is done, **we have an optimal Q-function, which means we have
    optimal Q-table.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And if we **have an optimal Q-function**, we **have an optimal policy** since
    we **know the best action to take at each state.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Link value policy](../Images/06e7785cc764e6109bfc6c89005a4d92.png)'
  prefs: []
  type: TYPE_IMG
- en: In the beginning, **our Q-table is useless since it gives arbitrary values for
    each state-action pair** (most of the time, we initialize the Q-table to 0). As
    the agent **explores the environment and we update the Q-table, it will give us
    a better and better approximation** to the optimal policy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Q-learning](../Images/5eeae1d543b1ae0da4b6f9afe9fe07c9.png)'
  prefs: []
  type: TYPE_IMG
- en: We see here that with the training, our Q-table is better since, thanks to it,
    we can know the value of each state-action pair.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what Q-Learning, Q-functions, and Q-tables are, **let’s
    dive deeper into the Q-Learning algorithm**.
  prefs: []
  type: TYPE_NORMAL
- en: The Q-Learning algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the Q-Learning pseudocode; let’s study each part and **see how it works
    with a simple example before implementing it.** Don’t be intimidated by it, it’s
    simpler than it looks! We’ll go over each step.
  prefs: []
  type: TYPE_NORMAL
- en: '![Q-learning](../Images/e98aadd735672374a66857c170d3b2ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 1: We initialize the Q-table'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Q-learning](../Images/01250a85fb5041af0c4b2aaf8c987543.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to initialize the Q-table for each state-action pair. **Most of the
    time, we initialize with values of 0.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Choose an action using the epsilon-greedy strategy'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Q-learning](../Images/30b0aba4490af7f85f0594dc198e9c03.png)'
  prefs: []
  type: TYPE_IMG
- en: The epsilon-greedy strategy is a policy that handles the exploration/exploitation
    trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that, with an initial value of ɛ = 1.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '*With probability 1 — ɛ* : we do **exploitation** (aka our agent selects the
    action with the highest state-action pair value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With probability ɛ: **we do exploration** (trying random action).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the beginning of the training, **the probability of doing exploration will
    be huge since ɛ is very high, so most of the time, we’ll explore.** But as the
    training goes on, and consequently our **Q-table gets better and better in its
    estimations, we progressively reduce the epsilon value** since we will need less
    and less exploration and more exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Q-learning](../Images/4d0d8f523643ebe543960e9ea3a2a4b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 3: Perform action At, get reward Rt+1 and next state St+1'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Q-learning](../Images/f834496430b9ed9ec65c64061d432454.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 4: Update Q(St, At)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that in TD Learning, we update our policy or value function (depending
    on the RL method we choose) **after one step of the interaction.**
  prefs: []
  type: TYPE_NORMAL
- en: To produce our TD target, **we used the immediate reward<math><semantics><mrow><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation
    encoding="application/x-tex">R_{t+1}</annotation></semantics></math>Rt+1​ plus
    the discounted value of the next state**, computed by finding the action that
    maximizes the current Q-function at the next state. (We call that bootstrap).
  prefs: []
  type: TYPE_NORMAL
- en: '![Q-learning](../Images/bdb95512c529cc741a6379b8a07de2b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, our<math><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mi>t</mi></msub><mo
    separator="true">,</mo><msub><mi>A</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">Q(S_t, A_t)</annotation></semantics></math>Q(St​,At​) **update
    formula goes like this:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Q-learning](../Images/0bfe74186cd45c67a2935f61d93e0937.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that to update our<math><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mi>t</mi></msub><mo
    separator="true">,</mo><msub><mi>A</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">Q(S_t, A_t)</annotation></semantics></math>Q(St​,At​):'
  prefs: []
  type: TYPE_NORMAL
- en: We need<math><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>A</mi><mi>t</mi></msub><mo
    separator="true">,</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo
    separator="true">,</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation
    encoding="application/x-tex">S_t, A_t, R_{t+1}, S_{t+1}</annotation></semantics></math>St​,At​,Rt+1​,St+1​.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To update our Q-value at a given state-action pair, we use the TD target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we form the TD target?
  prefs: []
  type: TYPE_NORMAL
- en: We obtain the reward<math><semantics><mrow><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation
    encoding="application/x-tex">R_{t+1}</annotation></semantics></math>Rt+1​ after
    taking the action<math><semantics><mrow><msub><mi>A</mi><mi>t</mi></msub></mrow><annotation
    encoding="application/x-tex">A_t</annotation></semantics></math>At​.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get the **best state-action pair value** for the next state, we use a greedy
    policy to select the next best action. Note that this is not an epsilon-greedy
    policy, this will always take the action with the highest state-action value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then when the update of this Q-value is done, we start in a new state and select
    our action **using a epsilon-greedy policy again.**
  prefs: []
  type: TYPE_NORMAL
- en: '**This is why we say that Q Learning is an off-policy algorithm.**'
  prefs: []
  type: TYPE_NORMAL
- en: Off-policy vs On-policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The difference is subtle:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Off-policy*: using **a different policy for acting (inference) and updating
    (training).**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, with Q-Learning, the epsilon-greedy policy (acting policy), is
    different from the greedy policy that is **used to select the best next-state
    action value to update our Q-value (updating policy).**
  prefs: []
  type: TYPE_NORMAL
- en: '![Off-on policy](../Images/962ba1bb9bae9ace4837824a79c98010.png)'
  prefs: []
  type: TYPE_IMG
- en: Acting Policy
  prefs: []
  type: TYPE_NORMAL
- en: 'Is different from the policy we use during the training part:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Off-on policy](../Images/e14d304b020044952e6f8de20e71e925.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating policy
  prefs: []
  type: TYPE_NORMAL
- en: '*On-policy:* using the **same policy for acting and updating.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, with Sarsa, another value-based algorithm, **the epsilon-greedy
    policy selects the next state-action pair, not a greedy policy.**
  prefs: []
  type: TYPE_NORMAL
- en: '![Off-on policy](../Images/b57fef603ca195b7a4707f530c6082f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Sarsa
  prefs: []
  type: TYPE_NORMAL
- en: '![Off-on policy](../Images/ce691ce98ae89b58669eb975be3f446c.png)'
  prefs: []
  type: TYPE_IMG
