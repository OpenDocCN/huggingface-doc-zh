# æ ‡è®°åˆ†ç±»

> åŽŸæ–‡é“¾æŽ¥ï¼š[`huggingface.co/docs/transformers/v4.37.2/en/tasks/token_classification`](https://huggingface.co/docs/transformers/v4.37.2/en/tasks/token_classification)

[`www.youtube-nocookie.com/embed/wVHdVlPScxA`](https://www.youtube-nocookie.com/embed/wVHdVlPScxA)

æ ‡è®°åˆ†ç±»ä¸ºå¥å­ä¸­çš„æ¯ä¸ªå•è¯åˆ†é…ä¸€ä¸ªæ ‡ç­¾ã€‚æœ€å¸¸è§çš„æ ‡è®°åˆ†ç±»ä»»åŠ¡ä¹‹ä¸€æ˜¯å‘½åå®žä½“è¯†åˆ«ï¼ˆNERï¼‰ã€‚NER è¯•å›¾ä¸ºå¥å­ä¸­çš„æ¯ä¸ªå®žä½“æ‰¾åˆ°ä¸€ä¸ªæ ‡ç­¾ï¼Œæ¯”å¦‚äººåã€åœ°ç‚¹æˆ–ç»„ç»‡ã€‚

æœ¬æŒ‡å—å°†å‘æ‚¨å±•ç¤ºå¦‚ä½•ï¼š

1.  åœ¨ WNUT 17 æ•°æ®é›†ä¸Šå¯¹[DistilBERT](https://huggingface.co/distilbert-base-uncased)è¿›è¡Œå¾®è°ƒï¼Œä»¥æ£€æµ‹æ–°å®žä½“ã€‚

1.  ä½¿ç”¨æ‚¨å¾®è°ƒçš„æ¨¡åž‹è¿›è¡ŒæŽ¨æ–­ã€‚

æœ¬æ•™ç¨‹ä¸­æ¼”ç¤ºçš„ä»»åŠ¡ç”±ä»¥ä¸‹æ¨¡åž‹æž¶æž„æ”¯æŒï¼š

ALBERT, BERT, BigBird, BioGpt, BLOOM, BROS, CamemBERT, CANINE, ConvBERT, Data2VecText, DeBERTa, DeBERTa-v2, DistilBERT, ELECTRA, ERNIE, ErnieM, ESM, Falcon, FlauBERT, FNet, Funnel Transformer, GPT-Sw3, OpenAI GPT-2, GPTBigCode, GPT Neo, GPT NeoX, I-BERT, LayoutLM, LayoutLMv2, LayoutLMv3, LiLT, Longformer, LUKE, MarkupLM, MEGA, Megatron-BERT, MobileBERT, MPNet, MPT, MRA, Nezha, NystrÃ¶mformer, Phi, QDQBert, RemBERT, RoBERTa, RoBERTa-PreLayerNorm, RoCBert, RoFormer, SqueezeBERT, XLM, XLM-RoBERTa, XLM-RoBERTa-XL, XLNet, X-MOD, YOSO

åœ¨å¼€å§‹ä¹‹å‰ï¼Œè¯·ç¡®ä¿å·²å®‰è£…æ‰€æœ‰å¿…è¦çš„åº“ï¼š

```py
pip install transformers datasets evaluate seqeval
```

æˆ‘ä»¬é¼“åŠ±æ‚¨ç™»å½•æ‚¨çš„ Hugging Face è´¦æˆ·ï¼Œè¿™æ ·æ‚¨å°±å¯ä»¥ä¸Šä¼ å’Œåˆ†äº«æ‚¨çš„æ¨¡åž‹ç»™ç¤¾åŒºã€‚åœ¨æç¤ºæ—¶ï¼Œè¾“å…¥æ‚¨çš„ä»¤ç‰Œä»¥ç™»å½•ï¼š

```py
>>> from huggingface_hub import notebook_login

>>> notebook_login()
```

## åŠ è½½ WNUT 17 æ•°æ®é›†

é¦–å…ˆä»ŽðŸ¤—æ•°æ®é›†åº“ä¸­åŠ è½½ WNUT 17 æ•°æ®é›†ï¼š

```py
>>> from datasets import load_dataset

>>> wnut = load_dataset("wnut_17")
```

ç„¶åŽçœ‹ä¸€ä¸ªä¾‹å­ï¼š

```py
>>> wnut["train"][0]
{'id': '0',
 'ner_tags': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],
 'tokens': ['@paulwalk', 'It', "'s", 'the', 'view', 'from', 'where', 'I', "'m", 'living', 'for', 'two', 'weeks', '.', 'Empire', 'State', 'Building', '=', 'ESB', '.', 'Pretty', 'bad', 'storm', 'here', 'last', 'evening', '.']
}
```

`ner_tags`ä¸­çš„æ¯ä¸ªæ•°å­—ä»£è¡¨ä¸€ä¸ªå®žä½“ã€‚å°†æ•°å­—è½¬æ¢ä¸ºå®ƒä»¬çš„æ ‡ç­¾åç§°ï¼Œä»¥æ‰¾å‡ºè¿™äº›å®žä½“æ˜¯ä»€ä¹ˆï¼š

```py
>>> label_list = wnut["train"].features[f"ner_tags"].feature.names
>>> label_list
[
    "O",
    "B-corporation",
    "I-corporation",
    "B-creative-work",
    "I-creative-work",
    "B-group",
    "I-group",
    "B-location",
    "I-location",
    "B-person",
    "I-person",
    "B-product",
    "I-product",
]
```

æ¯ä¸ª`ner_tag`å‰ç¼€çš„å­—æ¯è¡¨ç¤ºå®žä½“çš„æ ‡è®°ä½ç½®ï¼š

+   `B-`è¡¨ç¤ºä¸€ä¸ªå®žä½“çš„å¼€å§‹ã€‚

+   `I-`è¡¨ç¤ºä¸€ä¸ªå•è¯åŒ…å«åœ¨åŒä¸€ä¸ªå®žä½“ä¸­ï¼ˆä¾‹å¦‚ï¼Œ`State`å•è¯æ˜¯`Empire State Building`è¿™æ ·ä¸€ä¸ªå®žä½“çš„ä¸€éƒ¨åˆ†ï¼‰ã€‚

+   `0`è¡¨ç¤ºè¯¥æ ‡è®°ä¸å¯¹åº”ä»»ä½•å®žä½“ã€‚

## é¢„å¤„ç†

[`www.youtube-nocookie.com/embed/iY2AZYdZAr0`](https://www.youtube-nocookie.com/embed/iY2AZYdZAr0)

ä¸‹ä¸€æ­¥æ˜¯åŠ è½½ä¸€ä¸ª DistilBERT åˆ†è¯å™¨æ¥é¢„å¤„ç†`tokens`å­—æ®µï¼š

```py
>>> from transformers import AutoTokenizer

>>> tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")
```

æ­£å¦‚æ‚¨åœ¨ä¸Šé¢çš„ç¤ºä¾‹ `tokens` å­—æ®µä¸­çœ‹åˆ°çš„ï¼Œçœ‹èµ·æ¥è¾“å…¥å·²ç»è¢«æ ‡è®°åŒ–äº†ã€‚ä½†å®žé™…ä¸Šè¾“å…¥è¿˜æ²¡æœ‰è¢«æ ‡è®°åŒ–ï¼Œæ‚¨éœ€è¦è®¾ç½® `is_split_into_words=True` å°†å•è¯æ ‡è®°åŒ–ä¸ºå­è¯ã€‚ä¾‹å¦‚ï¼š

```py
>>> example = wnut["train"][0]
>>> tokenized_input = tokenizer(example["tokens"], is_split_into_words=True)
>>> tokens = tokenizer.convert_ids_to_tokens(tokenized_input["input_ids"])
>>> tokens
['[CLS]', '@', 'paul', '##walk', 'it', "'", 's', 'the', 'view', 'from', 'where', 'i', "'", 'm', 'living', 'for', 'two', 'weeks', '.', 'empire', 'state', 'building', '=', 'es', '##b', '.', 'pretty', 'bad', 'storm', 'here', 'last', 'evening', '.', '[SEP]']
```

ç„¶è€Œï¼Œè¿™ä¼šæ·»åŠ ä¸€äº›ç‰¹æ®Šæ ‡è®° `[CLS]` å’Œ `[SEP]`ï¼Œå­è¯æ ‡è®°åŒ–ä¼šå¯¼è‡´è¾“å…¥å’Œæ ‡ç­¾ä¹‹é—´çš„ä¸åŒ¹é…ã€‚çŽ°åœ¨ï¼Œä¸€ä¸ªå¯¹åº”äºŽå•ä¸ªæ ‡ç­¾çš„å•è¯å¯èƒ½ä¼šè¢«æ‹†åˆ†ä¸ºä¸¤ä¸ªå­è¯ã€‚æ‚¨éœ€è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼é‡æ–°å¯¹é½æ ‡è®°å’Œæ ‡ç­¾ï¼š

1.  ä½¿ç”¨ [`word_ids`](https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.BatchEncoding.word_ids) æ–¹æ³•å°†æ‰€æœ‰æ ‡è®°æ˜ å°„åˆ°å®ƒä»¬å¯¹åº”çš„å•è¯ã€‚

1.  å°†æ ‡ç­¾ `-100` åˆ†é…ç»™ç‰¹æ®Šæ ‡è®° `[CLS]` å’Œ `[SEP]`ï¼Œä»¥ä¾¿å®ƒä»¬è¢« PyTorch æŸå¤±å‡½æ•°å¿½ç•¥ï¼ˆå‚è§ [CrossEntropyLoss](https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html)ï¼‰ã€‚

1.  ä»…æ ‡è®°ç»™å®šå•è¯çš„ç¬¬ä¸€ä¸ªæ ‡è®°ã€‚å°†å…¶ä»–æ¥è‡ªåŒä¸€å•è¯çš„å­æ ‡è®°åˆ†é…ä¸º `-100`ã€‚

ä»¥ä¸‹æ˜¯å¦‚ä½•åˆ›å»ºä¸€ä¸ªå‡½æ•°æ¥é‡æ–°å¯¹é½æ ‡è®°å’Œæ ‡ç­¾ï¼Œå¹¶æˆªæ–­åºåˆ—ï¼Œä½¿å…¶ä¸è¶…è¿‡ DistilBERT çš„æœ€å¤§è¾“å…¥é•¿åº¦ï¼š

```py
>>> def tokenize_and_align_labels(examples):
...     tokenized_inputs = tokenizer(examples["tokens"], truncation=True, is_split_into_words=True)

...     labels = []
...     for i, label in enumerate(examples[f"ner_tags"]):
...         word_ids = tokenized_inputs.word_ids(batch_index=i)  # Map tokens to their respective word.
...         previous_word_idx = None
...         label_ids = []
...         for word_idx in word_ids:  # Set the special tokens to -100.
...             if word_idx is None:
...                 label_ids.append(-100)
...             elif word_idx != previous_word_idx:  # Only label the first token of a given word.
...                 label_ids.append(label[word_idx])
...             else:
...                 label_ids.append(-100)
...             previous_word_idx = word_idx
...         labels.append(label_ids)

...     tokenized_inputs["labels"] = labels
...     return tokenized_inputs
```

è¦åœ¨æ•´ä¸ªæ•°æ®é›†ä¸Šåº”ç”¨é¢„å¤„ç†å‡½æ•°ï¼Œè¯·ä½¿ç”¨ ðŸ¤— Datasets [map](https://huggingface.co/docs/datasets/v2.16.1/en/package_reference/main_classes#datasets.Dataset.map) å‡½æ•°ã€‚æ‚¨å¯ä»¥é€šè¿‡è®¾ç½® `batched=True` æ¥åŠ é€Ÿ `map` å‡½æ•°ï¼Œä»¥ä¸€æ¬¡å¤„ç†æ•°æ®é›†çš„å¤šä¸ªå…ƒç´ ï¼š

```py
>>> tokenized_wnut = wnut.map(tokenize_and_align_labels, batched=True)
```

çŽ°åœ¨ä½¿ç”¨ DataCollatorWithPadding åˆ›å»ºä¸€æ‰¹ç¤ºä¾‹ã€‚åœ¨æ•´ç†è¿‡ç¨‹ä¸­ï¼Œå°†å¥å­åŠ¨æ€å¡«å……åˆ°æ‰¹æ¬¡ä¸­çš„æœ€å¤§é•¿åº¦ï¼Œè€Œä¸æ˜¯å°†æ•´ä¸ªæ•°æ®é›†å¡«å……åˆ°æœ€å¤§é•¿åº¦ã€‚

PytorchHide Pytorch å†…å®¹

```py
>>> from transformers import DataCollatorForTokenClassification

>>> data_collator = DataCollatorForTokenClassification(tokenizer=tokenizer)
```

TensorFlowHide TensorFlow å†…å®¹

```py
>>> from transformers import DataCollatorForTokenClassification

>>> data_collator = DataCollatorForTokenClassification(tokenizer=tokenizer, return_tensors="tf")
```

## è¯„ä¼°

åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­åŒ…å«ä¸€ä¸ªæŒ‡æ ‡é€šå¸¸æœ‰åŠ©äºŽè¯„ä¼°æ¨¡åž‹çš„æ€§èƒ½ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ ðŸ¤— [Evaluate](https://huggingface.co/docs/evaluate/index) åº“å¿«é€ŸåŠ è½½è¯„ä¼°æ–¹æ³•ã€‚å¯¹äºŽè¿™ä¸ªä»»åŠ¡ï¼ŒåŠ è½½ [seqeval](https://huggingface.co/spaces/evaluate-metric/seqeval) æ¡†æž¶ï¼ˆæŸ¥çœ‹ ðŸ¤— Evaluate [å¿«é€Ÿå…¥é—¨](https://huggingface.co/docs/evaluate/a_quick_tour) äº†è§£å¦‚ä½•åŠ è½½å’Œè®¡ç®—æŒ‡æ ‡ï¼‰ã€‚Seqeval å®žé™…ä¸Šä¼šç”Ÿæˆå‡ ä¸ªåˆ†æ•°ï¼šç²¾ç¡®åº¦ã€å¬å›žçŽ‡ã€F1 å’Œå‡†ç¡®åº¦ã€‚

```py
>>> import evaluate

>>> seqeval = evaluate.load("seqeval")
```

é¦–å…ˆèŽ·å– NER æ ‡ç­¾ï¼Œç„¶åŽåˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œå°†æ‚¨çš„çœŸå®žé¢„æµ‹å’ŒçœŸå®žæ ‡ç­¾ä¼ é€’ç»™ `compute` æ¥è®¡ç®—åˆ†æ•°ï¼š

```py
>>> import numpy as np

>>> labels = [label_list[i] for i in example[f"ner_tags"]]

>>> def compute_metrics(p):
...     predictions, labels = p
...     predictions = np.argmax(predictions, axis=2)

...     true_predictions = [
...         [label_list[p] for (p, l) in zip(prediction, label) if l != -100]
...         for prediction, label in zip(predictions, labels)
...     ]
...     true_labels = [
...         [label_list[l] for (p, l) in zip(prediction, label) if l != -100]
...         for prediction, label in zip(predictions, labels)
...     ]

...     results = seqeval.compute(predictions=true_predictions, references=true_labels)
...     return {
...         "precision": results["overall_precision"],
...         "recall": results["overall_recall"],
...         "f1": results["overall_f1"],
...         "accuracy": results["overall_accuracy"],
...     }
```

æ‚¨çš„ `compute_metrics` å‡½æ•°çŽ°åœ¨å·²ç»å‡†å¤‡å°±ç»ªï¼Œå½“æ‚¨è®¾ç½®è®­ç»ƒæ—¶ä¼šè¿”å›žåˆ°å®ƒã€‚

## è®­ç»ƒ

åœ¨å¼€å§‹è®­ç»ƒæ¨¡åž‹ä¹‹å‰ï¼Œä½¿ç”¨ `id2label` å’Œ `label2id` åˆ›å»ºé¢„æœŸ id åˆ°æ ‡ç­¾çš„æ˜ å°„ï¼š

```py
>>> id2label = {
...     0: "O",
...     1: "B-corporation",
...     2: "I-corporation",
...     3: "B-creative-work",
...     4: "I-creative-work",
...     5: "B-group",
...     6: "I-group",
...     7: "B-location",
...     8: "I-location",
...     9: "B-person",
...     10: "I-person",
...     11: "B-product",
...     12: "I-product",
... }
>>> label2id = {
...     "O": 0,
...     "B-corporation": 1,
...     "I-corporation": 2,
...     "B-creative-work": 3,
...     "I-creative-work": 4,
...     "B-group": 5,
...     "I-group": 6,
...     "B-location": 7,
...     "I-location": 8,
...     "B-person": 9,
...     "I-person": 10,
...     "B-product": 11,
...     "I-product": 12,
... }
```

PytorchHide Pytorch å†…å®¹

å¦‚æžœæ‚¨ä¸ç†Ÿæ‚‰ä½¿ç”¨ Trainer å¯¹æ¨¡åž‹è¿›è¡Œå¾®è°ƒï¼Œè¯·æŸ¥çœ‹è¿™é‡Œçš„åŸºæœ¬æ•™ç¨‹ hereï¼

çŽ°åœ¨æ‚¨å·²ç»å‡†å¤‡å¥½å¼€å§‹è®­ç»ƒæ‚¨çš„æ¨¡åž‹äº†ï¼ä½¿ç”¨ AutoModelForTokenClassification åŠ è½½ DistilBERTï¼Œä»¥åŠé¢„æœŸæ ‡ç­¾æ•°å’Œæ ‡ç­¾æ˜ å°„ï¼š

```py
>>> from transformers import AutoModelForTokenClassification, TrainingArguments, Trainer

>>> model = AutoModelForTokenClassification.from_pretrained(
...     "distilbert-base-uncased", num_labels=13, id2label=id2label, label2id=label2id
... )
```

æ­¤æ—¶ï¼Œåªå‰©ä¸‹ä¸‰ä¸ªæ­¥éª¤ï¼š

1.  åœ¨ TrainingArguments ä¸­å®šä¹‰æ‚¨çš„è®­ç»ƒè¶…å‚æ•°ã€‚å”¯ä¸€å¿…éœ€çš„å‚æ•°æ˜¯ `output_dir`ï¼ŒæŒ‡å®šä¿å­˜æ¨¡åž‹çš„ä½ç½®ã€‚é€šè¿‡è®¾ç½® `push_to_hub=True` å°†æ­¤æ¨¡åž‹æŽ¨é€åˆ° Hubï¼ˆæ‚¨éœ€è¦ç™»å½• Hugging Face ä»¥ä¸Šä¼ æ¨¡åž‹ï¼‰ã€‚åœ¨æ¯ä¸ªæ—¶ä»£ç»“æŸæ—¶ï¼ŒTrainer å°†è¯„ä¼° seqeval åˆ†æ•°å¹¶ä¿å­˜è®­ç»ƒæ£€æŸ¥ç‚¹ã€‚

1.  å°†è®­ç»ƒå‚æ•°ä¼ é€’ç»™ Trainerï¼Œä»¥åŠæ¨¡åž‹ã€æ•°æ®é›†ã€åˆ†è¯å™¨ã€æ•°æ®æ•´ç†å™¨å’Œ`compute_metrics`å‡½æ•°ã€‚

1.  è°ƒç”¨ train()æ¥å¾®è°ƒæ‚¨çš„æ¨¡åž‹ã€‚

```py
>>> training_args = TrainingArguments(
...     output_dir="my_awesome_wnut_model",
...     learning_rate=2e-5,
...     per_device_train_batch_size=16,
...     per_device_eval_batch_size=16,
...     num_train_epochs=2,
...     weight_decay=0.01,
...     evaluation_strategy="epoch",
...     save_strategy="epoch",
...     load_best_model_at_end=True,
...     push_to_hub=True,
... )

>>> trainer = Trainer(
...     model=model,
...     args=training_args,
...     train_dataset=tokenized_wnut["train"],
...     eval_dataset=tokenized_wnut["test"],
...     tokenizer=tokenizer,
...     data_collator=data_collator,
...     compute_metrics=compute_metrics,
... )

>>> trainer.train()
```

åŸ¹è®­å®ŒæˆåŽï¼Œä½¿ç”¨ push_to_hub()æ–¹æ³•å°†æ‚¨çš„æ¨¡åž‹å…±äº«åˆ° Hubï¼Œä»¥ä¾¿æ¯ä¸ªäººéƒ½å¯ä»¥ä½¿ç”¨æ‚¨çš„æ¨¡åž‹ï¼š

```py
>>> trainer.push_to_hub()
```

éšè— TensorFlow å†…å®¹

å¦‚æžœæ‚¨ä¸ç†Ÿæ‚‰ä½¿ç”¨ Keras å¾®è°ƒæ¨¡åž‹ï¼Œè¯·æŸ¥çœ‹åŸºæœ¬æ•™ç¨‹è¿™é‡Œï¼

è¦åœ¨ TensorFlow ä¸­å¾®è°ƒæ¨¡åž‹ï¼Œè¯·é¦–å…ˆè®¾ç½®ä¼˜åŒ–å™¨å‡½æ•°ã€å­¦ä¹ çŽ‡è°ƒåº¦å’Œä¸€äº›è®­ç»ƒè¶…å‚æ•°ï¼š

```py
>>> from transformers import create_optimizer

>>> batch_size = 16
>>> num_train_epochs = 3
>>> num_train_steps = (len(tokenized_wnut["train"]) // batch_size) * num_train_epochs
>>> optimizer, lr_schedule = create_optimizer(
...     init_lr=2e-5,
...     num_train_steps=num_train_steps,
...     weight_decay_rate=0.01,
...     num_warmup_steps=0,
... )
```

ç„¶åŽï¼Œæ‚¨å¯ä»¥åŠ è½½ DistilBERT ä¸Ž TFAutoModelForTokenClassification ä»¥åŠé¢„æœŸæ ‡ç­¾çš„æ•°é‡å’Œæ ‡ç­¾æ˜ å°„ï¼š

```py
>>> from transformers import TFAutoModelForTokenClassification

>>> model = TFAutoModelForTokenClassification.from_pretrained(
...     "distilbert-base-uncased", num_labels=13, id2label=id2label, label2id=label2id
... )
```

ä½¿ç”¨ prepare_tf_dataset()å°†æ•°æ®é›†è½¬æ¢ä¸º`tf.data.Dataset`æ ¼å¼ï¼š

```py
>>> tf_train_set = model.prepare_tf_dataset(
...     tokenized_wnut["train"],
...     shuffle=True,
...     batch_size=16,
...     collate_fn=data_collator,
... )

>>> tf_validation_set = model.prepare_tf_dataset(
...     tokenized_wnut["validation"],
...     shuffle=False,
...     batch_size=16,
...     collate_fn=data_collator,
... )
```

ä½¿ç”¨[`compile`](https://keras.io/api/models/model_training_apis/#compile-method)é…ç½®æ¨¡åž‹è¿›è¡Œè®­ç»ƒã€‚è¯·æ³¨æ„ï¼ŒTransformers æ¨¡åž‹éƒ½æœ‰ä¸€ä¸ªé»˜è®¤çš„ä¸Žä»»åŠ¡ç›¸å…³çš„æŸå¤±å‡½æ•°ï¼Œå› æ­¤é™¤éžæ‚¨æƒ³è¦æŒ‡å®šä¸€ä¸ªï¼Œå¦åˆ™ä¸éœ€è¦æŒ‡å®šï¼š

```py
>>> import tensorflow as tf

>>> model.compile(optimizer=optimizer)  # No loss argument!
```

åœ¨å¼€å§‹è®­ç»ƒä¹‹å‰è®¾ç½®çš„æœ€åŽä¸¤ä»¶äº‹æ˜¯ä»Žé¢„æµ‹ä¸­è®¡ç®— seqeval åˆ†æ•°ï¼Œå¹¶æä¾›ä¸€ç§å°†æ‚¨çš„æ¨¡åž‹æŽ¨é€åˆ° Hub çš„æ–¹æ³•ã€‚è¿™ä¸¤è€…éƒ½å¯ä»¥ä½¿ç”¨ Keras callbacks æ¥å®Œæˆã€‚

å°†æ‚¨çš„`compute_metrics`å‡½æ•°ä¼ é€’ç»™ KerasMetricCallbackï¼š

```py
>>> from transformers.keras_callbacks import KerasMetricCallback

>>> metric_callback = KerasMetricCallback(metric_fn=compute_metrics, eval_dataset=tf_validation_set)
```

åœ¨ PushToHubCallback ä¸­æŒ‡å®šè¦æŽ¨é€æ¨¡åž‹å’Œåˆ†è¯å™¨çš„ä½ç½®ï¼š

```py
>>> from transformers.keras_callbacks import PushToHubCallback

>>> push_to_hub_callback = PushToHubCallback(
...     output_dir="my_awesome_wnut_model",
...     tokenizer=tokenizer,
... )
```

ç„¶åŽå°†æ‚¨çš„å›žè°ƒæ†ç»‘åœ¨ä¸€èµ·ï¼š

```py
>>> callbacks = [metric_callback, push_to_hub_callback]
```

æœ€åŽï¼Œæ‚¨å·²ç»å‡†å¤‡å¥½å¼€å§‹è®­ç»ƒæ‚¨çš„æ¨¡åž‹äº†ï¼ä½¿ç”¨æ‚¨çš„è®­ç»ƒå’ŒéªŒè¯æ•°æ®é›†ã€æ—¶ä»£æ•°å’Œå›žè°ƒè°ƒç”¨[`fit`](https://keras.io/api/models/model_training_apis/#fit-method)æ¥å¾®è°ƒæ¨¡åž‹ï¼š

```py
>>> model.fit(x=tf_train_set, validation_data=tf_validation_set, epochs=3, callbacks=callbacks)
```

ä¸€æ—¦è®­ç»ƒå®Œæˆï¼Œæ‚¨çš„æ¨¡åž‹å°†è‡ªåŠ¨ä¸Šä¼ åˆ° Hubï¼Œä»¥ä¾¿æ¯ä¸ªäººéƒ½å¯ä»¥ä½¿ç”¨å®ƒï¼

è¦äº†è§£å¦‚ä½•ä¸ºæ ‡è®°åˆ†ç±»å¾®è°ƒæ¨¡åž‹çš„æ›´æ·±å…¥ç¤ºä¾‹ï¼Œè¯·æŸ¥çœ‹ç›¸åº”çš„[PyTorch ç¬”è®°æœ¬](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/token_classification.ipynb)æˆ–[TensorFlow ç¬”è®°æœ¬](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/token_classification-tf.ipynb)ã€‚

## æŽ¨ç†

å¾ˆå¥½ï¼ŒçŽ°åœ¨æ‚¨å·²ç»å¾®è°ƒäº†ä¸€ä¸ªæ¨¡åž‹ï¼Œå¯ä»¥ç”¨å®ƒè¿›è¡ŒæŽ¨ç†äº†ï¼

èŽ·å–ä¸€äº›æ‚¨æƒ³è¦è¿è¡ŒæŽ¨ç†çš„æ–‡æœ¬ï¼š

```py
>>> text = "The Golden State Warriors are an American professional basketball team based in San Francisco."
```

å°è¯•ä½¿ç”¨æ‚¨å¾®è°ƒçš„æ¨¡åž‹è¿›è¡ŒæŽ¨ç†çš„æœ€ç®€å•æ–¹æ³•æ˜¯åœ¨ pipeline()ä¸­ä½¿ç”¨å®ƒã€‚ç”¨æ‚¨çš„æ¨¡åž‹å®žä¾‹åŒ–ä¸€ä¸ª NER çš„`pipeline`ï¼Œå¹¶å°†æ–‡æœ¬ä¼ é€’ç»™å®ƒï¼š

```py
>>> from transformers import pipeline

>>> classifier = pipeline("ner", model="stevhliu/my_awesome_wnut_model")
>>> classifier(text)
[{'entity': 'B-location',
  'score': 0.42658573,
  'index': 2,
  'word': 'golden',
  'start': 4,
  'end': 10},
 {'entity': 'I-location',
  'score': 0.35856336,
  'index': 3,
  'word': 'state',
  'start': 11,
  'end': 16},
 {'entity': 'B-group',
  'score': 0.3064001,
  'index': 4,
  'word': 'warriors',
  'start': 17,
  'end': 25},
 {'entity': 'B-location',
  'score': 0.65523505,
  'index': 13,
  'word': 'san',
  'start': 80,
  'end': 83},
 {'entity': 'B-location',
  'score': 0.4668663,
  'index': 14,
  'word': 'francisco',
  'start': 84,
  'end': 93}]
```

å¦‚æžœæ‚¨æ„¿æ„ï¼Œæ‚¨ä¹Ÿå¯ä»¥æ‰‹åŠ¨å¤åˆ¶`pipeline`çš„ç»“æžœï¼š

éšè— Pytorch å†…å®¹

å¯¹æ–‡æœ¬è¿›è¡Œæ ‡è®°åŒ–å¹¶è¿”å›ž PyTorch å¼ é‡ï¼š

```py
>>> from transformers import AutoTokenizer

>>> tokenizer = AutoTokenizer.from_pretrained("stevhliu/my_awesome_wnut_model")
>>> inputs = tokenizer(text, return_tensors="pt")
```

å°†æ‚¨çš„è¾“å…¥ä¼ é€’ç»™æ¨¡åž‹å¹¶è¿”å›ž`logits`ï¼š

```py
>>> from transformers import AutoModelForTokenClassification

>>> model = AutoModelForTokenClassification.from_pretrained("stevhliu/my_awesome_wnut_model")
>>> with torch.no_grad():
...     logits = model(**inputs).logits
```

èŽ·å–å…·æœ‰æœ€é«˜æ¦‚çŽ‡çš„ç±»ï¼Œå¹¶ä½¿ç”¨æ¨¡åž‹çš„`id2label`æ˜ å°„å°†å…¶è½¬æ¢ä¸ºæ–‡æœ¬æ ‡ç­¾ï¼š

```py
>>> predictions = torch.argmax(logits, dim=2)
>>> predicted_token_class = [model.config.id2label[t.item()] for t in predictions[0]]
>>> predicted_token_class
['O',
 'O',
 'B-location',
 'I-location',
 'B-group',
 'O',
 'O',
 'O',
 'O',
 'O',
 'O',
 'O',
 'O',
 'B-location',
 'B-location',
 'O',
 'O']
```

éšè— TensorFlow å†…å®¹

å¯¹æ–‡æœ¬è¿›è¡Œæ ‡è®°åŒ–å¹¶è¿”å›ž TensorFlow å¼ é‡ï¼š

```py
>>> from transformers import AutoTokenizer

>>> tokenizer = AutoTokenizer.from_pretrained("stevhliu/my_awesome_wnut_model")
>>> inputs = tokenizer(text, return_tensors="tf")
```

å°†æ‚¨çš„è¾“å…¥ä¼ é€’ç»™æ¨¡åž‹å¹¶è¿”å›ž`logits`ï¼š

```py
>>> from transformers import TFAutoModelForTokenClassification

>>> model = TFAutoModelForTokenClassification.from_pretrained("stevhliu/my_awesome_wnut_model")
>>> logits = model(**inputs).logits
```

èŽ·å–å…·æœ‰æœ€é«˜æ¦‚çŽ‡çš„ç±»ï¼Œå¹¶ä½¿ç”¨æ¨¡åž‹çš„`id2label`æ˜ å°„å°†å…¶è½¬æ¢ä¸ºæ–‡æœ¬æ ‡ç­¾ï¼š

```py
>>> predicted_token_class_ids = tf.math.argmax(logits, axis=-1)
>>> predicted_token_class = [model.config.id2label[t] for t in predicted_token_class_ids[0].numpy().tolist()]
>>> predicted_token_class
['O',
 'O',
 'B-location',
 'I-location',
 'B-group',
 'O',
 'O',
 'O',
 'O',
 'O',
 'O',
 'O',
 'O',
 'B-location',
 'B-location',
 'O',
 'O']
```
