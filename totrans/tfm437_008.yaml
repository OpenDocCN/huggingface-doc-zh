- en: Preprocess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Original text: [https://huggingface.co/docs/transformers/v4.37.2/en/preprocessing](https://huggingface.co/docs/transformers/v4.37.2/en/preprocessing)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en:  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can train a model on a dataset, it needs to be preprocessed into
    the expected model input format. Whether your data is text, images, or audio,
    they need to be converted and assembled into batches of tensors. ðŸ¤— Transformers
    provides a set of preprocessing classes to help prepare your data for the model.
    In this tutorial, youâ€™ll learn that for:'
  prefs: []
  type: TYPE_NORMAL
- en: Text, use a [Tokenizer](./main_classes/tokenizer) to convert text into a sequence
    of tokens, create a numerical representation of the tokens, and assemble them
    into tensors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speech and audio, use a [Feature extractor](./main_classes/feature_extractor)
    to extract sequential features from audio waveforms and convert them into tensors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image inputs use a [ImageProcessor](./main_classes/image) to convert images
    into tensors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multimodal inputs, use a [Processor](./main_classes/processors) to combine a
    tokenizer and a feature extractor or image processor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AutoProcessor` **always** works and automatically chooses the correct class
    for the model youâ€™re using, whether youâ€™re using a tokenizer, image processor,
    feature extractor or processor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you begin, install ðŸ¤— Datasets so you can load some datasets to experiment
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Natural Language Processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.youtube-nocookie.com/embed/Yffk5aydLzg](https://www.youtube-nocookie.com/embed/Yffk5aydLzg)'
  prefs: []
  type: TYPE_NORMAL
- en: The main tool for preprocessing textual data is a [tokenizer](main_classes/tokenizer).
    A tokenizer splits text into *tokens* according to a set of rules. The tokens
    are converted into numbers and then tensors, which become the model inputs. Any
    additional inputs required by the model are added by the tokenizer.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan on using a pretrained model, itâ€™s important to use the associated
    pretrained tokenizer. This ensures the text is split the same way as the pretraining
    corpus, and uses the same corresponding tokens-to-index (usually referred to as
    the *vocab*) during pretraining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get started by loading a pretrained tokenizer with the [AutoTokenizer.from_pretrained()](/docs/transformers/v4.37.2/en/model_doc/auto#transformers.AutoTokenizer.from_pretrained)
    method. This downloads the *vocab* a model was pretrained with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then pass your text to the tokenizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The tokenizer returns a dictionary with three important items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[input_ids](glossary#input-ids) are the indices corresponding to each token
    in the sentence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[attention_mask](glossary#attention-mask) indicates whether a token should
    be attended to or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[token_type_ids](glossary#token-type-ids) identifies which sequence a token
    belongs to when there is more than one sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return your input by decoding the `input_ids`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the tokenizer added two special tokens - `CLS` and `SEP` (classifier
    and separator) - to the sentence. Not all models need special tokens, but if they
    do, the tokenizer automatically adds them for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are several sentences you want to preprocess, pass them as a list
    to the tokenizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Pad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sentences arenâ€™t always the same length which can be an issue because tensors,
    the model inputs, need to have a uniform shape. Padding is a strategy for ensuring
    tensors are rectangular by adding a special *padding token* to shorter sentences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `padding` parameter to `True` to pad the shorter sequences in the batch
    to match the longest sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first and third sentences are now padded with `0`â€™s because they are shorter.
  prefs: []
  type: TYPE_NORMAL
- en: Truncation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the other end of the spectrum, sometimes a sequence may be too long for a
    model to handle. In this case, youâ€™ll need to truncate the sequence to a shorter
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `truncation` parameter to `True` to truncate a sequence to the maximum
    length accepted by the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Check out the [Padding and truncation](./pad_truncation) concept guide to learn
    more different padding and truncation arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Build tensors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, you want the tokenizer to return the actual tensors that get fed to
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `return_tensors` parameter to either `pt` for PyTorch, or `tf` for
    TensorFlow:'
  prefs: []
  type: TYPE_NORMAL
- en: PytorchHide Pytorch content
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: TensorFlowHide TensorFlow content
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Different pipelines support tokenizer arguments in their `__call__()` differently.
    `text-2-text-generation` pipelines support (i.e. pass on) only `truncation`. `text-generation`
    pipelines support `max_length`, `truncation`, `padding` and `add_special_tokens`.
    In `fill-mask` pipelines, tokenizer arguments can be passed in the `tokenizer_kwargs`
    argument (dictionary).
  prefs: []
  type: TYPE_NORMAL
- en: Audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For audio tasks, youâ€™ll need a [feature extractor](main_classes/feature_extractor)
    to prepare your dataset for the model. The feature extractor is designed to extract
    features from raw audio data, and convert them into tensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the [MInDS-14](https://huggingface.co/datasets/PolyAI/minds14) dataset
    (see the ðŸ¤— [Datasets tutorial](https://huggingface.co/docs/datasets/load_hub)
    for more details on how to load a dataset) to see how you can use a feature extractor
    with audio datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Access the first element of the `audio` column to take a look at the input.
    Calling the `audio` column automatically loads and resamples the audio file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns three items:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array` is the speech signal loaded - and potentially resampled - as a 1D array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path` points to the location of the audio file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sampling_rate` refers to how many data points in the speech signal are measured
    per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this tutorial, youâ€™ll use the [Wav2Vec2](https://huggingface.co/facebook/wav2vec2-base)
    model. Take a look at the model card, and youâ€™ll learn Wav2Vec2 is pretrained
    on 16kHz sampled speech audio. It is important your audio dataâ€™s sampling rate
    matches the sampling rate of the dataset used to pretrain the model. If your dataâ€™s
    sampling rate isnâ€™t the same, then you need to resample your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use ðŸ¤— Datasetsâ€™ [cast_column](https://huggingface.co/docs/datasets/v2.16.1/en/package_reference/main_classes#datasets.Dataset.cast_column)
    method to upsample the sampling rate to 16kHz:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `audio` column again to resample the audio file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, load a feature extractor to normalize and pad the input. When padding
    textual data, a `0` is added for shorter sequences. The same idea applies to audio
    data. The feature extractor adds a `0` - interpreted as silence - to `array`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the feature extractor with [AutoFeatureExtractor.from_pretrained()](/docs/transformers/v4.37.2/en/model_doc/auto#transformers.AutoFeatureExtractor.from_pretrained):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Pass the audio `array` to the feature extractor. We also recommend adding the
    `sampling_rate` argument in the feature extractor in order to better debug any
    silent errors that may occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the tokenizer, you can apply padding or truncation to handle variable
    sequences in a batch. Take a look at the sequence length of these two audio samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function to preprocess the dataset so the audio samples are the same
    lengths. Specify a maximum sample length, and the feature extractor will either
    pad or truncate the sequences to match it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the `preprocess_function` to the first few examples in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The sample lengths are now the same and match the specified maximum length.
    You can pass your processed dataset to the model now!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Computer vision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For computer vision tasks, youâ€™ll need an [image processor](main_classes/image_processor)
    to prepare your dataset for the model. Image preprocessing consists of several
    steps that convert images into the input expected by the model. These steps include
    but are not limited to resizing, normalizing, color channel correction, and converting
    images to tensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Image preprocessing often follows some form of image augmentation. Both image
    preprocessing and image augmentation transform image data, but they serve different
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Image augmentation alters images in a way that can help prevent overfitting
    and increase the robustness of the model. You can get creative in how you augment
    your data - adjust brightness and colors, crop, rotate, resize, zoom, etc. However,
    be mindful not to change the meaning of the images with your augmentations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image preprocessing guarantees that the images match the modelâ€™s expected input
    format. When fine-tuning a computer vision model, images must be preprocessed
    exactly as when the model was initially trained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use any library you like for image augmentation. For image preprocessing,
    use the `ImageProcessor` associated with the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the [food101](https://huggingface.co/datasets/food101) dataset (see the
    ðŸ¤— [Datasets tutorial](https://huggingface.co/docs/datasets/load_hub) for more
    details on how to load a dataset) to see how you can use an image processor with
    computer vision datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: Use ðŸ¤— Datasets `split` parameter to only load a small sample from the training
    split since the dataset is quite large!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, take a look at the image with ðŸ¤— Datasets [`Image`](https://huggingface.co/docs/datasets/package_reference/main_classes?highlight=image#datasets.Image)
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/63a998c1115de762652ef3c59b938a3f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Load the image processor with [AutoImageProcessor.from_pretrained()](/docs/transformers/v4.37.2/en/model_doc/auto#transformers.AutoImageProcessor.from_pretrained):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, letâ€™s add some image augmentation. You can use any library you prefer,
    but in this tutorial, weâ€™ll use torchvisionâ€™s [`transforms`](https://pytorch.org/vision/stable/transforms.html)
    module. If youâ€™re interested in using another data augmentation library, learn
    how in the [Albumentations](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/image_classification_albumentations.ipynb)
    or [Kornia notebooks](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/image_classification_kornia.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Here we use [`Compose`](https://pytorch.org/vision/master/generated/torchvision.transforms.Compose.html)
    to chain together a couple of transforms - [`RandomResizedCrop`](https://pytorch.org/vision/main/generated/torchvision.transforms.RandomResizedCrop.html)
    and [`ColorJitter`](https://pytorch.org/vision/main/generated/torchvision.transforms.ColorJitter.html).
    Note that for resizing, we can get the image size requirements from the `image_processor`.
    For some models, an exact height and width are expected, for others only the `shortest_edge`
    is defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The model accepts [`pixel_values`](model_doc/visionencoderdecoder#transformers.VisionEncoderDecoderModel.forward.pixel_values)
    as its input. `ImageProcessor` can take care of normalizing the images, and generating
    appropriate tensors. Create a function that combines image augmentation and image
    preprocessing for a batch of images and generates `pixel_values`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the example above we set `do_resize=False` because we have already resized
    the images in the image augmentation transformation, and leveraged the `size`
    attribute from the appropriate `image_processor`. If you do not resize images
    during image augmentation, leave this parameter out. By default, `ImageProcessor`
    will handle the resizing.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to normalize images as a part of the augmentation transformation,
    use the `image_processor.image_mean`, and `image_processor.image_std` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then use ðŸ¤— Datasets[set_transform](https://huggingface.co/docs/datasets/v2.16.1/en/package_reference/main_classes#datasets.Dataset.set_transform)
    to apply the transforms on the fly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now when you access the image, youâ€™ll notice the image processor has added `pixel_values`.
    You can pass your processed dataset to the model now!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here is what the image looks like after the transforms are applied. The image
    has been randomly cropped and itâ€™s color properties are different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/eee368b92fc814b0667081ba147249f4.png)'
  prefs: []
  type: TYPE_IMG
- en: For tasks like object detection, semantic segmentation, instance segmentation,
    and panoptic segmentation, `ImageProcessor` offers post processing methods. These
    methods convert modelâ€™s raw outputs into meaningful predictions such as bounding
    boxes, or segmentation maps.
  prefs: []
  type: TYPE_NORMAL
- en: Pad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, for instance, when fine-tuning [DETR](./model_doc/detr), the
    model applies scale augmentation at training time. This may cause images to be
    different sizes in a batch. You can use `DetrImageProcessor.pad()` from [DetrImageProcessor](/docs/transformers/v4.37.2/en/model_doc/detr#transformers.DetrImageProcessor)
    and define a custom `collate_fn` to batch images together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Multimodal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For tasks involving multimodal inputs, youâ€™ll need a [processor](main_classes/processors)
    to prepare your dataset for the model. A processor couples together two processing
    objects such as as tokenizer and feature extractor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the [LJ Speech](https://huggingface.co/datasets/lj_speech) dataset (see
    the ðŸ¤— [Datasets tutorial](https://huggingface.co/docs/datasets/load_hub) for more
    details on how to load a dataset) to see how you can use a processor for automatic
    speech recognition (ASR):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For ASR, youâ€™re mainly focused on `audio` and `text` so you can remove the
    other columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now take a look at the `audio` and `text` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Remember you should always [resample](preprocessing#audio) your audio datasetâ€™s
    sampling rate to match the sampling rate of the dataset used to pretrain a model!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Load a processor with [AutoProcessor.from_pretrained()](/docs/transformers/v4.37.2/en/model_doc/auto#transformers.AutoProcessor.from_pretrained):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function to process the audio data contained in `array` to `input_values`,
    and tokenize `text` to `labels`. These are the inputs to the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the `prepare_dataset` function to a sample:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The processor has now added `input_values` and `labels`, and the sampling rate
    has also been correctly downsampled to 16kHz. You can pass your processed dataset
    to the model now!
  prefs: []
  type: TYPE_NORMAL
