- en: Two types of value-based methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Original text: [https://huggingface.co/learn/deep-rl-course/unit2/two-types-value-based-methods](https://huggingface.co/learn/deep-rl-course/unit2/two-types-value-based-methods)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en:  
    
    
    
    
    
    
    
    
    
    
    
  prefs: []
  type: TYPE_NORMAL
- en: In value-based methods, **we learn a value function** that **maps a state to
    the expected value of being at that state.**
  prefs: []
  type: TYPE_NORMAL
- en: '![Value Based Methods](../Images/b4cdd11013b3a06c9b36019b40861897.png)'
  prefs: []
  type: TYPE_IMG
- en: The value of a state is the **expected discounted return** the agent can get
    if it **starts at that state and then acts according to our policy.**
  prefs: []
  type: TYPE_NORMAL
- en: But what does it mean to act according to our policy? After all, we don't have
    a policy in value-based methods since we train a value function and not a policy.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the goal of an **RL agent is to have an optimal policy π*.**
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the optimal policy, we learned about two different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Policy-based methods:* **Directly train the policy** to select what action
    to take given a state (or a probability distribution over actions at that state).
    In this case, we **don’t have a value function.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Two RL approaches](../Images/b0dc2fec6663d304a00631452105e70b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The policy takes a state as input and outputs what action to take at that state
    (deterministic policy: a policy that output one action given a state, contrary
    to stochastic policy that output a probability distribution over actions).'
  prefs: []
  type: TYPE_NORMAL
- en: And consequently, **we don’t define by hand the behavior of our policy; it’s
    the training that will define it.**
  prefs: []
  type: TYPE_NORMAL
- en: '*Value-based methods:* **Indirectly, by training a value function** that outputs
    the value of a state or a state-action pair. Given this value function, our policy **will
    take an action.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the policy is not trained/learned, **we need to specify its behavior.** For
    instance, if we want a policy that, given the value function, will take actions
    that always lead to the biggest reward, **we’ll create a Greedy Policy.**
  prefs: []
  type: TYPE_NORMAL
- en: '![Two RL approaches](../Images/8be62737a01a28f07a8cddd7fd292be0.png)'
  prefs: []
  type: TYPE_IMG
- en: Given a state, our action-value function (that we train) outputs the value of
    each action at that state. Then, our pre-defined Greedy Policy selects the action
    that will yield the highest value given a state or a state action pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, whatever method you use to solve your problem, **you will have
    a policy**. In the case of value-based methods, you don’t train the policy: your
    policy **is just a simple pre-specified function** (for instance, the Greedy Policy)
    that uses the values given by the value-function to select its actions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So the difference is:'
  prefs: []
  type: TYPE_NORMAL
- en: In policy-based training, **the optimal policy (denoted π*) is found by training
    the policy directly.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In value-based training, **finding an optimal value function (denoted Q* or
    V*, we’ll study the difference below) leads to having an optimal policy.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Link between value and policy](../Images/06e7785cc764e6109bfc6c89005a4d92.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, most of the time, in value-based methods, you’ll use **an Epsilon-Greedy
    Policy** that handles the exploration/exploitation trade-off; we’ll talk about
    this when we talk about Q-Learning in the second part of this unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned above, we have two types of value-based functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The state-value function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We write the state value function under a policy π like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![State value function](../Images/c64cf990ee9037cd2363ddd5d4ee5887.png)'
  prefs: []
  type: TYPE_IMG
- en: For each state, the state-value function outputs the expected return if the
    agent **starts at that state** and then follows the policy forever afterward (for
    all future timesteps, if you prefer).
  prefs: []
  type: TYPE_NORMAL
- en: '![State value function](../Images/5035b02fa7e331c3ef7ca3e014d3458c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we take the state with value -7: it''s the expected return starting at that
    state and taking actions according to our policy (greedy policy), so right, right,
    right, down, down, right, right.'
  prefs: []
  type: TYPE_NORMAL
- en: The action-value function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the action-value function, for each state and action pair, the action-value
    function **outputs the expected return** if the agent starts in that state, takes
    that action, and then follows the policy forever after.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of taking action<math><semantics><mrow><mi>a</mi></mrow><annotation
    encoding="application/x-tex">a</annotation></semantics></math>a in state<math><semantics><mrow><mi>s</mi></mrow><annotation
    encoding="application/x-tex">s</annotation></semantics></math>s under a policy<math><semantics><mrow><mi>π</mi></mrow><annotation
    encoding="application/x-tex">π</annotation></semantics></math>π is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Action State value function](../Images/bbd5a8264c0e47c0570c548e02e0804b.png)
    ![Action State value function](../Images/4b94e59b0a0a042bce0bc5932b95b154.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We see that the difference is:'
  prefs: []
  type: TYPE_NORMAL
- en: For the state-value function, we calculate **the value of a state<math><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub></mrow><annotation
    encoding="application/x-tex">S_t</annotation></semantics></math>St​**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the action-value function, we calculate **the value of the state-action
    pair (<math><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>A</mi><mi>t</mi></msub></mrow><annotation
    encoding="application/x-tex">S_t, A_t</annotation></semantics></math>St​,At​ )
    hence the value of taking that action at that state.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Two types of value function](../Images/6d23342c957a8b891dfe93782cee22a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note: We didn''t fill all the state-action pairs for the example of Action-value
    function'
  prefs: []
  type: TYPE_NORMAL
- en: In either case, whichever value function we choose (state-value or action-value
    function), **the returned value is the expected return.**
  prefs: []
  type: TYPE_NORMAL
- en: However, the problem is that **to calculate EACH value of a state or a state-action
    pair, we need to sum all the rewards an agent can get if it starts at that state.**
  prefs: []
  type: TYPE_NORMAL
- en: This can be a computationally expensive process, and that’s **where the Bellman
    equation comes in to help us.**
  prefs: []
  type: TYPE_NORMAL
